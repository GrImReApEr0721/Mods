// ==UserScript==
// @name         Mod大全頁面模擬器
// @namespace    http://tampermonkey.net/
// @version      5.0
// @description  清空當前頁面並將其轉換為Mod大全模擬介面，包含視窗模擬與側邊選單
// @author       程式夥伴
// @match        *://*.moomoo.io/*
// @grant        GM_addStyle
// ==/UserScript==


(function() {
    'use strict';
    if (window.self !== window.top) return;

    const CONFIG = {
        title: "Mod大全",
        themeColor: "#1e1e1e",
        accentColor: "#4CAF50",
        windowHeaderColor: "#333",
        githubOwner: "HaThuDangIu",
        githubRepo: "Moo-Script-Archive-2024",
        githubBranch: "main"
    };

    const MOD_LIBRARY = [];
    let topZIndex = 10000;

    function registerMod(title, author, description, scriptCode) {
        let codeStr = scriptCode || "";
        if (typeof scriptCode === 'function') {
            const funcStr = scriptCode.toString();
            codeStr = funcStr.substring(funcStr.indexOf("{") + 1, funcStr.lastIndexOf("}"));
        }

        let finalTitle = title || "未命名 Mod";
        let finalAuthor = author || "未知作者";
        let finalDesc = description || "無描述";

        try {
            const metadataMatch = codeStr.match(/\/\/ ==UserScript==([\s\S]*?)\/\/ ==\/UserScript==/);
            if (metadataMatch) {
                const metadata = metadataMatch[1];
                const nameMatch = metadata.match(/\/\/\s*@name\s+(.*)/);
                if (nameMatch) finalTitle = nameMatch[1].trim();
                const versionMatch = metadata.match(/\/\/\s*@version\s+(.*)/);
                if (versionMatch) finalTitle += ` v${versionMatch[1].trim()}`;
                const authorMatch = metadata.match(/\/\/\s*@author\s+(.*)/);
                if (authorMatch) finalAuthor = authorMatch[1].trim();
                const descMatch = metadata.match(/\/\/\s*@description\s+(.*)/);
                if (descMatch) finalDesc = descMatch[1].trim();
            } else {
                const firstLine = codeStr.split("\n").find(l => l.trim());
                if (firstLine && firstLine.trim().startsWith("//")) {
                    const txt = firstLine.replace(/^\/\/\s*/, "").trim();
                    if (txt.length && (!title || title === null)) finalTitle = txt.substring(0, 40);
                }
            }
        } catch (e) {}

        const mod = {
            id: Date.now() + Math.random().toString(36).substr(2, 9),
            title: finalTitle,
            author: finalAuthor,
            description: finalDesc,
            scriptCode: codeStr,
            githubUrl: null, // NEW: store the raw GitHub URL if imported
            iframe: null,
            windowEl: null,
            cardEl: null,
            isMinimized: false,
            savedRect: null,
            autoExecuted: false
        };

        MOD_LIBRARY.push(mod);
        return mod;
    }

    function nukePage() {
        if (window.stop) window.stop();
        document.head && (document.head.innerHTML = '');
        document.body.innerHTML = '';
        document.body.style.margin = "0";
        document.body.style.padding = "0";
        document.body.style.backgroundColor = CONFIG.themeColor;
        document.body.style.color = "#ffffff";
        document.body.style.fontFamily = "Arial, sans-serif";
        document.body.style.overflow = "hidden";
    }

    function injectStyles() {
        const css = `
            .mod-header { position: fixed; top: 0; left: 0; width: 100%; height: 60px; background-color: #2d2d2d; border-bottom: 2px solid ${CONFIG.accentColor}; display: flex; align-items: center; padding: 0 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); z-index: 1000; box-sizing: border-box; justify-content: space-between; }
            .header-left { display: flex; align-items: center; }
            .header-right { display: flex; align-items: center; }
            .menu-btn { font-size: 24px; cursor: pointer; margin-right: 20px; color: #fff; user-select: none; }
            .menu-btn:hover { color: ${CONFIG.accentColor}; }
            .mod-title { font-size: 24px; font-weight: bold; color: ${CONFIG.accentColor}; }
            .add-mod-btn { font-size: 28px; font-weight: bold; cursor: pointer; color: #fff; padding: 0 15px; user-select: none; transition: color 0.2s; }
            .add-mod-btn:hover { color: ${CONFIG.accentColor}; }
            .import-btn { font-size: 14px; cursor: pointer; color: #fff; padding: 6px 10px; border-radius: 6px; border: 1px solid #444; margin-left: 10px; user-select: none; }
            .import-btn:hover { background:#333; color: ${CONFIG.accentColor}; }

            .mod-sidebar { position: fixed; top: 60px; left: -250px; width: 250px; height: calc(100% - 60px); background-color: #252525; transition: left 0.3s ease; z-index: 999; border-right: 1px solid #444; padding-top: 20px; }
            .mod-sidebar.open { left: 0; }
            .sidebar-item { padding: 15px 25px; cursor: pointer; border-bottom: 1px solid #333; transition: background 0.2s; }
            .sidebar-item:hover { background-color: #333; color: ${CONFIG.accentColor}; }

            .mod-container { margin-top: 60px; padding: 20px; height: calc(100vh - 60px); overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; box-sizing: border-box; transition: margin-left 0.3s ease; }
            .mod-container.shifted { margin-left: 250px; width: calc(100% - 250px); }

            .mod-card { background-color: #333; border-radius: 8px; padding: 15px; cursor: pointer; border: 1px solid #444; display: flex; flex-direction: column; height: 280px; position: relative; z-index: 1; transition: box-shadow 0.12s, border-color 0.12s; }
            .mod-card:hover { border-color: ${CONFIG.accentColor}; }
            .mod-card.selected { box-shadow: 0 6px 30px rgba(0,0,0,0.6); border-color: ${CONFIG.accentColor}; }

            .card-menu-btn { position: absolute; bottom: 10px; right: 10px; color: #888; font-size: 20px; cursor: pointer; padding: 5px; z-index: 5; user-select: none; line-height: 10px; font-weight: bold; }
            .card-menu-btn:hover { color: #fff; }

            .card-dropdown { position: absolute; bottom: 35px; right: 10px; background-color: #222; border: 1px solid #444; border-radius: 4px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none; flex-direction: column; z-index: 10; min-width: 120px; overflow: hidden; }
            .card-dropdown.show { display: flex; }
            .dropdown-item { padding: 8px 12px; font-size: 13px; color: #ddd; cursor: pointer; transition: background 0.2s; }
            .dropdown-item:hover { background-color: #444; color: #fff; }
            .dropdown-item.delete:hover { background-color: #d32f2f; }

            .card-placeholder { flex: 1; background-color: #222; border-radius: 4px; margin-bottom: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #666; border: 2px dashed #444; overflow: hidden; position: relative; z-index: 2; }
            .card-placeholder-icon { font-size: 40px; margin-bottom: 10px; color: ${CONFIG.accentColor}; }

            .card-title { font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 5px; }
            .card-author { font-size: 12px; color: #888; margin-bottom: 8px; }
            .card-desc { font-size: 14px; color: #ccc; line-height: 1.4; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; }

            .sim-window { position: fixed; min-width: 320px; min-height: 180px; background-color: #1e1e1e; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.8); display: flex; flex-direction: column; overflow: hidden; border: 1px solid #555; resize: both; top: 100px; left: 100px; aspect-ratio: 16 / 9; transform-origin: top left; transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.2s; }
            .sim-window.minimized { position: fixed !important; top: 0 !important; left: 0 !important; z-index: 998 !important; border: 2px solid ${CONFIG.accentColor}; box-shadow: none; resize: none; border-radius: 4px; aspect-ratio: auto !important; }
            .window-header { height: 40px; background-color: ${CONFIG.windowHeaderColor}; display: flex; align-items: center; justify-content: space-between; padding: 0 0 0 15px; border-bottom: 1px solid #444; user-select: none; flex-shrink: 0; cursor: move; }
            .window-title { font-size: 14px; color: #ccc; }
            .window-controls { display: flex; height: 100%; cursor: default; }
            .control-btn { width: 45px; height: 100%; border: none; background: transparent; color: #ccc; font-size: 14px; display: flex; align-items: center; justify-content: center; cursor: pointer; }
            .control-btn:hover { background-color: rgba(255,255,255,0.1); }
            .btn-close:hover { background-color: #E81123; color: white; }
            .window-content { flex: 1; padding: 0; background-color: #000; position: relative; overflow: hidden; }
            .mod-iframe { width: 100%; height: 100%; border: none; display: block; pointer-events: auto; }
            .import-status { font-size: 12px; color: #ddd; margin-left: 12px; opacity: 0.95; }

            .click-shield { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; cursor: pointer; display: none; }
            .sim-window.minimized .click-shield { display: block; }
        `;
        const style = document.createElement('style');
        style.type = 'text/css';
        style.appendChild(document.createTextNode(css));
        document.head.appendChild(style);
    }

    function buildUI() {
        const header = document.createElement('div');
        header.className = 'mod-header';
        header.innerHTML = `
            <div class="header-left">
                <div class="menu-btn">&#9776;</div>
                <div class="mod-title">${CONFIG.title}</div>
            </div>
            <div class="header-right">
                <div class="add-mod-btn" title="新增 Mod">+</div>
                <div class="import-btn" title="從 GitHub 匯入 Mod">匯入 GitHub</div>
                <div class="import-status" id="import-status">未匯入</div>
            </div>
        `;
        document.body.appendChild(header);

        const sidebar = document.createElement('div');
        sidebar.className = 'mod-sidebar';
        sidebar.innerHTML = `
            <div class="sidebar-item">首頁</div>
            <div class="sidebar-item">我的最愛</div>
            <div class="sidebar-item">設定</div>
            <div class="sidebar-item">關於</div>
        `;
        document.body.appendChild(sidebar);

        const container = document.createElement('div');
        container.className = 'mod-container';
        document.body.appendChild(container);

        const modal = document.createElement('div');
        modal.className = 'add-mod-modal';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <span>新增 Mod</span>
                    <div class="modal-close">✕</div>
                </div>
                <div class="modal-body">
                    <div class="input-group">
                        <label>名稱 (選填)</label>
                        <input type="text" id="new-mod-title" placeholder="UserScript 名稱...">
                    </div>
                    <div class="input-group">
                        <label>作者 (選填)</label>
                        <input type="text" id="new-mod-author" placeholder="作者名稱...">
                    </div>
                    <div class="input-group">
                        <label>介紹 (選填)</label>
                        <input type="text" id="new-mod-desc" placeholder="簡短說明...">
                    </div>
                    <div class="input-group">
                        <label>程式碼 (支援 UserScript 檔頭解析)</label>
                        <textarea id="new-mod-code" placeholder="// ==UserScript==\n// @name  My Mod\n// ...\n\nconsole.log('Hello');"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-create">新增</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);

        const modalClose = modal.querySelector('.modal-close');
        const modalCreate = modal.querySelector('.btn-create');
        const inputTitle = modal.querySelector('#new-mod-title');
        const inputAuthor = modal.querySelector('#new-mod-author');
        const inputDesc = modal.querySelector('#new-mod-desc');
        const inputCode = modal.querySelector('#new-mod-code');

        function openModal() {
            inputTitle.value = '';
            inputAuthor.value = '';
            inputDesc.value = '';
            inputCode.value = '';
            modal.classList.add('show');
        }
        function closeModal() { modal.classList.remove('show'); }

        header.querySelector('.add-mod-btn').addEventListener('click', openModal);
        modalClose.addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

        modalCreate.addEventListener('click', () => {
            const title = inputTitle.value.trim() || null;
            const author = inputAuthor.value.trim() || null;
            const desc = inputDesc.value.trim() || null;
            const code = inputCode.value || "";
            const newMod = registerMod(title, author, desc, code);
            renderCard(newMod, container);
            closeModal();
        });

        header.querySelector('.menu-btn').addEventListener('click', () => {
            sidebar.classList.toggle('open');
            container.classList.toggle('shifted');
            let start = performance.now();
            function frame() {
                updateAllMiniWindows();
                if (performance.now() - start < 350) requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        });

        const updateAllMiniWindows = () => {
            MOD_LIBRARY.forEach(mod => {
                if (mod.isMinimized && mod.windowEl) {
                    mod.windowEl.classList.add('scrolling');
                    applyMinimizeTransform(mod);
                }
            });
        };

        let scrollTimeout;
        container.addEventListener('scroll', () => {
            updateAllMiniWindows();
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => { MOD_LIBRARY.forEach(mod => { if (mod.windowEl) mod.windowEl.classList.remove('scrolling'); }); }, 150);
        });

        window.addEventListener('resize', updateAllMiniWindows);
        const observer = new MutationObserver(() => { updateAllMiniWindows(); setTimeout(updateAllMiniWindows, 300); });
        observer.observe(container, { childList: true });

        const importBtn = header.querySelector('.import-btn');
        const statusEl = document.getElementById('import-status');
        importBtn.addEventListener('click', async () => {
            const proceed = confirm("你要從 GitHub 匯入該倉庫內所有 .js / .txt 檔案做為 Mod 項目嗎？\n\n注意：此動作只會把程式碼載入到列表，預設不會執行。");
            if (!proceed) return;

            const autoRun = confirm("是否在匯入完成後**自動執行**每個檔案？\n\n（自動執行會在隱藏 iframe 中執行，不會打開視窗）\n\n請僅在你信任該程式碼時選擇「確定」。");
            statusEl.textContent = `正在從 GitHub 取得檔案… (autoRun=${autoRun ? "是" : "否"})`;
            try {
                await importModsFromGitHub(container, statusEl, autoRun);
            } catch (e) {
                console.error(e);
                statusEl.textContent = '匯入失敗：' + (e.message || '錯誤');
            }
        });

        buildUI.container = container;
        MOD_LIBRARY.forEach((mod) => { renderCard(mod, container); });
    }

    function applyMinimizeTransform(mod) {
        const win = mod.windowEl;
        const placeholder = mod.cardEl.querySelector('.card-placeholder');
        if (!win || !placeholder) return;
        const targetRect = placeholder.getBoundingClientRect();
        const baseW = mod.savedRect ? mod.savedRect.width : window.innerWidth * 0.6;
        const baseH = mod.savedRect ? mod.savedRect.height : (window.innerWidth * 0.6 * (9/16));
        const scaleX = targetRect.width / baseW;
        const scaleY = targetRect.height / baseH;
        const scale = Math.min(scaleX, scaleY);
        const scaledW = baseW * scale;
        const scaledH = baseH * scale;
        const offsetX = (targetRect.width - scaledW) / 2;
        const offsetY = (targetRect.height - scaledH) / 2;
        const finalX = targetRect.left + offsetX;
        const finalY = targetRect.top + offsetY;
        win.style.width = baseW + 'px';
        win.style.height = baseH + 'px';
        win.style.transform = `translate(${finalX}px, ${finalY}px) scale(${scale})`;
    }

    function toggleMinimize(mod, minimize) {
        const win = mod.windowEl;
        if (!win) return;
        if (minimize) {
            if (win.classList.contains('maximized')) {
                win.classList.remove('maximized');
                const maxBtn = win.querySelector('.btn-max');
                if (maxBtn) maxBtn.textContent = '☐';
                mod.savedRect = { width: window.innerWidth, height: window.innerHeight, top: 0, left: 0 };
            } else {
                mod.savedRect = { width: win.offsetWidth, height: win.offsetHeight, top: win.offsetTop, left: win.offsetLeft };
            }
            mod.isMinimized = true;
            win.classList.add('minimized');
            requestAnimationFrame(() => applyMinimizeTransform(mod));
        } else {
            mod.isMinimized = false;
            win.classList.remove('minimized');
            win.style.transform = '';
            if (mod.savedRect) {
                win.style.width = mod.savedRect.width + 'px';
                win.style.height = mod.savedRect.height + 'px';
                win.style.top = mod.savedRect.top + 'px';
                win.style.left = mod.savedRect.left + 'px';
            }
            win.style.zIndex = ++topZIndex;
        }
    }

    function toggleMaximize(mod, win, maxBtn) {
        if (mod.isMinimized) {
            toggleMinimize(mod, false);
            setTimeout(() => { win.classList.add('maximized'); maxBtn.textContent = '❐'; }, 50);
            return;
        }
        if (win.classList.contains('maximized')) {
            win.classList.remove('maximized');
            maxBtn.textContent = '☐';
            const scaleFactor = 0.6;
            const initialWidth = window.innerWidth * scaleFactor;
            const initialHeight = initialWidth * (9 / 16);
            const centerX = (window.innerWidth - initialWidth) / 2;
            const centerY = (window.innerHeight - initialHeight) / 2;
            win.style.width = initialWidth + 'px';
            win.style.height = initialHeight + 'px';
            win.style.left = centerX + 'px';
            win.style.top = centerY + 'px';
        } else {
            win.classList.add('maximized');
            maxBtn.textContent = '❐';
        }
    }

    function createModWindow(mod) {
        if (mod.windowEl) return mod.windowEl;
        const win = document.createElement('div');
        win.className = 'sim-window';
        const scaleFactor = 0.6;
        const initialWidth = window.innerWidth * scaleFactor;
        const initialHeight = initialWidth * (9 / 16);
        const centerX = (window.innerWidth - initialWidth) / 2;
        const centerY = (window.innerHeight - initialHeight) / 2;
        win.style.width = initialWidth + 'px';
        win.style.height = initialHeight + 'px';
        win.style.left = centerX + 'px';
        win.style.top = centerY + 'px';
        win.style.zIndex = ++topZIndex;
        win.innerHTML = `
            <div class="click-shield" title="點擊還原視窗"></div>
            <div class="window-header">
                <div class="window-title">執行中 - ${mod.title}</div>
                <div class="window-controls">
                    <button class="control-btn btn-min" title="縮小至卡片">─</button>
                    <button class="control-btn btn-max" title="最大化">☐</button>
                    <button class="control-btn btn-close" title="關閉">✕</button>
                </div>
            </div>
            <div class="window-content"></div>
        `;
        document.body.appendChild(win);

        const header = win.querySelector('.window-header');
        const minBtn = win.querySelector('.btn-min');
        const maxBtn = win.querySelector('.btn-max');
        const closeBtn = win.querySelector('.btn-close');
        const content = win.querySelector('.window-content');
        const shield = win.querySelector('.click-shield');

        let isDragging = false;
        let startX, startY, initialLeft, initialTop;

        header.addEventListener('mousedown', (e) => {
            if(e.target.closest('.control-btn')) return;
            isDragging = true;
            win.classList.add('dragging');
            startX = e.clientX;
            startY = e.clientY;
            initialLeft = win.offsetLeft;
            initialTop = win.offsetTop;
            win.style.zIndex = ++topZIndex;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            if (win.classList.contains('maximized')) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            win.style.left = `${initialLeft + dx}px`;
            win.style.top = `${initialTop + dy}px`;
        });

        document.addEventListener('mouseup', () => { isDragging = false; win.classList.remove('dragging'); });

        win.addEventListener('mousedown', () => { if (!mod.isMinimized) win.style.zIndex = ++topZIndex; });
        minBtn.addEventListener('click', () => toggleMinimize(mod, true));
        shield.addEventListener('click', () => toggleMinimize(mod, false));
        maxBtn.addEventListener('click', () => toggleMaximize(mod, win, maxBtn));
        closeBtn.addEventListener('click', () => {
            if (mod.iframe) {
                try { mod.iframe.remove(); } catch(e){}
            }
            win.remove();
            mod.iframe = null;
            mod.windowEl = null;
            mod.isMinimized = false;
        });

        mod.windowEl = win;
        return { win, content };
    }

    // NEW: Fetch and inject the mod code
    async function fetchAndInjectMod(mod) {
        // If code already exists, no need to fetch
        if (mod.scriptCode && mod.scriptCode.trim()) {
            return injectModIntoWindow(mod);
        }

        // If we have a GitHub URL, fetch it
        if (mod.githubUrl) {
            try {
                const response = await fetch(mod.githubUrl);
                if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
                const code = await response.text();
                mod.scriptCode = code;

                // Re-parse metadata after fetching
                try {
                    const metadataMatch = code.match(/\/\/ ==UserScript==([\s\S]*?)\/\/ ==\/UserScript==/);
                    if (metadataMatch) {
                        const metadata = metadataMatch[1];
                        const nameMatch = metadata.match(/\/\/\s*@name\s+(.*)/);
                        if (nameMatch) mod.title = nameMatch[1].trim();
                        const versionMatch = metadata.match(/\/\/\s*@version\s+(.*)/);
                        if (versionMatch) mod.title += ` v${versionMatch[1].trim()}`;
                        const authorMatch = metadata.match(/\/\/\s*@author\s+(.*)/);
                        if (authorMatch) mod.author = authorMatch[1].trim();
                        const descMatch = metadata.match(/\/\/\s*@description\s+(.*)/);
                        if (descMatch) mod.description = descMatch[1].trim();

                        // Update card display
                        if (mod.cardEl) {
                            const titleEl = mod.cardEl.querySelector('.card-title');
                            const authorEl = mod.cardEl.querySelector('.card-author');
                            const descEl = mod.cardEl.querySelector('.card-desc');
                            if (titleEl) titleEl.textContent = mod.title;
                            if (authorEl) authorEl.textContent = `作者: ${mod.author}`;
                            if (descEl) descEl.textContent = mod.description;
                        }
                    }
                } catch (e) {}

                return injectModIntoWindow(mod);
            } catch (e) {
                alert(`無法載入 Mod 程式碼：${e.message}`);
                throw e;
            }
        } else {
            alert('此 Mod 沒有可用的程式碼');
            throw new Error('No code available');
        }
    }

    function injectModIntoWindow(mod) {
        const { win, content } = createModWindow(mod);
        const newIframe = document.createElement('iframe');
        newIframe.src = window.location.href;
        newIframe.className = 'mod-iframe';

        newIframe.onload = () => {
            try {
                const script = newIframe.contentDocument.createElement('script');
                script.textContent = mod.scriptCode;
                newIframe.contentDocument.body.appendChild(script);
                console.log(`Mod [${mod.title}] 已注入並執行。`);
            } catch (e) {
                console.error(e);
                alert('注入失敗，請檢查控制台。');
            }
        };

        content.appendChild(newIframe);
        mod.iframe = newIframe;
    }

    function renderCard(mod, container) {
        const card = document.createElement('div');
        card.className = 'mod-card';
        mod.cardEl = card;

        card.innerHTML = `
            <div class="card-placeholder">
                <div class="card-placeholder-icon">▶</div>
                <div>點擊開啟</div>
            </div>
            <div class="card-title">${mod.title}</div>
            <div class="card-author">作者: ${mod.author}</div>
            <div class="card-desc">${mod.description}</div>

            <div class="card-menu-btn" title="更多選項">⋮</div>

            <div class="card-dropdown">
                <div class="dropdown-item copy-btn">複製</div>
                <div class="dropdown-item viewcode-btn">查看程式碼</div>
                <div class="dropdown-item inject-btn">注入到 iframe (危險)</div>
                <div class="dropdown-item delete delete-btn">刪除</div>
            </div>
        `;

        const menuBtn = card.querySelector('.card-menu-btn');
        const dropdown = card.querySelector('.card-dropdown');
        const copyBtn = card.querySelector('.copy-btn');
        const deleteBtn = card.querySelector('.delete-btn');
        const viewCodeBtn = card.querySelector('.viewcode-btn');
        const injectBtn = card.querySelector('.inject-btn');

        menuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.card-dropdown.show').forEach(el => { if (el !== dropdown) el.classList.remove('show'); });
            dropdown.classList.toggle('show');
        });

        document.addEventListener('click', (e) => { if (!card.contains(e.target)) dropdown.classList.remove('show'); });

        copyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.remove('show');
            const newMod = registerMod(mod.title + " (複製)", mod.author, mod.description, mod.scriptCode);
            if (mod.githubUrl) newMod.githubUrl = mod.githubUrl;
            renderCard(newMod, container);
        });

        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.remove('show');
            if (confirm(`確定要刪除 "${mod.title}" 嗎？`)) {
                if (mod.iframe) try { mod.iframe.remove(); } catch(e){}
                if (mod.windowEl) try { mod.windowEl.remove(); } catch(e){}
                mod.iframe = null;
                mod.windowEl = null;
                card.remove();
                const index = MOD_LIBRARY.indexOf(mod);
                if (index > -1) MOD_LIBRARY.splice(index, 1);
            }
        });

        viewCodeBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            dropdown.classList.remove('show');

            // Fetch code if needed
            if (mod.githubUrl && (!mod.scriptCode || !mod.scriptCode.trim())) {
                try {
                    const response = await fetch(mod.githubUrl);
                    if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
                    mod.scriptCode = await response.text();
                } catch (err) {
                    alert(`無法載入程式碼：${err.message}`);
                    return;
                }
            }

            const w = window.open("", "_blank", "width=800,height=600,scrollbars=yes");
            w.document.title = `${mod.title} - 程式碼`;
            w.document.body.style.background = "#121212";
            w.document.body.style.color = "#ddd";
            const pre = w.document.createElement('pre');
            pre.style.whiteSpace = "pre-wrap";
            pre.style.fontFamily = "monospace";
            pre.style.padding = "12px";
            pre.style.margin = "10px";
            pre.style.borderRadius = "6px";
            pre.style.background = "#0b0b0b";
            pre.textContent = mod.scriptCode || "// (無程式碼)";
            w.document.body.appendChild(pre);
        });

        injectBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            dropdown.classList.remove('show');
            if (!confirm("注意：按下注入會把程式碼寫入 iframe 的 body 並執行。請僅在您信任此程式碼時執行。\n確定要注入並執行？")) return;

            try {
                await fetchAndInjectMod(mod);
            } catch (err) {
                console.error('Inject failed:', err);
            }
        });

        // FIXED: Card click now fetches first, then injects
        card.addEventListener('click', async () => {
            // if there is an existing minimized window, restore it
            if (mod.windowEl && mod.isMinimized) {
                toggleMinimize(mod, false);
                return;
            }
            // if window exists, bring to front
            if (mod.windowEl) {
                mod.windowEl.style.zIndex = ++topZIndex;
                return;
            }

            // NEW: Fetch and inject when clicking the card
            try {
                document.querySelectorAll('.mod-card.selected').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                await fetchAndInjectMod(mod);
            } catch (err) {
                console.error('Failed to open mod:', err);
            }
        });

        container.appendChild(card);
    }

    function autoExecuteInHiddenIframe(mod) {
        return new Promise((resolve, reject) => {
            try {
                const hidden = document.createElement('iframe');
                hidden.style.display = 'none';
                hidden.setAttribute('sandbox', '');
                hidden.srcdoc = '<!doctype html><html><head><meta charset="utf-8"></head><body></body></html>';
                document.body.appendChild(hidden);

                const to = setTimeout(() => {
                    try {
                        if (hidden.contentDocument && hidden.contentDocument.body) {
                            const script = hidden.contentDocument.createElement('script');
                            script.textContent = mod.scriptCode;
                            hidden.contentDocument.body.appendChild(script);
                            clearTimeout(to);
                            mod.iframe = hidden;
                            resolve();
                        } else {
                            clearTimeout(to);
                            reject(new Error('hidden iframe inaccessible after timeout'));
                        }
                    } catch (err) {
                        clearTimeout(to);
                        reject(err);
                    }
                }, 8000);

                hidden.onload = () => {
                    try {
                        const doc = hidden.contentDocument;
                        const script = doc.createElement('script');
                        script.textContent = mod.scriptCode;
                        doc.body.appendChild(script);
                        clearTimeout(to);
                        mod.iframe = hidden;
                        resolve();
                    } catch (e) {
                        clearTimeout(to);
                        reject(e);
                    }
                };
            } catch (e) {
                reject(e);
            }
        });
    }

    async function importModsFromGitHub(container, statusEl, autoRun = false) {
        const apiUrl = `https://api.github.com/repos/${CONFIG.githubOwner}/${CONFIG.githubRepo}/git/trees/${CONFIG.githubBranch}?recursive=1`;
        statusEl.textContent = '取得檔案清單…';
        const treeResp = await fetch(apiUrl).then(r => { if (!r.ok) throw new Error('GitHub API 取得失敗: ' + r.status); return r.json(); });

        if (!treeResp.tree || !Array.isArray(treeResp.tree)) throw new Error('無法取得檔案清單');

        const entries = treeResp.tree.filter(e => {
            if (!e.path) return false;
            const lower = e.path.toLowerCase();
            return (lower.endsWith('.js') || lower.endsWith('.txt'));
        });

        if (entries.length === 0) { statusEl.textContent = '在倉庫中找不到 .js 或 .txt 檔案'; return; }

        statusEl.textContent = `找到 ${entries.length} 個檔案，載入中…`;

        let loaded = 0;
        const errors = [];

        // NEW: Don't download code immediately, just create cards with GitHub URLs
        for (const f of entries) {
            const rawUrl = `https://raw.githubusercontent.com/${CONFIG.githubOwner}/${CONFIG.githubRepo}/${CONFIG.githubBranch}/${f.path}`;

            try {
                if (autoRun) {
                    // If auto-run is enabled, fetch and execute
                    const text = await fetch(rawUrl).then(r => { if (!r.ok) throw new Error(`raw fetch failed ${r.status}`); return r.text(); });
                    const mod = registerMod(null, null, null, text);
                    mod.githubUrl = rawUrl;
                    renderCard(mod, container);

                    await autoExecuteInHiddenIframe(mod);
                    mod.autoExecuted = true;
                    loaded++;
                    statusEl.textContent = `已執行（隱藏） ${loaded}/${entries.length}：${f.path}`;
                } else {
                    // Don't fetch code yet, just store the URL
                    const mod = registerMod(f.path, "GitHub", `來自: ${f.path}`, "");
                    mod.githubUrl = rawUrl;
                    renderCard(mod, container);
                    loaded++;
                    statusEl.textContent = `已載入 ${loaded}/${entries.length}：${f.path}`;
                }

                await new Promise(res => setTimeout(res, 50));
            } catch (err) {
                errors.push({ path: f.path, error: err.message || err.toString() });
                console.error('import error', f.path, err);
                statusEl.textContent = `匯入錯誤：${f.path}`;
            }
        }

        statusEl.textContent = `匯入完成：已載入 ${loaded}/${entries.length}` + (errors.length ? `，${errors.length} 個失敗` : '');
        if (errors.length) console.warn('Import errors:', errors);
    }

    setTimeout(() => {
        nukePage();
        injectStyles();
        buildUI();
    }, 500);

})();