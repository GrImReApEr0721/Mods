// ==UserScript==
// @name         ü©∏ Red Will ü©∏
// @namespace    ü©∏ Red Elite ü©∏
// @version      1.8-SaVeGe-Version
// @description  Official Red Elite's Mod, Very advanced and powerful.
// @icon         https://media.discordapp.net/attachments/1238074276368613440/1262011861373685800/RE.png?ex=66985762&is=669705e2&hm=d5e637b4c6ca1c7e8568b7aad303fd7d2d420db12d63ef4523a2d24fd6a19aac&=&format=webp&quality=lossless&width=314&height=314
// @match        *://*.moomoo.io/*
// @grant        none
// ==/UserScript==

let isHidden = false;

(function () {
    function a() {
        return 'ÿ°∆É∆≠‚ß´3‚±≠‚Ñ¢A‚àûÿ°‚©éZ¬ßœù‚ï≥7‚ßñ#ŸÉ¬™‚ãÜ8‚üÜ%ŸáŸÄ54yh54h65j65kj76k¬øùåÜ1&‚åáŸÑ@¬∂‚õßT9QŸèb+ÿ¥67k67k67Œ©x‚àÜŒ®√¶‚âà√ß‚àö‚à´~`¬°√ü¬¢‚äï‚öõ‚òØ‚üÅÍô®‚≥©·∏Ö‚â≠»Ω‚Ç£ÿ°';
    }

    function b() {
        return Math.random();
    }

    function c() {
        return new Array(10).fill().map(() => Math.floor(Math.random() * 100));
    }

    function d(x) {
        return x.split('').reverse().join('');
    }

    let e = 0;
    let f = 'Existence is fake, Dance for me. You wont be able to deobfuscate my mod!';
    let g = [1, 2, 3, 4, 5];
    let h = {
        a: 1
        , b: 2
        , c: 3
    };
    let i = [g, h];

    for (let j = 0; j < 10; j++) {
        e += j * (Math.random() - 0.5);
    }

    while (e < 100) {
        e += b();
    }

    let k = (function () {
        let l = a();
        let m = c();
        let n = d(f);
        return [l, m, n];
    })();

    (function () {
        let o = 0;
        for (let p = 0; p < 1000; p++) {
            o += Math.sin(p);
        }
    })();

    (function () {
        let q = '';
        for (let r = 0; r < 100; r++) {
            q += String.fromCharCode(Math.floor(Math.random() * 256));
        }
    })();

    if (typeof window !== 'undefined' && window.document) {
        console.log('SaVeGe is happy you dont try to deobfuscate my code.');
        let securedBySaVeGe = document.createElement('div');
        securedBySaVeGe.innerHTML = `
    <div id="redEliteSecurity">
      <h1 style="position: absolute; font-family: 'Jacquard 12 Charted'; font-weight: 200; top: -50px; font-size: 200px; color: #ff4d4d;">ü©∏ Red Elite ü©∏</h1>
        <div id="redEliteBox">
            <h1>Red Elite</h1>
            <h2>Secured by SaVeGe</h2>
            <input type="password" id="redElitePassword" placeholder="What's the code?" />
            <button id="redEliteSubmit">! ENTER !</button>
        </div>
        <h1 style="position: absolute; font-family: 'Jacquard 12'; font-weight: 100; bottom: 300px; left: 100px; transform: rotate(25deg); transform-origin: left bottom; font-size: 100px; color: #ff4d4d;">1.8-SaVeGe-Version</h1>
    </div>
`;
        document.body.appendChild(securedBySaVeGe);

        let stailishing = document.createElement('style');
        stailishing.innerHTML = `
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@500&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Jacquard+12+Charted&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Jacquard+12&display=swap');

    #redEliteSecurity {
        display: flex;
        justify-content: center;
        align-items: center;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(20, 0, 0, 1);
        z-index: 10000;
    }

    #redEliteBox {
        background: linear-gradient(135deg, #ff4d4d, #330000);
        padding: 10px;
        border-radius: 30px;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
        text-align: center;
        padding-bottom: 20px;
        animation: fadeIn 1s ease-in-out;
    }

    #redEliteBox h1 {
        color: white;
        font-family: 'Montserrat', sans-serif;
        margin-bottom: 20px;
        font-size: 50px;
    }

    #redEliteBox h2 {
        color: white;
        font-family: 'Montserrat', sans-serif;
        margin-bottom: 20px;
        font-size: 10px;
    }

    #redElitePassword {
        width: 80%;
        padding: 15px;
        margin-bottom: 20px;
        border: none;
        border-radius: 20px;
        font-size: 1em;
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
    }

    #redEliteSubmit {
        background-color: #ff1a1a;
        color: white;
        border: none;
        padding: 10px 25px;
        font-size: 1em;
        border-radius: 10px;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.3s ease;
    }

    #redEliteSubmit:hover {
        background-color: #cc0000;
        transform: scale(1.05);
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }
`;
        document.head.appendChild(stailishing);

        let ez2 = "S";
        let ez4 = "A";
        let ez7 = "5";
        let ez8 = "6";
        let ez5 = "-";
        let ez6 = "2";
        let ez1 = "H";

        let niggerSecurity = async function (autoHealing) {
            let wef0vb9b903 = new TextEncoder().encode(autoHealing);
            let fer398vfreg = await crypto.subtle.digest(ez2 + ez1 + ez4 + ez5 + ez6 + ez7 + ez8, wef0vb9b903);
            let g54herhg4 = Array.from(new Uint8Array(fer398vfreg));
            let erg8743gh88 = g54herhg4.map(b => b.toString(16).padStart(2, '0')).join('');
            return erg8743gh88;
        }

        const oeferrg9 = "let isExistenceReal"
        const oerg9 = "let isMooMooReal = false"
        const oefer043vrg9 = "let autohealing = true"
        const wef094j9 = "let hello = false"

        document.getElementById('redEliteSubmit').addEventListener('click', async () => {
            let vnuerv8438 = document.getElementById('redElitePassword').value;
            let okwerkwe99999 = await niggerSecurity(vnuerv8438);
            if (okwerkwe99999 === x38x849xc) {
                localStorage.setItem(oeferrg9 + oerg9 + oefer043vrg9 + wef094j9, 'true');
                document.getElementById('redEliteSecurity').style.display = 'none';
                runMod();
            } else {
                alert(`Haizzz, You're so cute...`);
            }
        });

        let runMod = function () {
            document.addEventListener("keydown", function (event) {
                if (event.keyCode === 192) {
                    let chatHolder = document.getElementById("gameUI");
                    if (chatHolder) {
                        let currentDisplay = chatHolder.style.display;
                        chatHolder.style.display = currentDisplay === "none" ? "block" : "none";
                    }
                }
            });

            let fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Montserrat:wght@500&display=swap';
            document.head.appendChild(fontLink);

            let gameFont = document.createElement('link');
            gameFont.rel = 'stylesheet';
            gameFont.href = 'https://fonts.googleapis.com/css2?family=Jacquard+12+Charted&display=swap';
            document.head.appendChild(gameFont);

            document.head.appendChild(document.createElement("style")).textContent = `
* {
font-family: 'Montserrat', sans-serif;
}
#youtuberOf {
	position: absolute;
	top: 10px;
	left: 10px;
	color: #ff6666;
	font-size: 24px;
}

.ytLink {
	color: #ff6666;
	font-size: 24px;
	text-decoration: none;
}

.ytLink:hover {
	color: #cc3333;
}

#featuredYoutube {
	margin-top: 5px;
}

#featuredYoutube a {
	color: #ff6666 !important;
}

#featuredYoutube a:hover {
	color: #cc3333 !important;
}

#mainMenu {
	background-color: rgba(0, 0, 0, 0.7);
	position: absolute;
	width: 100%;
	height: 100%;
	z-index: 10;
}

#menuContainer {
	width: 100%;
	white-space: nowrap;
	text-align: center;
	position: absolute;
	top: 45%;
	transform: translateY(-50%);
}

#partyButton {
	position: absolute;
	color: #ff6666;
	top: 20px;
	right: 20px;
	font-size: 24px;
	text-decoration: none;
}

#joinPartyButton {
	position: absolute;
	top: 54px;
	right: 20px;
	cursor: pointer;
}

#pingDisplay {
	position: absolute;
	top: 20px;
	left: 50%;
	transform: translateX(-50%);
	color: #ff6666;
}

#shutdownDisplay {
	position: absolute;
	top: 20px;
	left: 50%;
	transform: translateX(-50%);
	color: #ff6666;
	font-size: 25px;
	z-index: 100;
	pointer-events: none;
}

#settingsButton {
	position: absolute;
	cursor: pointer;
	display: none;
}

#followText {
	position: absolute;
	bottom: 40px;
	left: 10px;
	color: #ff6666;
	font-size: 22px;
}

#twitterFollow {
	position: absolute;
	bottom: 10px;
	left: 10px;
}

#youtubeFollow {
	position: absolute;
	bottom: 10px;
	left: 10px;
}

#linksContainer1 {
	border-radius: 4px;
	position: absolute;
	bottom: 0px;
	left: 0px;
	background-color: #ff3333;
	font-size: 20px;
	padding: 8px;
	border-radius: 0 4px 0 0;
	color: #fff;
}

#linksContainer2 {
	border-radius: 4px;
	position: absolute;
	bottom: 0px;
	right: 0px;
	background-color: #ff3333;
	text-align: right;
	font-size: 20px;
	padding: 8px;
	border-radius: 4px 0 0 0;
	color: #fff;
}

#loadingText {
	font-size: 45px;
	color: #ff6666;
	text-align: center;
}

#loadingText a {
	display: block;
	color: #ff3333;
}

.menuCard, .adMenuCard {
	vertical-align: top;
	text-align: left;
	white-space: normal;
	word-wrap: break-word;
	margin: 5px;
	display: inline-block;
	width: 300px;
	padding: 18px;
	background-color: #2b2b2b;
	box-shadow: 0px 7px #cc3333;
	border-radius: 4px;
	overflow: hidden;
	color: #fff;
}

.adMenuCard {
	min-width: 0;
	min-height: 0;
	height: initial;
	width: initial;
	padding: 0;
	box-shadow: none;
}

.menuHeader {
	font-size: 24px;
	color: #ff6666;
	margin-bottom: 5px;
}

.menuText {
	font-size: 18px;
	color: #cccccc;
	margin-bottom: 10px;
}

#serverBrowser select {
	width: 100%;
	height: 24px;
	background-color: #2b2b2b;
	color: #fff;
	border: none;
	outline: none;
}

#altServer {
	width: 100%;
	text-align: center;
	margin-top: 10px;
}

#skinColorHolder {
	width: 100%;
	padding: 0px;
	padding-top: 5px;
	padding-bottom: 0px;
}

.activeSkin {
	border-radius: 8px !important;
	border: 3px solid #ff6666;
}

.skinColorItem {
	cursor: pointer;
	display: inline-block;
	margin-right: 10px;
	width: 30px;
	height: 30px;
	border-radius: 20px;
	border: 3px solid #525252;
}

.skinColorItem:hover {
	border-radius: 8px;
	border-color: #ff6666;
}

.settingRadio {
	font-size: 18px;
	color: #cccccc;
	margin-bottom: 10px;
}

#gameName {
	font-size: 170px;
	margin-bottom: -25px;
	text-shadow:
			0 1px 0 #cc3333,
			0 2px 0 #cc3333,
			0 3px 0 #cc3333,
			0 4px 0 #cc3333,
			0 5px 0 #cc3333,
			0 6px 0 #cc3333,
			0 7px 0 #cc3333,
			0 8px 0 #cc3333,
			0 9px 0 #cc3333;
	color: #fff;
}

#nameInput {
	text-align: center;
	font-size: 26px;
	margin-bottom: 16px;
	padding: 6px;
	border: none;
	outline: none;
	box-sizing: border-box;
	color: #4A4A4A;
	background-color: #e5e3e3;
	width: 100%;
	border-radius: 4px;
}

.menuButton {
	text-align: center;
	font-size: 23px;
	padding: 6px;
	box-sizing: border-box;
	color: #fff;
	background-color: #ff6666;
	width: 100%;
	border-radius: 4px;
	cursor: pointer;
}

.menuButton:hover {
	background-color: #cc3333;
}

#gameUI {
	pointer-events: none;
	position: absolute;
	width: 100%;
	height: 100%;
	z-index: 2;
}

#chatHolder {
	position: absolute;
	bottom: 200px;
	width: 100%;
	text-align: center;
}

#chatBox {
	padding: 6px;
	font-size: 20px;
	color: #fff;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	pointer-events: all;
	border: 0;
}
#chatBox:focus {
	outline: none;
}

#topInfoHolder {
	position: absolute;
	right: 20px;
	top: 20px;
}

#leaderboard {
	color: #ff6666;
	font-size: 31px;
	text-align: left;
	padding: 10px;
	padding-top: 7px;
	padding-bottom: 5px;
	width: 220px;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
}

.leaderHolder {
	overflow: hidden;
	white-space: nowrap;
}

#killCounter {
	right: 0px;
	margin-top: 10px;
	color: #ff6666;
	font-size: 28px;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	background-image: url(../img/icons/skull.png);
}

.leaderScore {
	text-align: right;
	float: right;
	margin-left: 10px;
	display: inline-block;
	font-size: 22px;
}

.leaderboardItem {
	float: left;
	display: inline-block;
	max-width: 140px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	font-size: 22px;
}

.uiElement, .resourceDisplay {
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	color: #fff;
	padding: 10px;
	padding-top: 5px;
	padding-bottom: 5px;
	font-size: 28px;
}

.resourceDisplay {
	position: absolute;
	right: 20px;
	height: 35px;
	text-align: right;
	line-height: 39px;
	padding-left: 10px;
	padding-right: 40px;
	background-size: 28px;
	background-repeat: no-repeat;
	background-position: right 6px center;
}

#foodDisplay {
	background-image: url(../img/resources/food_ico.png);
}

#woodDisplay {
	background-image: url(../img/resources/wood_ico.png);
}

#stoneDisplay {
	background-image: url(../img/resources/stone_ico.png);
}

#scoreDisplay {
	right: inherit;
	left: 20px;
	bottom: 160px;
	text-align: left;
	padding-left: 40px;
	padding-right: 10px;
	background-position: left 6px center;
	background-image: url(../img/resources/gold_ico.png);
}

#stoneDisplay {
	bottom: 20px;
}

#woodDisplay {
	bottom: 75px;
}

#foodDisplay {
	bottom: 130px;
}

#actionBar {
	margin-bottom: 15px;
	width: 100%;
	text-align: center;
}

.actionBarItem {
	width: 66px;
	height: 66px;
	margin-left: 5px;
	margin-right: 5px;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	display: inline-block;
	cursor: pointer;
	pointer-events: all;
	background-size: cover;
}

.actionBarItem:hover {
	background-color: rgba(50, 50, 50, 0.5);
}

.itemIcon {
	width: 66px;
	height: 66px;
}

#mapDisplay {
	position: absolute;
	bottom: 20px;
	left: 20px;
	display: inline-block;
	width: 130px;
	height: 130px;
	pointer-events: all;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
}

.gameButton {
	position: absolute;
	top: 20px;
	padding: 5px;
	cursor: pointer;
	pointer-events: all;
}

.gameButton:hover {
	background-color: rgba(50, 50, 50, 0.5);
}

#allianceButton {
	right: 270px;
}

#leaderboardButton {
	display: none;
	-webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
}

#leaderboardButton:focus {
	outline: none !important;
}

#storeButton {
	right: 330px;
}

#chatButton {
	right: 390px;
}

#storeMenu {
	display: none;
	width: 100%;
	position: absolute;
	text-align: center;
	top: 50%;
	transform: translateY(-50%);
}

#storeHolder {
	pointer-events: all;
	width: 400px;
	display: inline-block;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	color: #fff;
	padding: 10px;
	height: 200px;
	max-height: calc(100vh - 200px);
	overflow-y: scroll;
	-webkit-overflow-scrolling: touch;
}

.storeTab {
	width: 183px;
	font-size: 26px;
	display: inline-block;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	color: #fff;
	padding: 10px;
	pointer-events: all;
	cursor: pointer;
}

.storeTab:hover {
	background-color: rgba(50, 50, 50, 0.5);
}

.storeItem {
	color: #fff;
	padding: 5px;
	font-size: 24px;
	text-align: left;
	cursor: pointer;
}

.itemPrice {
	margin-top: 5px;
	float: right;
	display: inline-block;
	color: rgba(255,255,255,0.5);
	font-size: 24px;
	padding-right: 5px;
}

.hatPreview {
	margin-top: -5px;
	width: 45px;
	height: 45px;
	display: inline-block;
	vertical-align: middle;
	padding-right: 10px;
}

#allianceMenu {
	display: none;
	width: 100%;
	position: absolute;
	text-align: center;
	top: 50%;
	transform: translateY(-50%);
}

#allianceHolder {
	pointer-events: all;
	height: 200px;
	max-height: calc(100vh - 260px);
	overflow-y: scroll;
	-webkit-overflow-scrolling: touch;
	width: 350px;
	display: inline-block;
	text-align: left;
	padding: 10px;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
}

.allianceItem {
	font-size: 24px;
	color: #fff;
	padding: 5px;
}

.joinAlBtn {
	float: right;
	font-size: 24px;
	text-align: right;
	cursor: pointer;
	color: #ff6666;
}

.joinAlBtn:hover {
	color: #cc3333;
}

.notificationText {
	vertical-align: top;
	font-size: 25px;
	color: #fff;
	display: inline-block;
}

.notifButton {
	padding: 5px;
	margin-left: 10px;
	display: inline-block;
	cursor: pointer;
	pointer-events: all;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
}

.notifButton:hover {
	background-color: rgba(50, 50, 50, 0.5);
}

#noticationDisplay {
	vertical-align: top;
	position: absolute;
	right: 270px;
	top: 80px;
	text-align: right;
}

.allianceButtonM {
	pointer-events: all;
	cursor: pointer;
	margin-top: 10px;
	font-size: 24px;
	color: #fff;
	padding: 5px;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	text-align: center;
	display: inline-block;
}

.allianceButtonM:hover {
	background-color: rgba(50, 50, 50, 0.5);
}

#allianceInput {
	pointer-events: all;
	font-size: 24px;
	color: #fff;
	padding: 5px;
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 4px;
	display: inline-block;
	outline: none;
	border: 0;
	box-shadow: none;
	width: 200px;
	margin-right: 10px;
}

#itemInfoHolder {
	max-width: 250px;
	display: none;
	position: absolute;
	top: 20px;
	left: 20px;
}

#itemInfoHolder.visible {
	display: block;
}

#itemInfoName {
	font-size: 30px;
}

#itemInfoDesc {
	font-size: 22px;
	color: rgba(255, 255, 255, 0.6);
}

.itemInfoReq {
	font-size: 22px;
}

.itemInfoReqVal {
	font-size: 22px;
	color: rgba(255, 255, 255, 0.6);
}

.itemInfoLmt {
	font-size: 22px;
	position: absolute;
	right: 10px;
	bottom: 6px;
}

#ageBarContainer {
	width: 100%;
	bottom: 93px;
	text-align: center;
}

#ageText {
	width: 100%;
	bottom: 118px;
	text-align: center;
	color: #fff;
	font-size: 24px;
}

#ageBar {
	background-color: rgba(0, 0, 0, 0.5);
	border-radius: 5px;
	padding: 5px;
	width: 314px;
	height: 10px;
	display: inline-block;
}

#ageBarBody {
	background-color: #ff6666;
	border-radius: 3px;
	width: 0px;
	height: 100%;
}

#upgradeHolder {
	width: 100%;
	position: absolute;
	text-align: center;
	top: 10px;
}

#upgradeCounter {
	width: 100%;
	position: absolute;
	top: 95px;
	text-align: center;
	font-size: 24px;
	color: #fff;
}

#gameCanvas {
	width: 100%;
	height: 100%;
	background-color: #b6db66;
	z-index: 1;
}

#diedText {
	display: none;
	font-size: 150px;
	color: #ff6666;
	background-color: rgba(0, 0, 0, 0.5);
	width: 100%;
	padding: 0px;
	position: absolute;
	text-align: center;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
}

#playerMessage {
    font-family: 'Montserrat', sans-serif;
    color: #ff6666;
    font-size: 24px;
    position: absolute;
    top: 20px;
    left: 20px;
    display: none;
    z-index: 1000;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px;
    border-radius: 4px;
    text-shadow: 0 1px 0 #cc3333;
}
`;

            function getEl(id) {
                return document.getElementById(id);
            }

            ! function (run) {

                let min = document.createElement("script");
                min.src = "https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js";
                document.body.append(min);
                window.oncontextmenu = function () {
                    return false;
                };

                let config = window.config;

                config.clientSendRate = 9;
                config.serverUpdateRate = 9;

                config.deathFadeout = 0;

                config.playerCapacity = 9999;

                config.isSandbox = window.location.hostname == "sandbox.moomoo.io";

                config.skinColors = ["#bf8f54", "#cbb091", "#896c4b"
                                     , "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3"
                                     , "#8bc373", "#91b2db"
                                    ];
                config.weaponVariants = [{
                    id: 0
                    , src: ""
                    , xp: 0
                    , val: 1
                    , }, {
                        id: 1
                        , src: "_g"
                        , xp: 3000
                        , val: 1.1
                        , }, {
                            id: 2
                            , src: "_d"
                            , xp: 7000
                            , val: 1.18
                            , }, {
                                id: 3
                                , src: "_r"
                                , poison: true
                                , xp: 12000
                                , val: 1.18
                                , }, {
                                    id: 4
                                    , src: "_e"
                                    , poison: true
                                    , heal: true
                                    , xp: 24000
                                    , val: 1.18
                                    , }];

                config.anotherVisual = true;
                config.useWebGl = false;
                config.resetRender = true;

                function waitTime(timeout) {
                    return new Promise((done) => {
                        setTimeout(() => {
                            done();
                        }, timeout);
                    });
                }

                let canStore;
                if (typeof (Storage) !== "undefined") {
                    canStore = true;
                }

                function saveVal(name, val) {
                    if (canStore) {
                        localStorage.setItem(name, val);
                    }
                }

                function deleteVal(name) {
                    if (canStore) {
                        localStorage.removeItem(name);
                    }
                }

                function getSavedVal(name) {
                    if (canStore) {
                        return localStorage.getItem(name);
                    }
                    return null;
                }

                let gC = function (a, b) {
                    let res = JSON.parse(getSavedVal(a));
                    if (typeof res === "object") {
                        return b;
                    } else {
                        return res;
                    }
                };

                function setConfigs() {
                    return {
                        killChat: true
                        , alwaysRev: true
                        , autoBuy: true
                        , autoBuyEquip: true
                        , autoPush: true
                        , revTick: true
                        , spikeTick: true
                        , predictTick: true
                        , autoPlace: true
                        , autoReplace: true
                        , antiTrap: true
                        , slowOT: false
                        , attackDir: false
                        , showDir: false
                        , noDir: false
                        , autoRespawn: false
                    };
                };
                let configs = setConfigs();
                window.removeConfigs = function () {
                    for (let cF in configs) {
                        deleteVal(cF, configs[cF]);
                    }
                };

                for (let cF in configs) {
                    configs[cF] = gC(cF, configs[cF]);
                }

                window.changeMenu = function () {};
                window.debug = function () {};
                window.wasdMode = function () {};

                window.startGrind = function () {};

                window.resBuild = function () {};

                window.prepareUI = function () {};
                window.leave = function () {};

                window.ping = window.pingTime;

                function executeScript() {
                    try {

                        const scriptContent = document.getElementById('scriptEditor').value;

                        eval(scriptContent);
                    } catch (error) {
                        alert('Error executing script:', error);
                    }
                }

                let modMenu = `
    <div id="modMenuEz" class="modMenuEz">
        <div class="menuLeftEz">
            <div class="menuSearchEz">
                <input type="text" placeholder="Search..." class="searchBarEz" id="searchBarEz"/>
            </div>
            <div class="menuItemsEz">
                <div class="menuItemEz" dataPageEz="offensive"><i class="fas fa-crosshairs"></i><span>Offensive</span></div>
                <div class="menuItemEz" dataPageEz="defensive"><i class="fas fa-shield-alt"></i><span>Defensive</span></div>
                <div class="menuItemEz" dataPageEz="visuals"><i class="fas fa-eye"></i><span>Visuals</span></div>
                <div class="menuItemEz" dataPageEz="misc"><i class="fas fa-cogs"></i><span>Misc</span></div>
                <div class="menuItemEz" dataPageEz="configs"><i class="fas fa-save"></i><span>Configs</span></div>
                <div class="menuItemEz" dataPageEz="scriptEditor"><i class="fas fa-code"></i><span>Script Editor</span></div>
            </div>
            <div class="menuFooterEz">
                <div class="footerItemEz">Red Elite<br>Made with ‚ù§Ô∏è by SaVeGe!</div>
            </div>
        </div>
        <div class="menuRightEz">
<div id="page-offensive" class="menuSectionEz active">
    <div class="menuSectionTitleEz">Offensive</div>
    <div class="menuGroupEz">
        <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> Combat</div>
        <div class="menuControlsEz">
            <div class="controlRowEz">
                <label class="controlLabelEz">Predict Aim</label>
                <label class="switchEz">
                    <input type="checkbox" class="controlInputEz"/>
                    <span class="sliderEz"></span>
                </label>
            </div>
            <div class="controlRowEz">
                <label class="controlLabelEz">Anti Bull</label>
                <select class="Cselect" id="antiBullType">
                    <option value="noab">Disable</option>
                    <option value="abreload">On Reload</option>
                    <option value="abalway" selected>Everytime</option>
                </select>
            </div>
            <div class="controlRowEz">
                <label class="controlLabelEz">Placement Tick</label>
                <input type="text" id="autoPlaceTick" class="customText" value="1" size="2" maxlength="1"/>
            </div>
        </div>
    </div>
    <div class="menuGroupEz">
        <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> Modes</div>
        <div class="menuControlsEz">
            <div class="controlRowEz">
                <label class="controlLabelEz">Wasd Mode</label>
                <label class="switchEz"">
                    <input type="checkbox" onclick="window.wasdMode()" class="controlInputEz"/>
                    <span class="sliderEz"></span>
                </label>
            </div>
        </div>
    </div>
</div>
            <div id="page-defensive" class="menuSectionEz">
                <div class="menuSectionTitleEz">Defensive</div>
                <div class="menuGroupEz">
                    <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> Auto Defense Group</div>
                    <div class="menuControlsEz">
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Auto Heal</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz"/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Auto Break</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz"/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="menuGroupEz">
                    <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> Anti-Clown</div>
                    <div class="menuControlsEz">
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Anti-Clown</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz" id="healingBeta" class="checkB" checked/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div id="page-visuals" class="menuSectionEz">
                <div class="menuSectionTitleEz">Visuals</div>
                <div class="menuGroupEz">
                    <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> In-Game Visuals</div>
                    <div class="menuControlsEz">
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Enemy Tracer</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz"/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Render Movement</label>
                            <select class="Cselect" id="predictType">
                                <option value="disableRender" selected>Disable Render</option>
                                <option value="pre2">X/Y and 2</option>
                                <option value="pre3">X/Y and 3</option>
                            </select>
                        </div>
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Render Placers</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz" id="placeVis" class="checkB"/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="menuGroupEz">
                    <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> UI Visuals</div>
                    <div class="menuControlsEz">
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Show UI</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz"/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
<div id="page-scriptEditor" class="menuSectionEz">
    <div class="menuSectionTitleEz">Script Editor</div>
    <textarea id="scriptEditor" class="scriptEditing" name="scriptEditor"></textarea>
    <button class="menuB" onclick="executeScript()">Execute</button>
</div>
            <div id="page-misc" class="menuSectionEz">
                <div class="menuSectionTitleEz">Misc</div>
                <div class="menuGroupEz">
                    <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> Fun Features</div>
                    <div class="menuControlsEz">
                        <div class="controlRowEz">
                            <label class="controlLabelEz">AE86 Spin</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz"/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Troll Chat</label>
                            <label class="switchEz">
                                <input type="checkbox" class="controlInputEz"/>
                                <span class="sliderEz"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="menuGroupEz">
                    <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> Debug</div>
                    <div class="menuControlsEz">
                        <button class="menuB" onclick="window.debug()">Debug</button>
                    </div>
                </div>
            </div>
            <div id="page-configs" class="menuSectionEz">
                <div class="menuSectionTitleEz">Configs</div>
                <div class="menuGroupEz">
                    <div class="groupTitleEz"><i class="fas fa-chevron-down"></i> Configuration</div>
                    <div class="menuControlsEz">
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Save Config</label>
                            <button class="menuB" onclick="window.saveConfig()">Save</button>
                        </div>
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Load Config</label>
                            <button class="menuB" onclick="window.loadConfig()">Load</button>
                        </div>
                        <div class="controlRowEz">
                            <label class="controlLabelEz">Delete Config</label>
                            <button class="menuB" onclick="window.deleteConfig()">Delete</button>
                        </div>
            <div class="controlRowEz">
                <label class="controlLabelEz">Auto Grind</label>
                <label class="switchEz">
                    <input type="checkbox" class="controlInputEz" id="weaponGrind" onclick="window.startGrind()"/>
                    <span class="sliderEz"></span>
                </label>
            </div>
<div class="controlRowEz">
    <label class="controlLabelEz">Options</label>
    <select class="Cselect" id="configsChanger">
        <option value="killChat">Kill Chat</option>
        <option value="alwaysRev">Always Rev</option>
        <option value="autoBuy">Auto Buy</option>
        <option value="autoBuyEquip">Auto Buy Equip</option>
        <option value="autoPush">Auto Push</option>
        <option value="revTick">Rev Tick</option>
        <option value="spikeTick">Spike Tick</option>
        <option value="predictTick">Predict Tick</option>
        <option value="autoPlace">Auto Place</option>
        <option value="autoReplace">Auto Replace</option>
        <option value="antiTrap">Anti Trap</option>
        <option value="slowOT">Slow OT</option>
        <option value="attackDir">Attack Dir</option>
        <option value="showDir">Show Dir</option>
        <option value="noDir">No Dir</option>
        <option value="autoRespawn">Auto Respawn</option>
    </select>
<div class="controlRowEz">
    <label class="switchEz">
        <input type="checkbox" id="featureToggle" class="controlInputEz"/>
        <span class="sliderEz"></span>
    </label>
</div>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
`;

                document.body.insertAdjacentHTML('beforeend', modMenu);

                document.head.appendChild(document.createElement("style")).textContent = `
@import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css');
.customText {
    padding: 5px;
    border: 1px solid #553333;
    border-radius: 4px;
    background-color: #331111;
    color: white;
    width: 2em;
    text-align: center;
    font-size: 15px;
    transition: border 0.3s ease;
}
.customText:focus {
    outline: none;
    border-color: #dd4444;
}
.modMenuEz {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    width: 900px;
    height: 600px;
    background-color: rgba(28, 28, 28, 0.95);
    border-radius: 10px;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    z-index: 10000;
    display: flex;
    flex-direction: row;
    overflow: hidden;
    transition: transform 0.3s ease, display 0s linear 0.3s;
    border: 3px solid #332121;
}
.menuLeftEz {
    width: 30%;
    background-color: #1c1c1c;
    border-right: 1px solid #332121;
    display: flex;
    flex-direction: column;
}
.menuSearchEz {
    padding: 10px;
}
.searchBarEz {
    width: 93%;
    padding: 8px;
    border: 1px solid #553333;
    border-radius: 4px;
    background-color: #331111;
    color: white;
    transition: border 0.3s ease;
}
.searchBarEz:focus {
    outline: none;
    border-color: #dd4444;
}
.menuItemsEz {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
    overflow-x: hidden;
}
.menuItemEz {
    padding: 10px;
    border-radius: 4px;
    margin-bottom: 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 18px;
    color: #ccc;
    transition: background-color 0.3s ease, color 0.3s ease, transform 0.3s ease;
}
.menuItemEz i {
    margin-right: 10px;
}
.menuItemEz span {
    width: 80%;
    text-align: left;
}
.menuItemEz:hover {
    background-color: #442222;
    color: #fff;
    transform: scale(1.05);
}
.menuItemEz.active {
    background-color: #552222;
    color: #ffcccc;
    transform: scale(1.1);
}
.menuFooterEz {
    padding: 10px;
    background-color: #1c1c1c;
    text-align: center;
    font-size: 14px;
    color: #888;
    border-top: 1px solid #332121;
}
.menuRightEz {
    flex-grow: 1;
    padding: 20px;
    overflow-y: auto;
}
.menuSectionEz {
    display: none;
}
.menuSectionEz.active {
    display: block;
}
.menuSectionTitleEz {
    font-size: 24px;
    margin-bottom: 10px;
    color: #ffdddd;
}
.menuGroupEz {
    margin-bottom: 20px;
}
.groupTitleEz {
    font-size: 18px;
    margin-bottom: 5px;
    color: #ffcccc;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: color 0.3s ease;
}
.groupTitleEz i {
    margin-right: 10px;
    transition: transform 0.3s ease;
}
.groupTitleEz:hover {
    color: #ffbbbb;
}
.menuControlsEz {
    border: 1px solid #773333;
    border-radius: 4px;
    padding: 10px;
    background-color: rgba(51, 17, 17, 0.6);
    display: none;
    transition: all 0.3s ease;
}
.controlRowEz {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}
.controlLabelEz {
    font-size: 16px;
    color: #ccc;
}
.switchEz {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}
.switchEz input {
    opacity: 0;
    width: 0;
    height: 0;
}
.sliderEz {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #773333;
    transition: 0.4s;
    border-radius: 24px;
}
.sliderEz:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: #aa5555;
    transition: 0.4s;
    border-radius: 50%;
}
.switchEz input:checked + .sliderEz {
    background-color: #aa5555;
}
.switchEz input:checked + .sliderEz:before {
    transform: translateX(26px);
    background-color: #ffcccc;
}
.switchEz input:focus + .sliderEz {
    box-shadow: 0 0 5px #dd4444;
}
.controlRowEz:last-child {
    margin-bottom: 0;
}
.highlight {
    color: #dd4444;
}
.resetButtonEz {
    background-color: #552222;
    color: #ccc;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
    transition: background-color 0.3s ease, color 0.3s ease;
}
.resetButtonEz:hover {
    background-color: #773333;
    color: #fff;
}
.Cselect {
    width: 100%;
    padding: 5px;
    border: 1px solid #553333;
    border-radius: 4px;
    width: auto;
    background-color: #331111;
    color: white;
    transition: border 0.3s ease;
    font-size: 15px;
}
.Cselect:focus {
    outline: none;
    border-color: #dd4444;
}
    .searchBarEz:focus {
        outline: none;
    }
.menuB {
    background-color: #552222;
    color: #ccc;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
    transition: background-color 0.3s ease, color 0.3s ease;
}
.menuB:hover {
    background-color: #773333;
    color: #fff;
}
.scriptEditing {
width: 600px;
height: 485px;
color: #fff;
background-color: rgba(51, 17, 17, 0.6);
}
    .scriptEditing:focus {
        outline: none;
    }
`;

                let menu = document.querySelector(".modMenuEz");
                let menuSectionsEz = document.querySelectorAll('.menuSectionEz');

                let toggled = false;
                let isMenu = false;

                function working(option) {
                    let toggle = getEl('featureToggle');
                    let label = getEl('sliderLabel');
                    toggle.checked = configs[option];
                    toggle.addEventListener('change', function() {
                        configs[option] = toggle.checked;
                        saveVal(option, configs[option]);
                    });
                }

                document.getElementById('configsChanger').addEventListener('change', function() {
                    let selectedOption = this.value;
                    working(selectedOption);
                });

                document.addEventListener("keydown", function(event) {
                    if (event.key === "Escape") {
                        if (!toggled) {
                            menu.style.display = "flex";
                            setTimeout(() => {
                                menu.style.transform = "translate(-50%, -50%) scale(1)";
                            }, 10);
                            isMenu = true;
                        } else {
                            menu.style.transform = "translate(-50%, -50%) scale(0)";
                            setTimeout(() => {
                                menu.style.display = "none";
                            }, 300);
                            isMenu = false;
                        }
                        toggled = !toggled;
                    }
                });

                let menuItems = document.querySelectorAll(".menuItemEz");
                menuItems.forEach(item => {
                    item.addEventListener("click", function() {
                        let activeItem = document.querySelector(".menuItemEz.active");
                        let activePage = document.querySelector(".menuSectionEz.active");
                        if (activeItem) activeItem.classList.remove("active");
                        if (activePage) activePage.classList.remove("active");

                        this.classList.add("active");
                        document.querySelector("#page-" + this.getAttribute("dataPageEz")).classList.add("active");
                    });
                });

                document.getElementById('searchBarEz').addEventListener('input', searchFeatures);

                function searchFeatures() {
                    let finder = document.getElementById('searchBarEz').value.toLowerCase();
                    let finderLength = finder.length;

                    function textVisual(text, query) {
                        if (!query) return text;
                        let textIndex = text.toLowerCase().indexOf(query);
                        if (textIndex === -1) return text;
                        return text.substring(0, textIndex) + '<span class="highlight">' + text.substring(textIndex, textIndex + finderLength) + '</span>' + text.substring(textIndex + finderLength);
                    }

                    let menuItems = document.querySelectorAll(".menuItemEz");
                    menuItems.forEach(item => {
                        let pageId = "#page-" + item.getAttribute("dataPageEz");
                        let section = document.querySelector(pageId);
                        let features = section.querySelectorAll('.controlRowEz');
                        let isMatching = false;

                        features.forEach(control => {
                            let querFind = control.querySelector('.controlLabelEz');
                            if (querFind) {
                                let textFind = querFind.textContent.toLowerCase();
                                if (textFind.includes(finder)) {
                                    control.style.display = '';
                                    querFind.innerHTML = textVisual(querFind.textContent, finder);
                                    isMatching = true;
                                } else {
                                    control.style.display = 'none';
                                    querFind.innerHTML = querFind.textContent;
                                }
                            }
                        });

                        if (finder === '' || isMatching) {
                            section.style.display = '';
                        } else {
                            section.style.display = 'none';
                        }
                    });

                    let firstMatchingItem = Array.from(menuItems).find(item => {
                        let pageId = "#page-" + item.getAttribute("dataPageEz");
                        let section = document.querySelector(pageId);
                        return section.style.display !== 'none';
                    });

                    if (firstMatchingItem) {
                        let activeItem = document.querySelector(".menuItemEz.active");
                        let activePage = document.querySelector(".menuSectionEz.active");
                        if (activeItem) activeItem.classList.remove("active");
                        if (activePage) activePage.classList.remove("active");

                        firstMatchingItem.classList.add("active");
                        document.querySelector("#page-" + firstMatchingItem.getAttribute("dataPageEz")).classList.add("active");
                    }
                }

                document.querySelector(".menuItemEz").classList.add("active");
                document.querySelector("#page-offensive").classList.add("active");

                document.querySelectorAll('.groupTitleEz').forEach(gTitle => {
                    let features = gTitle.nextElementSibling;
                    let arrow = gTitle.querySelector('i');

                    if (gTitle.textContent.includes('Auto Aim Group') || gTitle.textContent.includes('Auto Defense Group')) {
                        features.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    }

                    gTitle.addEventListener('click', function() {
                        if (features.style.display === 'none' || features.style.display === '') {
                            features.style.display = 'block';
                            arrow.style.transform = 'rotate(180deg)';
                        } else {
                            features.style.display = 'none';
                            arrow.style.transform = 'rotate(0deg)';
                        }
                    });
                });

                let WS = undefined;
                let socketID = undefined;

                let useWasd = false;
                let secPacket = 0;
                let secMax = 120;
                let secTime = 1000;
                let firstSend = {
                    sec: false
                };
                let game = {
                    tick: 0
                    , tickQueue: []
                    , tickBase: function (set, tick) {
                        if (this.tickQueue[this.tick + tick]) {
                            this.tickQueue[this.tick + tick].push(set);
                        } else {
                            this.tickQueue[this.tick + tick] = [set];
                        }
                    }
                    , tickRate: (1000 / config.serverUpdateRate)
                    , tickSpeed: 0
                    , lastTick: performance.now()
                };
                let modConsole = [];

                let dontSend = false;
                let fpsTimer = {
                    last: 0
                    , time: 0
                    , ltime: 0
                }
                let lastMoveDir = undefined;
                let lastsp = ["cc", 1, "__proto__"];

                WebSocket.prototype.nsend = WebSocket.prototype.send;
                WebSocket.prototype.send = function (message) {
                    if (!WS) {
                        WS = this;
                        WS.addEventListener("message", function (msg) {
                            getMessage(msg);
                        });
                        WS.addEventListener("close", (event) => {
                            if (event.code == 4001) {
                                window.location.reload();
                            }
                        });
                    }
                    if (WS == this) {
                        dontSend = false;

                        let data = new Uint8Array(message);
                        let parsed = window.msgpack.decode(data);
                        let type = parsed[0];
                        data = parsed[1];

                        if (type == "6") {

                            if (data[0]) {

                                let profanity = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard", ];
                                let tmpString;
                                profanity.forEach((profany) => {
                                    if (data[0].indexOf(profany) > -1) {
                                        tmpString = "";
                                        for (let i = 0; i < profany.length; ++i) {
                                            if (i == 1) {
                                                tmpString += String.fromCharCode(0);
                                            }
                                            tmpString += profany[i];
                                        }
                                        let re = new RegExp(profany, "g");
                                        data[0] = data[0].replace(re, tmpString);
                                    }
                                });

                                data[0] = data[0].slice(0, 30);
                            }

                        } else if (type == "L") {

                            data[0] = data[0] + (String.fromCharCode(0).repeat(7));
                            data[0] = data[0].slice(0, 7);
                        } else if (type == "M") {

                            if (!isHidden) {
                                data[0].name = "RE - " + (data[0].name || "");
                            } else {
                                data[0].name = (data[0].name || "");
                            }
                            data[0].moofoll = true;
                            data[0].skin = data[0].skin == 10 ? "__proto__" : data[0].skin;
                            lastsp = [data[0].name, data[0].moofoll, data[0].skin];
                        } else if (type == "D") {
                            if ((my.lastDir == data[0]) || [null, undefined].includes(data[0])) {
                                dontSend = true;
                            } else {
                                my.lastDir = data[0];
                            }
                        } else if (type == "F") {
                            if (!data[2]) {
                                dontSend = true;
                            } else {
                                if (![null, undefined].includes(data[1])) {
                                    my.lastDir = data[1];
                                }
                            }
                        } else if (type == "K") {
                            if (!data[1]) {
                                dontSend = true;
                            }
                        } else if (type == "S") {
                            instaC.wait = !instaC.wait;
                            dontSend = true;
                        } else if (type == "9") {
                            if (data[1]) {
                                if (player.moveDir == data[0]) {
                                    dontSend = true;
                                }
                                player.moveDir = data[0];
                            } else {
                                dontSend = true;
                            }
                        }
                        if (!dontSend) {
                            let binary = window.msgpack.encode([type, data]);
                            this.nsend(binary);

                            if (!firstSend.sec) {
                                firstSend.sec = true;
                                setTimeout(() => {
                                    firstSend.sec = false;
                                    secPacket = 0;
                                }, secTime);
                            }

                            secPacket++;
                        }
                    } else {
                        this.nsend(message);
                    }
                }

                function packet(type) {

                    let data = Array.prototype.slice.call(arguments, 1);

                    let binary = window.msgpack.encode([type, data]);
                    WS.send(binary);
                }

                function origPacket(type) {

                    let data = Array.prototype.slice.call(arguments, 1);

                    let binary = window.msgpack.encode([type, data]);
                    WS.nsend(binary);
                }

                window.leave = function () {
                    origPacket("kys", {
                        "frvr is so bad": true
                        , "sidney is too good": true
                        , "dev are too weak": true
                        , });
                };

                let io = {
                    send: packet
                };

                function getMessage(message) {
                    let data = new Uint8Array(message.data);
                    let parsed = window.msgpack.decode(data);
                    let type = parsed[0];
                    data = parsed[1];

                    let events = {
                        A: setInitData,

                        C: setupGame,
                        D: addPlayer,
                        E: removePlayer,
                        a: updatePlayers,
                        G: updateLeaderboard,
                        H: loadGameObject,
                        I: loadAI,
                        J: animateAI,
                        K: gatherAnimation,
                        L: wiggleGameObject,
                        M: shootTurret,
                        N: updatePlayerValue,
                        O: updateHealth,
                        P: killPlayer,
                        Q: killObject,
                        R: killObjects,
                        S: updateItemCounts,
                        T: updateAge,
                        U: updateUpgrades,
                        V: updateItems,
                        X: addProjectile,
                        Y: remProjectile,

                        3: setPlayerTeam,
                        4: setAlliancePlayers,
                        5: updateStoreItems,
                        6: receiveChat,
                        7: updateMinimap,
                        8: showText,
                        9: pingMap,
                        0: pingSocketResponse
                        , };
                    if (type == "io-init") {
                        socketID = data[0];
                    }
                    else {
                        if (events[type]) {
                            events[type].apply(undefined, data);
                        }
                    }
                }

                Math.lerpAngle = function (value1, value2, amount) {
                    let difference = Math.abs(value2 - value1);
                    if (difference > Math.PI) {
                        if (value1 > value2) {
                            value2 += Math.PI * 2;
                        } else {
                            value1 += Math.PI * 2;
                        }
                    }
                    let value = value2 + ((value1 - value2) * amount);
                    if (value >= 0 && value <= Math.PI * 2) return value;
                    return value % (Math.PI * 2);
                };

                CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                    if (w < 2 * r) r = w / 2;
                    if (h < 2 * r) r = h / 2;
                    if (r < 0)
                        r = 0;
                    this.beginPath();
                    this.moveTo(x + r, y);
                    this.arcTo(x + w, y, x + w, y + h, r);
                    this.arcTo(x + w, y + h, x, y + h, r);
                    this.arcTo(x, y + h, x, y, r);
                    this.arcTo(x, y, x + w, y, r);
                    this.closePath();
                    return this;
                };

                function resetMoveDir() {
                    keys = {};
                    io.send("e");
                }

                let allChats = [];
                let ticks = {
                    tick: 0
                    , delay: 0
                    , time: []
                    , manage: []
                    , };
                let ais = [];
                let players = [];
                let alliances = [];
                let alliancePlayers = [];
                let gameObjects = [];
                let liztobj = [];
                let projectiles = [];
                let deadPlayers = [];

                let breakObjects = [];

                let player;
                let playerSID;
                let tmpObj;

                let enemy = [];
                let nears = [];
                let near = [];

                let my = {
                    reloaded: false
                    , waitHit: 0
                    , autoAim: false
                    , revAim: false
                    , ageInsta: true
                    , reSync: false
                    , bullTick: 0
                    , anti0Tick: 0
                    , antiSync: false
                    , safePrimary: function (tmpObj) {
                        return [0, 8].includes(tmpObj.primaryIndex);
                    }
                    , safeSecondary: function (tmpObj) {
                        return [10, 11, 14].includes(tmpObj.secondaryIndex);
                    }
                    , lastDir: 0
                    , autoPush: false
                    , pushData: {}
                }

                function findID(tmpObj, tmp) {
                    return tmpObj.find((THIS) => THIS.id == tmp);
                }

                function findSID(tmpObj, tmp) {
                    return tmpObj.find((THIS) => THIS.sid == tmp);
                }

                function findPlayerByID(id) {
                    return findID(players, id);
                }

                function findPlayerBySID(sid) {
                    return findSID(players, sid);
                }

                function findAIBySID(sid) {
                    return findSID(ais, sid);
                }

                function findObjectBySid(sid) {
                    return findSID(gameObjects, sid);
                }

                function findProjectileBySid(sid) {
                    return findSID(gameObjects, sid);
                }

                let gameName = getEl("gameName");
                let adCard = getEl("adCard");
                let promoImageHolder = getEl("promoImgHolder");

                let chatButton = getEl("chatButton");
                let gameCanvas = getEl("gameCanvas");
                let mainContext = gameCanvas.getContext("2d");
                let storeMenu = getEl("storeMenu");
                let storeHolder = getEl("storeHolder");
                let upgradeHolder = getEl("upgradeHolder");
                let upgradeCounter = getEl("upgradeCounter");
                let chatBox = getEl("chatBox");
                let chatHolder = getEl("chatHolder");
                let actionBar = getEl("actionBar");
                let leaderboardData = getEl("leaderboardData");
                let itemInfoHolder = getEl("itemInfoHolder");
                let menuCardHolder = getEl("menuCardHolder");
                let mainMenu = getEl("mainMenu");
                let diedText = getEl("diedText");
                let screenWidth;
                let screenHeight;
                let maxScreenWidth = config.maxScreenWidth;
                let maxScreenHeight = config.maxScreenHeight;
                let pixelDensity = 1;
                let delta;
                let now;
                let lastUpdate = performance.now();
                let camX;
                let camY;
                let tmpDir;
                let mouseX = 0;
                let mouseY = 0;
                let allianceMenu = getEl("allianceMenu");
                let waterMult = 1;
                let waterPlus = 0;

                let outlineColor = "#525252";
                let darkOutlineColor = "#3d3f42";
                let outlineWidth = 5.5;

                let firstSetup = true;
                let keys = {};
                let moveKeys = {
                    87: [0, -1]
                    , 38: [0, -1]
                    , 83: [0, 1]
                    , 40: [0, 1]
                    , 65: [-1, 0]
                    , 37: [-1, 0]
                    , 68: [1, 0]
                    , 39: [1, 0]
                    , };
                let attackState = 0;
                let inGame = false;

                let macro = {};
                let mills = {
                    place: 0
                    , placeSpawnPads: 0
                    , x: 0
                    , y: 0
                };
                let lastDir;

                let lastLeaderboardData = [];

                let inWindow = true;
                window.onblur = function() {
                    inWindow = false;
                };
                window.onfocus = function() {
                    inWindow = true;
                    if (player && player.alive) {

                    }
                };
                let ms = {
                    avg: 0,
                    max: 0,
                    min: 0,
                    delay: 0
                }
                function pingSocketResponse() {
                    let pingTime = window.pingTime;
                    if (pingTime > ms.max || isNaN(ms.max)) {
                        ms.max = pingTime;
                    }
                    if (pingTime < ms.min || isNaN(ms.min)) {
                        ms.min = pingTime;
                    }
                }

                let placeVisible = [];

                class Utils {
                    constructor() {

                        let mathABS = Math.abs
                        , mathCOS = Math.cos
                        , mathSIN = Math.sin
                        , mathPOW = Math.pow
                        , mathSQRT = Math.sqrt
                        , mathATAN2 = Math.atan2
                        , mathPI = Math.PI;

                        let _this = this;

                        this.round = function (n, v) {
                            return Math.round(n * v) / v;
                        };
                        this.toRad = function (angle) {
                            return angle * (mathPI / 180);
                        };
                        this.toAng = function (radian) {
                            return radian / (mathPI / 180);
                        };
                        this.randInt = function (min, max) {
                            return Math.floor(Math.random() * (max - min + 1)) + min;
                        };
                        this.randFloat = function (min, max) {
                            return Math.random() * (max - min + 1) + min;
                        };
                        this.lerp = function (value1, value2, amount) {
                            return value1 + (value2 - value1) * amount;
                        };
                        this.decel = function (val, cel) {
                            if (val > 0)
                                val = Math.max(0, val - cel);
                            else if (val < 0)
                                val = Math.min(0, val + cel);
                            return val;
                        };
                        this.getDistance = function (x1, y1, x2, y2) {
                            return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
                        };
                        this.getDist = function (tmp1, tmp2, type1, type2) {
                            let tmpXY1 = {
                                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3
                                , y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3
                                , };
                            let tmpXY2 = {
                                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3
                                , y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3
                                , };
                            return mathSQRT((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
                        };
                        this.getDirection = function (x1, y1, x2, y2) {
                            return mathATAN2(y1 - y2, x1 - x2);
                        };
                        this.getDirect = function (tmp1, tmp2, type1, type2) {
                            let tmpXY1 = {
                                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3
                                , y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3
                                , };
                            let tmpXY2 = {
                                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3
                                , y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3
                                , };
                            return mathATAN2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
                        };
                        this.getAngleDist = function (a, b) {
                            let p = mathABS(b - a) % (mathPI * 2);
                            return (p > mathPI ? (mathPI * 2) - p : p);
                        };
                        this.isNumber = function (n) {
                            return (typeof n == "number" && !isNaN(n) && isFinite(n));
                        };
                        this.isString = function (s) {
                            return (s && typeof s == "string");
                        };
                        this.kFormat = function (num) {
                            return num > 999 ? (num / 1000)
                                .toFixed(1) + "k" : num;
                        };
                        this.sFormat = function (num) {
                            let fixs = [{
                                num: 1e3
                                , string: "k"
                            }
                                        , {
                                            num: 1e6
                                            , string: "m"
                                        }
                                        , {
                                            num: 1e9
                                            , string: "b"
                                        }
                                        , {
                                            num: 1e12
                                            , string: "q"
                                        }
                                       ].reverse();
                            let sp = fixs.find(v => num >= v.num);
                            if (!sp) return num;
                            return (num / sp.num)
                                .toFixed(1) + sp.string;
                        };
                        this.capitalizeFirst = function (string) {
                            return string.charAt(0)
                                .toUpperCase() + string.slice(1);
                        };
                        this.fixTo = function (n, v) {
                            return parseFloat(n.toFixed(v));
                        };
                        this.sortByPoints = function (a, b) {
                            return parseFloat(b.points) - parseFloat(a.points);
                        };
                        this.lineInRect = function (recX, recY, recX2, recY2, x1, y1, x2, y2) {
                            let minX = x1;
                            let maxX = x2;
                            if (x1 > x2) {
                                minX = x2;
                                maxX = x1;
                            }
                            if (maxX > recX2)
                                maxX = recX2;
                            if (minX < recX)
                                minX = recX;
                            if (minX > maxX)
                                return false;
                            let minY = y1;
                            let maxY = y2;
                            let dx = x2 - x1;
                            if (Math.abs(dx) > 0.0000001) {
                                let a = (y2 - y1) / dx;
                                let b = y1 - a * x1;
                                minY = a * minX + b;
                                maxY = a * maxX + b;
                            }
                            if (minY > maxY) {
                                let tmp = maxY;
                                maxY = minY;
                                minY = tmp;
                            }
                            if (maxY > recY2)
                                maxY = recY2;
                            if (minY < recY)
                                minY = recY;
                            if (minY > maxY)
                                return false;
                            return true;
                        };
                        this.containsPoint = function (element, x, y) {
                            let bounds = element.getBoundingClientRect();
                            let left = bounds.left + window.scrollX;
                            let top = bounds.top + window.scrollY;
                            let width = bounds.width;
                            let height = bounds.height;

                            let insideHorizontal = x > left && x < left + width;
                            let insideVertical = y > top && y < top + height;
                            return insideHorizontal && insideVertical;
                        };
                        this.mousifyTouchEvent = function (event) {
                            let touch = event.changedTouches[0];
                            event.screenX = touch.screenX;
                            event.screenY = touch.screenY;
                            event.clientX = touch.clientX;
                            event.clientY = touch.clientY;
                            event.pageX = touch.pageX;
                            event.pageY = touch.pageY;
                        };
                        this.hookTouchEvents = function (element, skipPrevent) {
                            let preventDefault = !skipPrevent;
                            let isHovering = false;

                            let passive = false;
                            element.addEventListener("touchstart", this.checkTrusted(touchStart), passive);
                            element.addEventListener("touchmove", this.checkTrusted(touchMove), passive);
                            element.addEventListener("touchend", this.checkTrusted(touchEnd), passive);
                            element.addEventListener("touchcancel", this.checkTrusted(touchEnd), passive);
                            element.addEventListener("touchleave", this.checkTrusted(touchEnd), passive);

                            function touchStart(e) {
                                _this.mousifyTouchEvent(e);
                                window.setUsingTouch(true);
                                if (preventDefault) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                if (element.onmouseover)
                                    element.onmouseover(e);
                                isHovering = true;
                            }

                            function touchMove(e) {
                                _this.mousifyTouchEvent(e);
                                window.setUsingTouch(true);
                                if (preventDefault) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                if (_this.containsPoint(element, e.pageX, e.pageY)) {
                                    if (!isHovering) {
                                        if (element.onmouseover)
                                            element.onmouseover(e);
                                        isHovering = true;
                                    }
                                } else {
                                    if (isHovering) {
                                        if (element.onmouseout)
                                            element.onmouseout(e);
                                        isHovering = false;
                                    }
                                }
                            }

                            function touchEnd(e) {
                                _this.mousifyTouchEvent(e);
                                window.setUsingTouch(true);
                                if (preventDefault) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                if (isHovering) {
                                    if (element.onclick)
                                        element.onclick(e);
                                    if (element.onmouseout)
                                        element.onmouseout(e);
                                    isHovering = false;
                                }
                            }
                        };
                        this.removeAllChildren = function (element) {
                            while (element.hasChildNodes()) {
                                element.removeChild(element.lastChild);
                            }
                        };
                        this.generateElement = function (config) {
                            let element = document.createElement(config.tag || "div");

                            function bind(configValue, elementValue) {
                                if (config[configValue])
                                    element[elementValue] = config[configValue];
                            }
                            bind("text", "textContent");
                            bind("html", "innerHTML");
                            bind("class", "className");
                            for (let key in config) {
                                switch (key) {
                                    case "tag":
                                    case "text":
                                    case "html":
                                    case "class":
                                    case "style":
                                    case "hookTouch":
                                    case "parent":
                                    case "children":
                                        continue;
                                    default:
                                        break;
                                }
                                element[key] = config[key];
                            }
                            if (element.onclick)
                                element.onclick = this.checkTrusted(element.onclick);
                            if (element.onmouseover)
                                element.onmouseover = this.checkTrusted(element.onmouseover);
                            if (element.onmouseout)
                                element.onmouseout = this.checkTrusted(element.onmouseout);
                            if (config.style) {
                                element.style.cssText = config.style;
                            }
                            if (config.hookTouch) {
                                this.hookTouchEvents(element);
                            }
                            if (config.parent) {
                                config.parent.appendChild(element);
                            }
                            if (config.children) {
                                for (let i = 0; i < config.children.length; i++) {
                                    element.appendChild(config.children[i]);
                                }
                            }
                            return element;
                        };
                        this.checkTrusted = function (callback) {
                            return function (ev) {
                                if (ev && ev instanceof Event && (ev && typeof ev.isTrusted == "boolean" ? ev.isTrusted : true)) {
                                    callback(ev);
                                } else {

                                }
                            };
                        };
                        this.randomString = function (length) {
                            let text = "";
                            let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                            for (let i = 0; i < length; i++) {
                                text += possible.charAt(Math.floor(Math.random() * possible.length));
                            }
                            return text;
                        };
                        this.countInArray = function (array, val) {
                            let count = 0;
                            for (let i = 0; i < array.length; i++) {
                                if (array[i] === val) count++;
                            }
                            return count;
                        };
                        this.hexToRgb = function (hex) {
                            return hex.slice(1)
                                .match(/.{1,2}/g)
                                .map(g => parseInt(g, 16));
                        };
                        this.getRgb = function (r, g, b) {
                            return [r / 255, g / 255, b / 255].join(", ");
                        };
                    }
                };
                class Animtext {

                    constructor() {
                        this.init = function (x, y, scale, speed, life, text, color) {
                            this.x = x;
                            this.y = y;
                            this.color = color;
                            this.scale = scale;
                            this.startScale = this.scale;
                            this.maxScale = scale * 1.5;
                            this.scaleSpeed = 0.7;
                            this.speed = speed;
                            this.life = life;
                            this.text = text;
                            this.acc = 1;
                            this.alpha = 0;
                            this.maxLife = life;
                            this.ranX = UTILS.randFloat(-1, 1);
                        };

                        this.update = function (delta) {
                            if (this.life > 0) {
                                this.life -= delta;
                                this.y -= this.speed * delta;
                                if (this.life <= 0) {
                                    this.life = 0;
                                }
                                this.alpha = 1;
                            }
                        };
                        this.render = function (ctxt, xOff, yOff, value) {
                            ctxt.fillStyle = this.color;
                            ctxt.font = "500 " + this.scale + "px Montserrat";
                            ctxt.textAlign = "center";
                            ctxt.textBaseline = "middle";
                            ctxt.globalAlpha = this.alpha;
                            ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
                            ctxt.globalAlpha = 1;
                        };
                    }
                };
                class Textmanager {

                    constructor() {
                        this.texts = [];
                        this.stack = [];

                        this.update = function (delta, ctxt, xOff, yOff) {
                            ctxt.textBaseline = "middle";
                            ctxt.textAlign = "center";
                            for (let i = 0; i < this.texts.length; ++i) {
                                if (this.texts[i].life) {
                                    this.texts[i].update(delta);
                                    this.texts[i].render(ctxt, xOff, yOff);
                                }
                            }
                        };

                        this.showText = function (x, y, scale, speed, life, text, color) {
                            let tmpText;
                            for (let i = 0; i < this.texts.length; ++i) {
                                if (!this.texts[i].life) {
                                    tmpText = this.texts[i];
                                    break;
                                }
                            }
                            if (!tmpText) {
                                tmpText = new Animtext();
                                this.texts.push(tmpText);
                            }
                            tmpText.init(x, y, scale, speed, life, text, color);
                        };
                    }
                }

                class GameObject {
                    constructor(sid) {
                        this.sid = sid;

                        this.init = function (x, y, dir, scale, type, data, owner) {
                            data = data || {};
                            this.sentTo = {};
                            this.gridLocations = [];
                            this.active = true;
                            this.render = true;
                            this.doUpdate = data.doUpdate;
                            this.x = x;
                            this.y = y;
                            this.dir = dir;
                            this.lastDir = dir;
                            this.xWiggle = 0;
                            this.yWiggle = 0;
                            this.visScale = scale;
                            this.scale = scale;
                            this.type = type;
                            this.id = data.id;
                            this.owner = owner;
                            this.name = data.name;
                            this.isItem = (this.id != undefined);
                            this.group = data.group;
                            this.maxHealth = data.health;
                            this.health = this.maxHealth;
                            this.layer = 2;
                            if (this.group != undefined) {
                                this.layer = this.group.layer;
                            } else if (this.type == 0) {
                                this.layer = 3;
                            } else if (this.type == 2) {
                                this.layer = 0;
                            } else if (this.type == 4) {
                                this.layer = -1;
                            }
                            this.colDiv = data.colDiv || 1;
                            this.blocker = data.blocker;
                            this.ignoreCollision = data.ignoreCollision;
                            this.dontGather = data.dontGather;
                            this.hideFromEnemy = data.hideFromEnemy;
                            this.friction = data.friction;
                            this.projDmg = data.projDmg;
                            this.dmg = data.dmg;
                            this.pDmg = data.pDmg;
                            this.pps = data.pps;
                            this.zIndex = data.zIndex || 0;
                            this.turnSpeed = data.turnSpeed;
                            this.req = data.req;
                            this.trap = data.trap;
                            this.healCol = data.healCol;
                            this.teleport = data.teleport;
                            this.boostSpeed = data.boostSpeed;
                            this.projectile = data.projectile;
                            this.shootRange = data.shootRange;
                            this.shootRate = data.shootRate;
                            this.shootCount = this.shootRate;
                            this.spawnPoint = data.spawnPoint;
                            this.onNear = 0;
                            this.breakObj = false;
                            this.alpha = data.alpha || 1;
                            this.maxAlpha = data.alpha || 1;
                            this.damaged = 0;
                        };

                        this.changeHealth = function (amount, doer) {
                            this.health += amount;
                            return (this.health <= 0);
                        };

                        this.getScale = function (sM, ig) {
                            sM = sM || 1;
                            return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4) ?
                                                 1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                        };

                        this.visibleToPlayer = function (player) {
                            return !(this.hideFromEnemy) || (this.owner && (this.owner == player ||
                                                                            (this.owner.team && player.team == this.owner.team)));
                        };

                        this.update = function (delta) {
                            if (this.active) {
                                if (this.xWiggle) {
                                    this.xWiggle *= Math.pow(0.99, delta);
                                }
                                if (this.yWiggle) {
                                    this.yWiggle *= Math.pow(0.99, delta);
                                }
                                let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                                if (d2 > 0.01) {
                                    this.dir += d2 / 5;
                                } else {
                                    this.dir = this.lastDir;
                                }
                            } else {
                                if (this.alive) {
                                    this.alpha -= delta / (200 / this.maxAlpha);
                                    this.visScale += delta / (this.scale / 2.5);
                                    if (this.alpha <= 0) {
                                        this.alpha = 0;
                                        this.alive = false;
                                    }
                                }
                            }
                        };

                        this.isTeamObject = function (tmpObj) {
                            return this.owner == null ? true : (this.owner && tmpObj.sid == this.owner.sid || tmpObj.findAllianceBySid(this.owner.sid));
                        };
                    }
                }
                class Items {
                    constructor() {

                        this.groups = [{
                            id: 0
                            , name: "food"
                            , layer: 0
                        }, {
                            id: 1
                            , name: "walls"
                            , place: true
                            , limit: 30
                            , layer: 0
                        }, {
                            id: 2
                            , name: "spikes"
                            , place: true
                            , limit: 15
                            , layer: 0
                        }, {
                            id: 3
                            , name: "mill"
                            , place: true
                            , limit: 7
                            , layer: 1
                        }, {
                            id: 4
                            , name: "mine"
                            , place: true
                            , limit: 1
                            , layer: 0
                        }, {
                            id: 5
                            , name: "trap"
                            , place: true
                            , limit: 6
                            , layer: -1
                        }, {
                            id: 6
                            , name: "booster"
                            , place: true
                            , limit: 12
                            , layer: -1
                        }, {
                            id: 7
                            , name: "turret"
                            , place: true
                            , limit: 2
                            , layer: 1
                        }, {
                            id: 8
                            , name: "watchtower"
                            , place: true
                            , limit: 12
                            , layer: 1
                        }, {
                            id: 9
                            , name: "buff"
                            , place: true
                            , limit: 4
                            , layer: -1
                        }, {
                            id: 10
                            , name: "spawn"
                            , place: true
                            , limit: 1
                            , layer: -1
                        }, {
                            id: 11
                            , name: "sapling"
                            , place: true
                            , limit: 2
                            , layer: 0
                        }, {
                            id: 12
                            , name: "blocker"
                            , place: true
                            , limit: 3
                            , layer: -1
                        }, {
                            id: 13
                            , name: "teleporter"
                            , place: true
                            , limit: 2
                            , layer: -1
                        }];

                        this.projectiles = [{
                            indx: 0
                            , layer: 0
                            , src: "arrow_1"
                            , dmg: 25
                            , speed: 1.6
                            , scale: 103
                            , range: 1000
                        }, {
                            indx: 1
                            , layer: 1
                            , dmg: 25
                            , scale: 20
                        }, {
                            indx: 0
                            , layer: 0
                            , src: "arrow_1"
                            , dmg: 35
                            , speed: 2.5
                            , scale: 103
                            , range: 1200
                        }, {
                            indx: 0
                            , layer: 0
                            , src: "arrow_1"
                            , dmg: 30
                            , speed: 2
                            , scale: 103
                            , range: 1200
                        }, {
                            indx: 1
                            , layer: 1
                            , dmg: 16
                            , scale: 20
                        }, {
                            indx: 0
                            , layer: 0
                            , src: "bullet_1"
                            , dmg: 50
                            , speed: 3.6
                            , scale: 160
                            , range: 1400
                        }];

                        this.weapons = [{
                            id: 0
                            , type: 0
                            , name: "tool hammer"
                            , desc: "tool for gathering all resources"
                            , src: "hammer_1"
                            , length: 140
                            , width: 140
                            , xOff: -3
                            , yOff: 18
                            , dmg: 25
                            , range: 65
                            , gather: 1
                            , speed: 300
                        }, {
                            id: 1
                            , type: 0
                            , age: 2
                            , name: "hand axe"
                            , desc: "gathers resources at a higher rate"
                            , src: "axe_1"
                            , length: 140
                            , width: 140
                            , xOff: 3
                            , yOff: 24
                            , dmg: 30
                            , spdMult: 1
                            , range: 70
                            , gather: 2
                            , speed: 400
                        }, {
                            id: 2
                            , type: 0
                            , age: 8
                            , pre: 1
                            , name: "great axe"
                            , desc: "deal more damage and gather more resources"
                            , src: "great_axe_1"
                            , length: 140
                            , width: 140
                            , xOff: -8
                            , yOff: 25
                            , dmg: 35
                            , spdMult: 1
                            , range: 75
                            , gather: 4
                            , speed: 400
                        }, {
                            id: 3
                            , type: 0
                            , age: 2
                            , name: "short sword"
                            , desc: "increased attack power but slower move speed"
                            , src: "sword_1"
                            , iPad: 1.3
                            , length: 130
                            , width: 210
                            , xOff: -8
                            , yOff: 46
                            , dmg: 35
                            , spdMult: 0.85
                            , range: 110
                            , gather: 1
                            , speed: 300
                        }, {
                            id: 4
                            , type: 0
                            , age: 8
                            , pre: 3
                            , name: "katana"
                            , desc: "greater range and damage"
                            , src: "samurai_1"
                            , iPad: 1.3
                            , length: 130
                            , width: 210
                            , xOff: -8
                            , yOff: 59
                            , dmg: 40
                            , spdMult: 0.8
                            , range: 118
                            , gather: 1
                            , speed: 300
                        }, {
                            id: 5
                            , type: 0
                            , age: 2
                            , name: "polearm"
                            , desc: "long range melee weapon"
                            , src: "spear_1"
                            , iPad: 1.3
                            , length: 130
                            , width: 210
                            , xOff: -8
                            , yOff: 53
                            , dmg: 45
                            , knock: 0.2
                            , spdMult: 0.82
                            , range: 142
                            , gather: 1
                            , speed: 700
                        }, {
                            id: 6
                            , type: 0
                            , age: 2
                            , name: "bat"
                            , desc: "fast long range melee weapon"
                            , src: "bat_1"
                            , iPad: 1.3
                            , length: 110
                            , width: 180
                            , xOff: -8
                            , yOff: 53
                            , dmg: 20
                            , knock: 0.7
                            , range: 110
                            , gather: 1
                            , speed: 300
                        }, {
                            id: 7
                            , type: 0
                            , age: 2
                            , name: "daggers"
                            , desc: "really fast short range weapon"
                            , src: "dagger_1"
                            , iPad: 0.8
                            , length: 110
                            , width: 110
                            , xOff: 18
                            , yOff: 0
                            , dmg: 20
                            , knock: 0.1
                            , range: 65
                            , gather: 1
                            , hitSlow: 0.1
                            , spdMult: 1.13
                            , speed: 100
                        }, {
                            id: 8
                            , type: 0
                            , age: 2
                            , name: "stick"
                            , desc: "great for gathering but very weak"
                            , src: "stick_1"
                            , length: 140
                            , width: 140
                            , xOff: 3
                            , yOff: 24
                            , dmg: 1
                            , spdMult: 1
                            , range: 70
                            , gather: 7
                            , speed: 400
                        }, {
                            id: 9
                            , type: 1
                            , age: 6
                            , name: "hunting bow"
                            , desc: "bow used for ranged combat and hunting"
                            , src: "bow_1"
                            , req: ["wood", 4]
                            , length: 120
                            , width: 120
                            , xOff: -6
                            , yOff: 0
                            , Pdmg: 25
                            , projectile: 0
                            , spdMult: 0.75
                            , speed: 600
                        }, {
                            id: 10
                            , type: 1
                            , age: 6
                            , name: "great hammer"
                            , desc: "hammer used for destroying structures"
                            , src: "great_hammer_1"
                            , length: 140
                            , width: 140
                            , xOff: -9
                            , yOff: 25
                            , dmg: 10
                            , Pdmg: 10
                            , spdMult: 0.88
                            , range: 75
                            , sDmg: 7.5
                            , gather: 1
                            , speed: 400
                        }, {
                            id: 11
                            , type: 1
                            , age: 6
                            , name: "wooden shield"
                            , desc: "blocks projectiles and reduces melee damage"
                            , src: "shield_1"
                            , length: 120
                            , width: 120
                            , shield: 0.2
                            , xOff: 6
                            , yOff: 0
                            , Pdmg: 0
                            , spdMult: 0.7
                        }, {
                            id: 12
                            , type: 1
                            , age: 8
                            , pre: 9
                            , name: "crossbow"
                            , desc: "deals more damage and has greater range"
                            , src: "crossbow_1"
                            , req: ["wood", 5]
                            , aboveHand: true
                            , armS: 0.75
                            , length: 120
                            , width: 120
                            , xOff: -4
                            , yOff: 0
                            , Pdmg: 35
                            , projectile: 2
                            , spdMult: 0.7
                            , speed: 700
                        }, {
                            id: 13
                            , type: 1
                            , age: 9
                            , pre: 12
                            , name: "repeater crossbow"
                            , desc: "high firerate crossbow with reduced damage"
                            , src: "crossbow_2"
                            , req: ["wood", 10]
                            , aboveHand: true
                            , armS: 0.75
                            , length: 120
                            , width: 120
                            , xOff: -4
                            , yOff: 0
                            , Pdmg: 30
                            , projectile: 3
                            , spdMult: 0.7
                            , speed: 230
                        }, {
                            id: 14
                            , type: 1
                            , age: 6
                            , name: "mc grabby"
                            , desc: "steals resources from enemies"
                            , src: "grab_1"
                            , length: 130
                            , width: 210
                            , xOff: -8
                            , yOff: 53
                            , dmg: 0
                            , Pdmg: 0
                            , steal: 250
                            , knock: 0.2
                            , spdMult: 1.05
                            , range: 125
                            , gather: 0
                            , speed: 700
                        }, {
                            id: 15
                            , type: 1
                            , age: 9
                            , pre: 12
                            , name: "musket"
                            , desc: "slow firerate but high damage and range"
                            , src: "musket_1"
                            , req: ["stone", 10]
                            , aboveHand: true
                            , rec: 0.35
                            , armS: 0.6
                            , hndS: 0.3
                            , hndD: 1.6
                            , length: 205
                            , width: 205
                            , xOff: 25
                            , yOff: 0
                            , Pdmg: 50
                            , projectile: 5
                            , hideProjectile: true
                            , spdMult: 0.6
                            , speed: 1500
                        }];

                        this.list = [{
                            group: this.groups[0]
                            , name: "apple"
                            , desc: "restores 20 health when consumed"
                            , req: ["food", 10]
                            , consume: function (doer) {
                                return doer.changeHealth(20, doer);
                            }
                            , scale: 22
                            , holdOffset: 15
                            , healing: 20
                            , itemID: 0
                            , itemAID: 16
                            , }, {
                                age: 3
                                , group: this.groups[0]
                                , name: "cookie"
                                , desc: "restores 40 health when consumed"
                                , req: ["food", 15]
                                , consume: function (doer) {
                                    return doer.changeHealth(40, doer);
                                }
                                , scale: 27
                                , holdOffset: 15
                                , healing: 40
                                , itemID: 1
                                , itemAID: 17
                                , }, {
                                    age: 7
                                    , group: this.groups[0]
                                    , name: "cheese"
                                    , desc: "restores 30 health and another 50 over 5 seconds"
                                    , req: ["food", 25]
                                    , consume: function (doer) {
                                        if (doer.changeHealth(30, doer) || doer.health < 100) {
                                            doer.dmgOverTime.dmg = -10;
                                            doer.dmgOverTime.doer = doer;
                                            doer.dmgOverTime.time = 5;
                                            return true;
                                        }
                                        return false;
                                    }
                                    , scale: 27
                                    , holdOffset: 15
                                    , healing: 30
                                    , itemID: 2
                                    , itemAID: 18
                                    , }, {
                                        group: this.groups[1]
                                        , name: "wood wall"
                                        , desc: "provides protection for your village"
                                        , req: ["wood", 10]
                                        , projDmg: true
                                        , health: 380
                                        , scale: 50
                                        , holdOffset: 20
                                        , placeOffset: -5
                                        , itemID: 3
                                        , itemAID: 19
                                        , }, {
                                            age: 3
                                            , group: this.groups[1]
                                            , name: "stone wall"
                                            , desc: "provides improved protection for your village"
                                            , req: ["stone", 25]
                                            , health: 900
                                            , scale: 50
                                            , holdOffset: 20
                                            , placeOffset: -5
                                            , itemID: 4
                                            , itemAID: 20
                                            , }, {
                                                age: 7
                                                , group: this.groups[1]
                                                , name: "castle wall"
                                                , desc: "provides powerful protection for your village"
                                                , req: ["stone", 35]
                                                , health: 1500
                                                , scale: 52
                                                , holdOffset: 20
                                                , placeOffset: -5
                                                , itemID: 5
                                                , itemAID: 21
                                                , }, {
                                                    group: this.groups[2]
                                                    , name: "spikes"
                                                    , desc: "damages enemies when they touch them"
                                                    , req: ["wood", 20, "stone", 5]
                                                    , health: 400
                                                    , dmg: 20
                                                    , scale: 49
                                                    , spritePadding: -23
                                                    , holdOffset: 8
                                                    , placeOffset: -5
                                                    , itemID: 6
                                                    , itemAID: 22
                                                    , }, {
                                                        age: 5
                                                        , group: this.groups[2]
                                                        , name: "greater spikes"
                                                        , desc: "damages enemies when they touch them"
                                                        , req: ["wood", 30, "stone", 10]
                                                        , health: 500
                                                        , dmg: 35
                                                        , scale: 52
                                                        , spritePadding: -23
                                                        , holdOffset: 8
                                                        , placeOffset: -5
                                                        , itemID: 7
                                                        , itemAID: 23
                                                        , }, {
                                                            age: 9
                                                            , group: this.groups[2]
                                                            , name: "poison spikes"
                                                            , desc: "poisons enemies when they touch them"
                                                            , req: ["wood", 35, "stone", 15]
                                                            , health: 600
                                                            , dmg: 30
                                                            , pDmg: 5
                                                            , scale: 52
                                                            , spritePadding: -23
                                                            , holdOffset: 8
                                                            , placeOffset: -5
                                                            , itemID: 8
                                                            , itemAID: 24
                                                            , }, {
                                                                age: 9
                                                                , group: this.groups[2]
                                                                , name: "spinning spikes"
                                                                , desc: "damages enemies when they touch them"
                                                                , req: ["wood", 30, "stone", 20]
                                                                , health: 500
                                                                , dmg: 45
                                                                , turnSpeed: 0.003
                                                                , scale: 52
                                                                , spritePadding: -23
                                                                , holdOffset: 8
                                                                , placeOffset: -5
                                                                , itemID: 9
                                                                , itemAID: 25
                                                                , }, {
                                                                    group: this.groups[3]
                                                                    , name: "windmill"
                                                                    , desc: "generates gold over time"
                                                                    , req: ["wood", 50, "stone", 10]
                                                                    , health: 400
                                                                    , pps: 1
                                                                    , turnSpeed: 0.0016
                                                                    , spritePadding: 25
                                                                    , iconLineMult: 12
                                                                    , scale: 45
                                                                    , holdOffset: 20
                                                                    , placeOffset: 5
                                                                    , itemID: 10
                                                                    , itemAID: 26
                                                                    , }, {
                                                                        age: 5
                                                                        , group: this.groups[3]
                                                                        , name: "faster windmill"
                                                                        , desc: "generates more gold over time"
                                                                        , req: ["wood", 60, "stone", 20]
                                                                        , health: 500
                                                                        , pps: 1.5
                                                                        , turnSpeed: 0.0025
                                                                        , spritePadding: 25
                                                                        , iconLineMult: 12
                                                                        , scale: 47
                                                                        , holdOffset: 20
                                                                        , placeOffset: 5
                                                                        , itemID: 11
                                                                        , itemAID: 27
                                                                        , }, {
                                                                            age: 8
                                                                            , group: this.groups[3]
                                                                            , name: "power mill"
                                                                            , desc: "generates more gold over time"
                                                                            , req: ["wood", 100, "stone", 50]
                                                                            , health: 800
                                                                            , pps: 2
                                                                            , turnSpeed: 0.005
                                                                            , spritePadding: 25
                                                                            , iconLineMult: 12
                                                                            , scale: 47
                                                                            , holdOffset: 20
                                                                            , placeOffset: 5
                                                                            , itemID: 12
                                                                            , itemAID: 28
                                                                            , }, {
                                                                                age: 5
                                                                                , group: this.groups[4]
                                                                                , type: 2
                                                                                , name: "mine"
                                                                                , desc: "allows you to mine stone"
                                                                                , req: ["wood", 20, "stone", 100]
                                                                                , iconLineMult: 12
                                                                                , scale: 65
                                                                                , holdOffset: 20
                                                                                , placeOffset: 0
                                                                                , itemID: 13
                                                                                , itemAID: 29
                                                                                , }, {
                                                                                    age: 5
                                                                                    , group: this.groups[11]
                                                                                    , type: 0
                                                                                    , name: "sapling"
                                                                                    , desc: "allows you to farm wood"
                                                                                    , req: ["wood", 150]
                                                                                    , iconLineMult: 12
                                                                                    , colDiv: 0.5
                                                                                    , scale: 110
                                                                                    , holdOffset: 50
                                                                                    , placeOffset: -15
                                                                                    , itemID: 14
                                                                                    , itemAID: 30
                                                                                    , }, {
                                                                                        age: 4
                                                                                        , group: this.groups[5]
                                                                                        , name: "pit trap"
                                                                                        , desc: "pit that traps enemies if they walk over it"
                                                                                        , req: ["wood", 30, "stone", 30]
                                                                                        , trap: true
                                                                                        , ignoreCollision: true
                                                                                        , hideFromEnemy: true
                                                                                        , health: 500
                                                                                        , colDiv: 0.2
                                                                                        , scale: 50
                                                                                        , holdOffset: 20
                                                                                        , placeOffset: -5
                                                                                        , alpha: 0.6
                                                                                        , itemID: 15
                                                                                        , itemAID: 31
                                                                                        , }, {
                                                                                            age: 4
                                                                                            , group: this.groups[6]
                                                                                            , name: "boost pad"
                                                                                            , desc: "provides boost when stepped on"
                                                                                            , req: ["stone", 20, "wood", 5]
                                                                                            , ignoreCollision: true
                                                                                            , boostSpeed: 1.5
                                                                                            , health: 150
                                                                                            , colDiv: 0.7
                                                                                            , scale: 45
                                                                                            , holdOffset: 20
                                                                                            , placeOffset: -5
                                                                                            , itemID: 16
                                                                                            , itemAID: 32
                                                                                            , }, {
                                                                                                age: 7
                                                                                                , group: this.groups[7]
                                                                                                , doUpdate: true
                                                                                                , name: "turret"
                                                                                                , desc: "defensive structure that shoots at enemies"
                                                                                                , req: ["wood", 200, "stone", 150]
                                                                                                , health: 800
                                                                                                , projectile: 1
                                                                                                , shootRange: 700
                                                                                                , shootRate: 2200
                                                                                                , scale: 43
                                                                                                , holdOffset: 20
                                                                                                , placeOffset: -5
                                                                                                , itemID: 17
                                                                                                , itemAID: 33
                                                                                                , }, {
                                                                                                    age: 7
                                                                                                    , group: this.groups[8]
                                                                                                    , name: "platform"
                                                                                                    , desc: "platform to shoot over walls and cross over water"
                                                                                                    , req: ["wood", 20]
                                                                                                    , ignoreCollision: true
                                                                                                    , zIndex: 1
                                                                                                    , health: 300
                                                                                                    , scale: 43
                                                                                                    , holdOffset: 20
                                                                                                    , placeOffset: -5
                                                                                                    , itemID: 18
                                                                                                    , itemAID: 34
                                                                                                    , }, {
                                                                                                        age: 7
                                                                                                        , group: this.groups[9]
                                                                                                        , name: "healing pad"
                                                                                                        , desc: "standing on it will slowly heal you"
                                                                                                        , req: ["wood", 30, "food", 10]
                                                                                                        , ignoreCollision: true
                                                                                                        , healCol: 15
                                                                                                        , health: 400
                                                                                                        , colDiv: 0.7
                                                                                                        , scale: 45
                                                                                                        , holdOffset: 20
                                                                                                        , placeOffset: -5
                                                                                                        , itemID: 19
                                                                                                        , itemAID: 35
                                                                                                        , }, {
                                                                                                            age: 9
                                                                                                            , group: this.groups[10]
                                                                                                            , name: "spawn pad"
                                                                                                            , desc: "you will spawn here when you die but it will dissapear"
                                                                                                            , req: ["wood", 100, "stone", 100]
                                                                                                            , health: 400
                                                                                                            , ignoreCollision: true
                                                                                                            , spawnPoint: true
                                                                                                            , scale: 45
                                                                                                            , holdOffset: 20
                                                                                                            , placeOffset: -5
                                                                                                            , itemID: 20
                                                                                                            , itemAID: 36
                                                                                                            , }, {
                                                                                                                age: 7
                                                                                                                , group: this.groups[12]
                                                                                                                , name: "blocker"
                                                                                                                , desc: "blocks building in radius"
                                                                                                                , req: ["wood", 30, "stone", 25]
                                                                                                                , ignoreCollision: true
                                                                                                                , blocker: 300
                                                                                                                , health: 400
                                                                                                                , colDiv: 0.7
                                                                                                                , scale: 45
                                                                                                                , holdOffset: 20
                                                                                                                , placeOffset: -5
                                                                                                                , itemID: 21
                                                                                                                , itemAID: 37
                                                                                                                , }, {
                                                                                                                    age: 7
                                                                                                                    , group: this.groups[13]
                                                                                                                    , name: "teleporter"
                                                                                                                    , desc: "teleports you to a random point on the map"
                                                                                                                    , req: ["wood", 60, "stone", 60]
                                                                                                                    , ignoreCollision: true
                                                                                                                    , teleport: true
                                                                                                                    , health: 200
                                                                                                                    , colDiv: 0.7
                                                                                                                    , scale: 45
                                                                                                                    , holdOffset: 20
                                                                                                                    , placeOffset: -5
                                                                                                                    , itemID: 22
                                                                                                                    , itemAID: 38
                                                                                                                }];

                        this.checkItem = {
                            index: function (id, myItems) {
                                return [0, 1, 2].includes(id) ? 0 : [3, 4, 5].includes(id) ? 1 : [6, 7, 8, 9].includes(id) ? 2 : [10, 11, 12].includes(id) ? 3 : [13, 14].includes(id) ? 5 : [15, 16].includes(id) ? 4 : [17, 18, 19, 21, 22].includes(id) ? [13, 14].includes(myItems) ? 6 :
                                5 :
                                id == 20 ? [13, 14].includes(myItems) ? 7 :
                                6 :
                                undefined;
                            }
                        }

                        for (let i = 0; i < this.list.length; ++i) {
                            this.list[i].id = i;
                            if (this.list[i].pre) this.list[i].pre = i - this.list[i].pre;
                        }

                        if (typeof window !== "undefined") {
                            function shuffle(a) {
                                for (let i = a.length - 1; i > 0; i--) {
                                    let j = Math.floor(Math.random() * (i + 1));
                                    [a[i], a[j]] = [a[j], a[i]];
                                }
                                return a;
                            }

                        }
                    }
                }
                class Objectmanager {
                    constructor(GameObject, liztobj, UTILS, config, players, server) {
                        let mathFloor = Math.floor
                        , mathABS = Math.abs
                        , mathCOS = Math.cos
                        , mathSIN = Math.sin
                        , mathPOW = Math.pow
                        , mathSQRT = Math.sqrt;

                        this.ignoreAdd = false;
                        this.hitObj = [];

                        this.disableObj = function (obj) {
                            obj.active = false;
                        };

                        let tmpObj;
                        this.add = function (sid, x, y, dir, s, type, data, setSID, owner) {
                            tmpObj = findObjectBySid(sid);
                            if (!tmpObj) {
                                tmpObj = gameObjects.find((tmp) => !tmp.active);
                                if (!tmpObj) {
                                    tmpObj = new GameObject(sid);
                                    gameObjects.push(tmpObj);
                                }
                            }
                            if (setSID) {
                                tmpObj.sid = sid;
                            }
                            tmpObj.init(x, y, dir, s, type, data, owner);
                        };

                        this.disableBySid = function (sid) {
                            let find = findObjectBySid(sid);
                            if (find) {
                                this.disableObj(find);
                            }
                        };

                        this.removeAllItems = function (sid, server) {
                            gameObjects.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid)
                                .forEach((tmp) => this.disableObj(tmp));
                        };

                        this.checkItemLocation = function (x, y, s, sM, indx, ignoreWater, placer) {
                            let cantPlace = liztobj.find((tmp) => tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
                            if (cantPlace) return false;
                            if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;
                            return true;
                        };

                    }
                }
                class Projectile {
                    constructor(players, ais, objectManager, items, config, UTILS, server) {

                        this.init = function (indx, x, y, dir, spd, dmg, rng, scl, owner) {
                            this.active = true;
                            this.tickActive = true;
                            this.indx = indx;
                            this.x = x;
                            this.y = y;
                            this.x2 = x;
                            this.y2 = y;
                            this.dir = dir;
                            this.skipMov = true;
                            this.speed = spd;
                            this.dmg = dmg;
                            this.scale = scl;
                            this.range = rng;
                            this.r2 = rng;
                            this.owner = owner;
                        };

                        this.update = function (delta) {
                            if (this.active) {
                                let tmpSpeed = this.speed * delta;
                                if (!this.skipMov) {
                                    this.x += tmpSpeed * Math.cos(this.dir);
                                    this.y += tmpSpeed * Math.sin(this.dir);
                                    this.range -= tmpSpeed;
                                    if (this.range <= 0) {
                                        this.x += this.range * Math.cos(this.dir);
                                        this.y += this.range * Math.sin(this.dir);
                                        tmpSpeed = 1;
                                        this.range = 0;
                                        this.active = false;
                                    }
                                } else {
                                    this.skipMov = false;
                                }
                            }
                        };
                        this.tickUpdate = function (delta) {
                            if (this.tickActive) {
                                let tmpSpeed = this.speed * delta;
                                if (!this.skipMov) {
                                    this.x2 += tmpSpeed * Math.cos(this.dir);
                                    this.y2 += tmpSpeed * Math.sin(this.dir);
                                    this.r2 -= tmpSpeed;
                                    if (this.r2 <= 0) {
                                        this.x2 += this.r2 * Math.cos(this.dir);
                                        this.y2 += this.r2 * Math.sin(this.dir);
                                        tmpSpeed = 1;
                                        this.r2 = 0;
                                        this.tickActive = false;
                                    }
                                } else {
                                    this.skipMov = false;
                                }
                            }
                        };
                    }
                };
                class Store {
                    constructor() {

                        this.hats = [{
                            id: 45
                            , name: "Shame!"
                            , dontSell: true
                            , price: 0
                            , scale: 120
                            , desc: "hacks are for winners"
                        }, {
                            id: 51
                            , name: "Moo Cap"
                            , price: 0
                            , scale: 120
                            , desc: "coolest mooer around"
                        }, {
                            id: 50
                            , name: "Apple Cap"
                            , price: 0
                            , scale: 120
                            , desc: "apple farms remembers"
                        }, {
                            id: 28
                            , name: "Moo Head"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 29
                            , name: "Pig Head"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 30
                            , name: "Fluff Head"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 36
                            , name: "Pandou Head"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 37
                            , name: "Bear Head"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 38
                            , name: "Monkey Head"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 44
                            , name: "Polar Head"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 35
                            , name: "Fez Hat"
                            , price: 0
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 42
                            , name: "Enigma Hat"
                            , price: 0
                            , scale: 120
                            , desc: "join the enigma army"
                        }, {
                            id: 43
                            , name: "Blitz Hat"
                            , price: 0
                            , scale: 120
                            , desc: "hey everybody i'm blitz"
                        }, {
                            id: 49
                            , name: "Bob XIII Hat"
                            , price: 0
                            , scale: 120
                            , desc: "like and subscribe"
                        }, {
                            id: 57
                            , name: "Pumpkin"
                            , price: 50
                            , scale: 120
                            , desc: "Spooooky"
                        }, {
                            id: 8
                            , name: "Bummle Hat"
                            , price: 100
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 2
                            , name: "Straw Hat"
                            , price: 500
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 15
                            , name: "Winter Cap"
                            , price: 600
                            , scale: 120
                            , desc: "allows you to move at normal speed in snow"
                            , coldM: 1
                        }, {
                            id: 5
                            , name: "Cowboy Hat"
                            , price: 1000
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 4
                            , name: "Ranger Hat"
                            , price: 2000
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 18
                            , name: "Explorer Hat"
                            , price: 2000
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 31
                            , name: "Flipper Hat"
                            , price: 2500
                            , scale: 120
                            , desc: "have more control while in water"
                            , watrImm: true
                        }, {
                            id: 1
                            , name: "Marksman Cap"
                            , price: 3000
                            , scale: 120
                            , desc: "increases arrow speed and range"
                            , aMlt: 1.3
                        }, {
                            id: 10
                            , name: "Bush Gear"
                            , price: 3000
                            , scale: 160
                            , desc: "allows you to disguise yourself as a bush"
                        }, {
                            id: 48
                            , name: "Halo"
                            , price: 3000
                            , scale: 120
                            , desc: "no effect"
                        }, {
                            id: 6
                            , name: "Soldier Helmet"
                            , price: 4000
                            , scale: 120
                            , desc: "reduces damage taken but slows movement"
                            , spdMult: 0.94
                            , dmgMult: 0.75
                        }, {
                            id: 23
                            , name: "Anti Venom Gear"
                            , price: 4000
                            , scale: 120
                            , desc: "makes you immune to poison"
                            , poisonRes: 1
                        }, {
                            id: 13
                            , name: "Medic Gear"
                            , price: 5000
                            , scale: 110
                            , desc: "slowly regenerates health over time"
                            , healthRegen: 3
                        }, {
                            id: 9
                            , name: "Miners Helmet"
                            , price: 5000
                            , scale: 120
                            , desc: "earn 1 extra gold per resource"
                            , extraGold: 1
                        }, {
                            id: 32
                            , name: "Musketeer Hat"
                            , price: 5000
                            , scale: 120
                            , desc: "reduces cost of projectiles"
                            , projCost: 0.5
                        }, {
                            id: 7
                            , name: "Bull Helmet"
                            , price: 6000
                            , scale: 120
                            , desc: "increases damage done but drains health"
                            , healthRegen: -5
                            , dmgMultO: 1.5
                            , spdMult: 0.96
                        }, {
                            id: 22
                            , name: "Emp Helmet"
                            , price: 6000
                            , scale: 120
                            , desc: "turrets won't attack but you move slower"
                            , antiTurret: 1
                            , spdMult: 0.7
                        }, {
                            id: 12
                            , name: "Booster Hat"
                            , price: 6000
                            , scale: 120
                            , desc: "increases your movement speed"
                            , spdMult: 1.16
                        }, {
                            id: 26
                            , name: "Barbarian Armor"
                            , price: 8000
                            , scale: 120
                            , desc: "knocks back enemies that attack you"
                            , dmgK: 0.6
                        }, {
                            id: 21
                            , name: "Plague Mask"
                            , price: 10000
                            , scale: 120
                            , desc: "melee attacks deal poison damage"
                            , poisonDmg: 5
                            , poisonTime: 6
                        }, {
                            id: 46
                            , name: "Bull Mask"
                            , price: 10000
                            , scale: 120
                            , desc: "bulls won't target you unless you attack them"
                            , bullRepel: 1
                        }, {
                            id: 14
                            , name: "Windmill Hat"
                            , topSprite: true
                            , price: 10000
                            , scale: 120
                            , desc: "generates points while worn"
                            , pps: 1.5
                        }, {
                            id: 11
                            , name: "Spike Gear"
                            , topSprite: true
                            , price: 10000
                            , scale: 120
                            , desc: "deal damage to players that damage you"
                            , dmg: 0.45
                        }, {
                            id: 53
                            , name: "Turret Gear"
                            , topSprite: true
                            , price: 10000
                            , scale: 120
                            , desc: "you become a walking turret"
                            , turret: {
                                proj: 1
                                , range: 700
                                , rate: 2500
                            }
                            , spdMult: 0.7
                        }, {
                            id: 20
                            , name: "Samurai Armor"
                            , price: 12000
                            , scale: 120
                            , desc: "increased attack speed and fire rate"
                            , atkSpd: 0.78
                        }, {
                            id: 58
                            , name: "Dark Knight"
                            , price: 12000
                            , scale: 120
                            , desc: "restores health when you deal damage"
                            , healD: 0.4
                        }, {
                            id: 27
                            , name: "Scavenger Gear"
                            , price: 15000
                            , scale: 120
                            , desc: "earn double points for each kill"
                            , kScrM: 2
                        }, {
                            id: 40
                            , name: "Tank Gear"
                            , price: 15000
                            , scale: 120
                            , desc: "increased damage to buildings but slower movement"
                            , spdMult: 0.3
                            , bDmg: 3.3
                        }, {
                            id: 52
                            , name: "Thief Gear"
                            , price: 15000
                            , scale: 120
                            , desc: "steal half of a players gold when you kill them"
                            , goldSteal: 0.5
                        }, {
                            id: 55
                            , name: "Bloodthirster"
                            , price: 20000
                            , scale: 120
                            , desc: "Restore Health when dealing damage. And increased damage"
                            , healD: 0.25
                            , dmgMultO: 1.2
                            , }, {
                                id: 56
                                , name: "Assassin Gear"
                                , price: 20000
                                , scale: 120
                                , desc: "Go invisible when not moving. Can't eat. Increased speed"
                                , noEat: true
                                , spdMult: 1.1
                                , invisTimer: 1000
                            }];

                        this.accessories = [{
                            id: 12
                            , name: "Snowball"
                            , price: 1000
                            , scale: 105
                            , xOff: 18
                            , desc: "no effect"
                        }, {
                            id: 9
                            , name: "Tree Cape"
                            , price: 1000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 10
                            , name: "Stone Cape"
                            , price: 1000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 3
                            , name: "Cookie Cape"
                            , price: 1500
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 8
                            , name: "Cow Cape"
                            , price: 2000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 11
                            , name: "Monkey Tail"
                            , price: 2000
                            , scale: 97
                            , xOff: 25
                            , desc: "Super speed but reduced damage"
                            , spdMult: 1.35
                            , dmgMultO: 0.2
                        }, {
                            id: 17
                            , name: "Apple Basket"
                            , price: 3000
                            , scale: 80
                            , xOff: 12
                            , desc: "slowly regenerates health over time"
                            , healthRegen: 1
                        }, {
                            id: 6
                            , name: "Winter Cape"
                            , price: 3000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 4
                            , name: "Skull Cape"
                            , price: 4000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 5
                            , name: "Dash Cape"
                            , price: 5000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 2
                            , name: "Dragon Cape"
                            , price: 6000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 1
                            , name: "Super Cape"
                            , price: 8000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 7
                            , name: "Troll Cape"
                            , price: 8000
                            , scale: 90
                            , desc: "no effect"
                        }, {
                            id: 14
                            , name: "Thorns"
                            , price: 10000
                            , scale: 115
                            , xOff: 20
                            , desc: "no effect"
                        }, {
                            id: 15
                            , name: "Blockades"
                            , price: 10000
                            , scale: 95
                            , xOff: 15
                            , desc: "no effect"
                        }, {
                            id: 20
                            , name: "Devils Tail"
                            , price: 10000
                            , scale: 95
                            , xOff: 20
                            , desc: "no effect"
                        }, {
                            id: 16
                            , name: "Sawblade"
                            , price: 12000
                            , scale: 90
                            , spin: true
                            , xOff: 0
                            , desc: "deal damage to players that damage you"
                            , dmg: 0.15
                        }, {
                            id: 13
                            , name: "Angel Wings"
                            , price: 15000
                            , scale: 138
                            , xOff: 22
                            , desc: "slowly regenerates health over time"
                            , healthRegen: 3
                        }, {
                            id: 19
                            , name: "Shadow Wings"
                            , price: 15000
                            , scale: 138
                            , xOff: 22
                            , desc: "increased movement speed"
                            , spdMult: 1.1
                        }, {
                            id: 18
                            , name: "Blood Wings"
                            , price: 20000
                            , scale: 178
                            , xOff: 26
                            , desc: "restores health when you deal damage"
                            , healD: 0.2
                        }, {
                            id: 21
                            , name: "Corrupt X Wings"
                            , price: 20000
                            , scale: 178
                            , xOff: 26
                            , desc: "deal damage to players that damage you"
                            , dmg: 0.25
                        }];
                    }
                };
                class ProjectileManager {
                    constructor(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
                        this.addProjectile = function (x, y, dir, range, speed, indx, owner, ignoreObj, layer, inWindow) {
                            let tmpData = items.projectiles[indx];
                            let tmpProj;
                            for (let i = 0; i < projectiles.length; ++i) {
                                if (!projectiles[i].active) {
                                    tmpProj = projectiles[i];
                                    break;
                                }
                            }
                            if (!tmpProj) {
                                tmpProj = new Projectile(players, ais, objectManager, items, config, UTILS, server);
                                tmpProj.sid = projectiles.length;
                                projectiles.push(tmpProj);
                            }
                            tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
                            tmpProj.ignoreObj = ignoreObj;
                            tmpProj.layer = layer || tmpData.layer;
                            tmpProj.inWindow = inWindow;
                            tmpProj.src = tmpData.src;
                            return tmpProj;
                        };
                    }
                };
                class AiManager {

                    constructor(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {

                        this.aiTypes = [{
                            id: 0
                            , src: "cow_1"
                            , killScore: 150
                            , health: 500
                            , weightM: 0.8
                            , speed: 0.00095
                            , turnSpeed: 0.001
                            , scale: 72
                            , drop: ["food", 50]
                        }, {
                            id: 1
                            , src: "pig_1"
                            , killScore: 200
                            , health: 800
                            , weightM: 0.6
                            , speed: 0.00085
                            , turnSpeed: 0.001
                            , scale: 72
                            , drop: ["food", 80]
                        }, {
                            id: 2
                            , name: "Bull"
                            , src: "bull_2"
                            , hostile: true
                            , dmg: 20
                            , killScore: 1000
                            , health: 1800
                            , weightM: 0.5
                            , speed: 0.00094
                            , turnSpeed: 0.00074
                            , scale: 78
                            , viewRange: 800
                            , chargePlayer: true
                            , drop: ["food", 100]
                        }, {
                            id: 3
                            , name: "Bully"
                            , src: "bull_1"
                            , hostile: true
                            , dmg: 20
                            , killScore: 2000
                            , health: 2800
                            , weightM: 0.45
                            , speed: 0.001
                            , turnSpeed: 0.0008
                            , scale: 90
                            , viewRange: 900
                            , chargePlayer: true
                            , drop: ["food", 400]
                        }, {
                            id: 4
                            , name: "Wolf"
                            , src: "wolf_1"
                            , hostile: true
                            , dmg: 8
                            , killScore: 500
                            , health: 300
                            , weightM: 0.45
                            , speed: 0.001
                            , turnSpeed: 0.002
                            , scale: 84
                            , viewRange: 800
                            , chargePlayer: true
                            , drop: ["food", 200]
                        }, {
                            id: 5
                            , name: "Quack"
                            , src: "chicken_1"
                            , dmg: 8
                            , killScore: 2000
                            , noTrap: true
                            , health: 300
                            , weightM: 0.2
                            , speed: 0.0018
                            , turnSpeed: 0.006
                            , scale: 70
                            , drop: ["food", 100]
                        }, {
                            id: 6
                            , name: "MOOSTAFA"
                            , nameScale: 50
                            , src: "enemy"
                            , hostile: true
                            , dontRun: true
                            , fixedSpawn: true
                            , spawnDelay: 60000
                            , noTrap: true
                            , colDmg: 100
                            , dmg: 40
                            , killScore: 8000
                            , health: 18000
                            , weightM: 0.4
                            , speed: 0.0007
                            , turnSpeed: 0.01
                            , scale: 80
                            , spriteMlt: 1.8
                            , leapForce: 0.9
                            , viewRange: 1000
                            , hitRange: 210
                            , hitDelay: 1000
                            , chargePlayer: true
                            , drop: ["food", 100]
                        }, {
                            id: 7
                            , name: "Treasure"
                            , hostile: true
                            , nameScale: 35
                            , src: "crate_1"
                            , fixedSpawn: true
                            , spawnDelay: 120000
                            , colDmg: 200
                            , killScore: 5000
                            , health: 20000
                            , weightM: 0.1
                            , speed: 0.0
                            , turnSpeed: 0.0
                            , scale: 70
                            , spriteMlt: 1.0
                        }, {
                            id: 8
                            , name: "MOOFIE"
                            , src: "wolf_2"
                            , hostile: true
                            , fixedSpawn: true
                            , dontRun: true
                            , hitScare: 4
                            , spawnDelay: 30000
                            , noTrap: true
                            , nameScale: 35
                            , dmg: 10
                            , colDmg: 100
                            , killScore: 3000
                            , health: 7000
                            , weightM: 0.45
                            , speed: 0.0015
                            , turnSpeed: 0.002
                            , scale: 90
                            , viewRange: 800
                            , chargePlayer: true
                            , drop: ["food", 1000]
                        }, {
                            id: 9
                            , name: "üíÄMOOFIE"
                            , src: "wolf_2"
                            , hostile: !0
                            , fixedSpawn: !0
                            , dontRun: !0
                            , hitScare: 50
                            , spawnDelay: 6e4
                            , noTrap: !0
                            , nameScale: 35
                            , dmg: 12
                            , colDmg: 100
                            , killScore: 3e3
                            , health: 9e3
                            , weightM: .45
                            , speed: .0015
                            , turnSpeed: .0025
                            , scale: 94
                            , viewRange: 1440
                            , chargePlayer: !0
                            , drop: ["food", 3e3]
                            , minSpawnRange: .85
                            , maxSpawnRange: .9
                        }, {
                            id: 10
                            , name: "üíÄWolf"
                            , src: "wolf_1"
                            , hostile: !0
                            , fixedSpawn: !0
                            , dontRun: !0
                            , hitScare: 50
                            , spawnDelay: 3e4
                            , dmg: 10
                            , killScore: 700
                            , health: 500
                            , weightM: .45
                            , speed: .00115
                            , turnSpeed: .0025
                            , scale: 88
                            , viewRange: 1440
                            , chargePlayer: !0
                            , drop: ["food", 400]
                            , minSpawnRange: .85
                            , maxSpawnRange: .9
                        }, {
                            id: 11
                            , name: "üíÄBully"
                            , src: "bull_1"
                            , hostile: !0
                            , fixedSpawn: !0
                            , dontRun: !0
                            , hitScare: 50
                            , dmg: 20
                            , killScore: 5e3
                            , health: 5e3
                            , spawnDelay: 1e5
                            , weightM: .45
                            , speed: .00115
                            , turnSpeed: .0025
                            , scale: 94
                            , viewRange: 1440
                            , chargePlayer: !0
                            , drop: ["food", 800]
                            , minSpawnRange: .85
                            , maxSpawnRange: .9
                        }];

                        this.spawn = function (x, y, dir, index) {
                            let tmpObj = ais.find((tmp) => !tmp.active);
                            if (!tmpObj) {
                                tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server);
                                ais.push(tmpObj);
                            }
                            tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                            return tmpObj;
                        };
                    }

                };
                class AI {
                    constructor(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
                        this.sid = sid;
                        this.isAI = true;
                        this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);

                        this.init = function (x, y, dir, index, data) {
                            this.x = x;
                            this.y = y;
                            this.startX = data.fixedSpawn ? x : null;
                            this.startY = data.fixedSpawn ? y : null;
                            this.xVel = 0;
                            this.yVel = 0;
                            this.zIndex = 0;
                            this.dir = dir;
                            this.dirPlus = 0;
                            this.showName = 'aaa';
                            this.index = index;
                            this.src = data.src;
                            if (data.name) this.name = data.name;
                            (this.name || "")
                                .startsWith("üíÄ") && (this.isVolcanoAi = !0);
                            this.weightM = data.weightM;
                            this.speed = data.speed;
                            this.killScore = data.killScore;
                            this.turnSpeed = data.turnSpeed;
                            this.scale = data.scale;
                            this.maxHealth = data.health;
                            this.leapForce = data.leapForce;
                            this.health = this.maxHealth;
                            this.chargePlayer = data.chargePlayer;
                            this.viewRange = data.viewRange;
                            this.drop = data.drop;
                            this.dmg = data.dmg;
                            this.hostile = data.hostile;
                            this.dontRun = data.dontRun;
                            this.hitRange = data.hitRange;
                            this.hitDelay = data.hitDelay;
                            this.hitScare = data.hitScare;
                            this.spriteMlt = data.spriteMlt;
                            this.nameScale = data.nameScale;
                            this.colDmg = data.colDmg;
                            this.noTrap = data.noTrap;
                            this.spawnDelay = data.spawnDelay;
                            this.hitWait = 0;
                            this.waitCount = 1000;
                            this.moveCount = 0;
                            this.targetDir = 0;
                            this.active = true;
                            this.alive = true;
                            this.runFrom = null;
                            this.chargeTarget = null;
                            this.dmgOverTime = {};
                        };
                        this.getVolcanoAggression = function () {
                            let p = UTILS.getDistance(this.x, this.y, config.volcanoLocationX, config.volcanoLocationY)
                            , h = p > config.volcanoAggressionRadius ? 0 : config.volcanoAggressionRadius - p;
                            return 1 + config.volcanoAggressionPercentage * (1 - h / config.volcanoAggressionRadius)
                        }
                        let tmpRatio = 0;
                        let animIndex = 0;
                        this.animate = function (delta) {
                            if (this.animTime > 0) {
                                this.animTime -= delta;
                                if (this.animTime <= 0) {
                                    this.animTime = 0;
                                    this.dirPlus = 0;
                                    tmpRatio = 0;
                                    animIndex = 0;
                                } else {
                                    if (animIndex == 0) {
                                        tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                        if (tmpRatio >= 1) {
                                            tmpRatio = 1;
                                            animIndex = 1;
                                        }
                                    } else {
                                        tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                                    }
                                }
                            }
                        };

                        this.startAnim = function () {
                            this.animTime = this.animSpeed = 600;
                            this.targetAngle = Math.PI * 0.8;
                            tmpRatio = 0;
                            animIndex = 0;
                        };

                    };

                };
                class addCh {
                    constructor(x, y, chat, tmpObj) {
                        this.x = x;
                        this.y = y;
                        this.alpha = 0;
                        this.active = true;
                        this.alive = false;
                        this.chat = chat;
                        this.owner = tmpObj;
                    };
                };
                class DeadPlayer {
                    constructor(x, y, dir, buildIndex, weaponIndex, weaponVariant, skinColor, scale, name) {
                        this.x = x;
                        this.y = y;
                        this.lastDir = dir;
                        this.dir = dir + Math.PI;
                        this.buildIndex = buildIndex;
                        this.weaponIndex = weaponIndex;
                        this.weaponVariant = weaponVariant;
                        this.skinColor = skinColor;
                        this.scale = scale;
                        this.visScale = 0;
                        this.name = name;
                        this.alpha = 1;
                        this.active = true;
                        this.animate = function (delta) {
                            let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                            if (d2 > 0.01) {
                                this.dir += d2 / 20;
                            } else {
                                this.dir = this.lastDir;
                            }
                            if (this.visScale < this.scale) {
                                this.visScale += delta / (this.scale / 2);
                                if (this.visScale >= this.scale) {
                                    this.visScale = this.scale;
                                }
                            }
                            this.alpha -= delta / 30000;
                            if (this.alpha <= 0) {
                                this.alpha = 0;
                                this.active = false;
                            }
                        }
                    }
                };

                class Player {
                    constructor(id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
                        this.id = id;
                        this.sid = sid;
                        this.tmpScore = 0;
                        this.team = null;
                        this.latestSkin = 0;
                        this.oldSkinIndex = 0;
                        this.skinIndex = 0;
                        this.latestTail = 0;
                        this.oldTailIndex = 0;
                        this.tailIndex = 0;
                        this.hitTime = 0;
                        this.lastHit = 0;
                        this.showName = 'NOOO';
                        this.tails = {};
                        for (let i = 0; i < accessories.length; ++i) {
                            if (accessories[i].price <= 0)
                                this.tails[accessories[i].id] = 1;
                        }
                        this.skins = {};
                        for (let i = 0; i < hats.length; ++i) {
                            if (hats[i].price <= 0)
                                this.skins[hats[i].id] = 1;
                        }
                        this.points = 0;
                        this.dt = 0;
                        this.hidden = false;
                        this.itemCounts = {};
                        this.isPlayer = true;
                        this.pps = 0;
                        this.moveDir = undefined;
                        this.skinRot = 0;
                        this.lastPing = 0;
                        this.iconIndex = 0;
                        this.skinColor = 0;
                        this.dist2 = 0;
                        this.aim2 = 0;
                        this.maxSpeed = 1;
                        this.chat = {
                            message: null
                            , count: 0
                        };
                        this.backupNobull = true;
                        this.circle = false;
                        this.circleRad = 200;
                        this.circleRadSpd = 0.1;
                        this.cAngle = 0;

                        this.spawn = function (moofoll) {
                            this.attacked = false;
                            this.timeDamaged = 0;
                            this.timeHealed = 100;
                            this.pinge = 0;
                            this.millPlace = 'NOOO';
                            this.lastshamecount = 0;
                            this.death = false;
                            this.spinDir = 0;
                            this.sync = false;
                            this.antiBull = 0;
                            this.bullTimer = 0;
                            this.poisonTimer = 0;
                            this.active = true;
                            this.alive = true;
                            this.lockMove = false;
                            this.lockDir = false;
                            this.minimapCounter = 0;
                            this.chatCountdown = 0;
                            this.shameCount = 0;
                            this.shameTimer = 0;
                            this.sentTo = {};
                            this.gathering = 0;
                            this.gatherIndex = 0;
                            this.shooting = {};
                            this.shootIndex = 9;
                            this.autoGather = 0;
                            this.animTime = 0;
                            this.animSpeed = 0;
                            this.mouseState = 0;
                            this.buildIndex = -1;
                            this.weaponIndex = 0;
                            this.weaponCode = 0;
                            this.weaponVariant = 0;
                            this.primaryIndex = undefined;
                            this.secondaryIndex = undefined;
                            this.dmgOverTime = {};
                            this.noMovTimer = 0;
                            this.maxXP = 300;
                            this.XP = 0;
                            this.age = 1;
                            this.kills = 0;
                            this.upgrAge = 2;
                            this.upgradePoints = 0;
                            this.x = 0;
                            this.y = 0;
                            this.oldXY = {
                                x: 0
                                , y: 0
                            };
                            this.zIndex = 0;
                            this.xVel = 0;
                            this.yVel = 0;
                            this.slowMult = 1;
                            this.dir = 0;
                            this.dirPlus = 0;
                            this.targetDir = 0;
                            this.targetAngle = 0;
                            this.maxHealth = 100;
                            this.health = this.maxHealth;
                            this.oldHealth = this.maxHealth;
                            this.damaged = 0;
                            this.scale = config.playerScale;
                            this.speed = config.playerSpeed;
                            this.resetMoveDir();
                            this.resetResources(moofoll);
                            this.items = [0, 3, 6, 10];
                            this.weapons = [0];
                            this.shootCount = 0;
                            this.weaponXP = [];
                            this.reloads = {
                                0: 0
                                , 1: 0
                                , 2: 0
                                , 3: 0
                                , 4: 0
                                , 5: 0
                                , 6: 0
                                , 7: 0
                                , 8: 0
                                , 9: 0
                                , 10: 0
                                , 11: 0
                                , 12: 0
                                , 13: 0
                                , 14: 0
                                , 15: 0
                                , 53: 0
                                , };
                            this.bowThreat = {
                                9: 0
                                , 12: 0
                                , 13: 0
                                , 15: 0
                                , };
                            this.damageThreat = 0;
                            this.inTrap = false;
                            this.canEmpAnti = false;
                            this.empAnti = false;
                            this.soldierAnti = false;
                            this.poisonTick = 0;
                            this.bullTick = 0;
                            this.setPoisonTick = false;
                            this.setBullTick = false;
                            this.antiTimer = 2;
                        };

                        this.resetMoveDir = function () {
                            this.moveDir = undefined;
                        };

                        this.resetResources = function (moofoll) {
                            for (let i = 0; i < config.resourceTypes.length; ++i) {
                                this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                            }
                        };

                        this.getItemType = function (id) {
                            let findindx = this.items.findIndex((ids) => ids == id);
                            if (findindx != -1) {
                                return findindx;
                            } else {
                                return items.checkItem.index(id, this.items);
                            }
                        };

                        this.setData = function (data) {
                            this.id = data[0];
                            this.sid = data[1];
                            this.name = data[2];
                            this.x = data[3];
                            this.y = data[4];
                            this.dir = data[5];
                            this.health = data[6];
                            this.maxHealth = data[7];
                            this.scale = data[8];
                            this.skinColor = data[9];
                        };

                        this.updateTimer = function () {
                            this.bullTimer -= 1;
                            if (this.bullTimer <= 0) {
                                this.setBullTick = false;
                                this.bullTick = game.tick - 1;
                                this.bullTimer = config.serverUpdateRate;
                            }
                            this.poisonTimer -= 1;
                            if (this.poisonTimer <= 0) {
                                this.setPoisonTick = false;
                                this.poisonTick = game.tick - 1;
                                this.poisonTimer = config.serverUpdateRate;
                            }

                        };
                        this.update = function (delta) {
                            if (this.active) {

                                let gear = {
                                    skin: findID(hats, this.skinIndex)
                                    , tail: findID(accessories, this.tailIndex)
                                }
                                let spdMult = ((this.buildIndex >= 0) ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (gear.skin ? (gear.skin.spdMult || 1) : 1) * (gear.tail ? (gear.tail.spdMult || 1) : 1) * (this.y <= config.snowBiomeTop ? ((gear.skin && gear.skin.coldM) ? 1 : config.snowSpeed) : 1) * this.slowMult;
                                this.maxSpeed = spdMult;

                            }
                        };

                        let tmpRatio = 0;
                        let animIndex = 0;
                        this.animate = function (delta) {
                            if (this.animTime > 0) {
                                this.animTime -= delta;
                                if (this.animTime <= 0) {
                                    this.animTime = 0;
                                    this.dirPlus = 0;
                                    tmpRatio = 0;
                                    animIndex = 0;
                                } else {
                                    if (animIndex == 0) {
                                        tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                        if (tmpRatio >= 1) {
                                            tmpRatio = 1;
                                            animIndex = 1;
                                        }
                                    } else {
                                        tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                                    }
                                }
                            }
                        };

                        this.startAnim = function (didHit, index) {
                            this.animTime = this.animSpeed = items.weapons[index].speed;
                            this.targetAngle = (didHit ? -config.hitAngle : -Math.PI);
                            tmpRatio = 0;
                            animIndex = 0;
                        };

                        this.canSee = function (other) {
                            if (!other) return false;
                            let dx = Math.abs(other.x - this.x) - other.scale;
                            let dy = Math.abs(other.y - this.y) - other.scale;
                            return dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3;
                        };

                        this.judgeShame = function () {
                            this.lastshamecount = this.shameCount;
                            if (this.oldHealth < this.health) {
                                if (this.hitTime) {
                                    let timeSinceHit = game.tick - this.hitTime;
                                    this.lastHit = game.tick;
                                    this.hitTime = 0;
                                    if (timeSinceHit < 2) {
                                        this.shameCount++;
                                    } else {
                                        this.shameCount = Math.max(0, this.shameCount - 2);
                                    }
                                }
                            } else if (this.oldHealth > this.health) {
                                this.hitTime = game.tick;
                            }
                        };

                        this.addShameTimer = function () {
                            this.shameCount = 0;
                            this.shameTimer = 30;
                            let interval = setInterval(() => {
                                this.shameTimer--;
                                if (this.shameTimer <= 0) {
                                    clearInterval(interval);
                                }
                            }, 1000);
                        };

                        this.isTeam = function (tmpObj) {
                            return (this == tmpObj || (this.team && this.team == tmpObj.team));
                        };

                        this.findAllianceBySid = function (sid) {
                            return this.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
                        };

                        this.checkCanInsta = function (nobull) {
                            let totally = 0;
                            if (this.alive && inGame) {
                                let primary = {
                                    weapon: this.weapons[0]
                                    , variant: this.primaryVariant
                                    , dmg: this.weapons[0] == undefined ? 0 : items.weapons[this.weapons[0]].dmg
                                    , };
                                let secondary = {
                                    weapon: this.weapons[1]
                                    , variant: this.secondaryVariant
                                    , dmg: this.weapons[1] == undefined ? 0 : items.weapons[this.weapons[1]].Pdmg
                                    , };
                                let bull = this.skins[7] && !nobull ? 1.5 : 1;
                                let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1;
                                if (primary.weapon != undefined && this.reloads[primary.weapon] == 0) {
                                    totally += primary.dmg * pV * bull;
                                }
                                if (secondary.weapon != undefined && this.reloads[secondary.weapon] == 0) {
                                    totally += secondary.dmg;
                                }
                                if (this.skins[53] && this.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate) && near.skinIndex != 22) {
                                    totally += 25;
                                }
                                totally *= near.skinIndex == 6 ? 0.75 : 1;
                                return totally;
                            }
                            return 0;
                        };

                        this.manageReload = function () {
                            if (this.shooting[53]) {
                                this.shooting[53] = 0;
                                this.reloads[53] = (2500 - game.tickRate);
                            } else {
                                if (this.reloads[53] > 0) {
                                    this.reloads[53] = Math.max(0, this.reloads[53] - game.tickRate);
                                }
                            }

                            if (this.reloads[this.weaponIndex] <= 1000 / 9) {
                                let index = this.weaponIndex;
                                let nearObja = liztobj.filter((e) => (e.active || e.alive) && e.health < e.maxHealth && e.group !== undefined && UTILS.getDist(e, player, 0, 2) <= (items.weapons[player.weaponIndex].range + e.scale));
                                for (let i = 0; i < nearObja.length; i++) {
                                    let aaa = nearObja[i];

                                    let val = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * 3.3;
                                    let valaa = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1);
                                    if (aaa.health - (valaa) <= 0 && near.length) {
                                        place(near.dist2 < ((near.scale * 1.8) + 50) ? 4 : 2, caf(aaa, player) + Math.PI);
                                    }
                                }
                            }

                            if (this.gathering || this.shooting[1]) {
                                if (this.gathering) {
                                    this.gathering = 0;
                                    this.reloads[this.gatherIndex] = (items.weapons[this.gatherIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                                    this.attacked = true;
                                }
                                if (this.shooting[1]) {
                                    this.shooting[1] = 0;
                                    this.reloads[this.shootIndex] = (items.weapons[this.shootIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                                    this.attacked = true;
                                }
                            } else {
                                this.attacked = false;
                                if (this.buildIndex < 0) {
                                    if (this.reloads[this.weaponIndex] > 0) {

                                        this.reloads[this.weaponIndex] = Math.max(0, this.reloads[this.weaponIndex] - 110);
                                        if (this == player) {
                                            if (getEl("weaponGrind")
                                                .checked) {
                                                for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                                    checkPlace(player.getItemType(22), i);
                                                }
                                            }
                                        }
                                        if (this.reloads[this.primaryIndex] == 0 && this.reloads[this.weaponIndex] == 0) {
                                            this.antiBull++;
                                            game.tickBase(() => {
                                                this.antiBull = 0;
                                            }, 1);
                                        }
                                    }
                                }
                            }
                        };

                        this.addDamageThreat = function (tmpObj) {
                            let primary = {
                                weapon: this.primaryIndex
                                , variant: this.primaryVariant
                            };
                            primary.dmg = primary.weapon == undefined ? 45 : items.weapons[primary.weapon].dmg;
                            let secondary = {
                                weapon: this.secondaryIndex
                                , variant: this.secondaryVariant
                            };
                            secondary.dmg = secondary.weapon == undefined ? 35 : items.weapons[secondary.weapon].Pdmg;
                            let bull = 1.5;
                            let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
                            let sV = secondary.variant != undefined ? [9, 12, 17, 15].includes(secondary.weapon) ? 1 : config.weaponVariants[secondary.variant].val : 1.18;
                            if (primary.weapon == undefined ? true : this.reloads[primary.weapon] == 0) {
                                this.damageThreat += primary.dmg * pV * bull;
                            }
                            if (secondary.weapon == undefined ? true : this.reloads[secondary.weapon] == 0) {
                                this.damageThreat += secondary.dmg * sV;
                            }
                            if (this.reloads[53] <= game.tickRate) {
                                this.damageThreat += 25;
                            }
                            this.damageThreat *= tmpObj.skinIndex == 6 ? 0.75 : 1;
                            if (!this.isTeam(tmpObj)) {
                                if (this.dist2 <= 300) {
                                    tmpObj.damageThreat += this.damageThreat;
                                }
                            }
                        };

                        this.addDamageProbability = function (tmpObj) {
                            let primary = {
                                weapon: this.primaryIndex
                                , variant: this.primaryVariant
                            };
                            primary.dmg = primary.weapon == undefined ? 45 : items.weapons[primary.weapon].dmg;
                            let secondary = {
                                weapon: this.secondaryIndex
                                , variant: this.secondaryVariant
                            };
                            secondary.dmg = secondary.weapon == undefined ? 50 : items.weapons[secondary.weapon].Pdmg;
                            let bull = 1.5;
                            let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
                            let sV = secondary.variant != undefined ? [9, 12, 17, 15].includes(secondary.weapon) ? 1 : config.weaponVariants[secondary.variant].val : 1.18;
                            if (primary.weapon == undefined ? true : this.reloads[primary.weapon] == 0) {
                                this.damageProbably += primary.dmg * pV * bull * 0.75;
                            }
                            if (secondary.weapon == undefined ? true : this.reloads[secondary.weapon] == 0) {
                                this.damageProbably += secondary.dmg * sV;
                            }
                            this.damageProbably *= 0.75;
                            if (!this.isTeam(tmpObj)) {
                                if (this.dist2 <= 300) {
                                    tmpObj.damageProbably += this.damageProbably;
                                }
                            }
                        };
                    }
                };

                function sendUpgrade(index) {
                    player.reloads[index] = 0;
                    packet("H", index);
                }

                function storeEquip(id, index) {
                    packet("c", 0, id, index);
                }

                function storeBuy(id, index) {
                    packet("c", 1, id, index);
                }

                function buyEquip(id, index) {
                    let nID = player.skins[6] ? 6 : 0;
                    if (player.alive && inGame) {
                        if (index == 0) {
                            if (player.skins[id]) {
                                if (player.latestSkin != id) {
                                    packet("c", 0, id, 0);
                                }
                            } else {
                                if (configs.autoBuyEquip) {
                                    let find = findID(hats, id);
                                    if (find) {
                                        if (player.points >= find.price) {
                                            packet("c", 1, id, 0);
                                            packet("c", 0, id, 0);
                                        } else {
                                            if (player.latestSkin != nID) {
                                                packet("c", 0, nID, 0);
                                            }
                                        }
                                    } else {
                                        if (player.latestSkin != nID) {
                                            packet("c", 0, nID, 0);
                                        }
                                    }
                                } else {
                                    if (player.latestSkin != nID) {
                                        packet("c", 0, nID, 0);
                                    }
                                }
                            }
                        } else if (index == 1) {
                            if (useWasd && (id != 11 && id != 0)) {
                                if (player.latestTail != 0) {
                                    packet("c", 0, 0, 1);
                                }
                                return;
                            }
                            if (player.tails[id]) {
                                if (player.latestTail != id) {
                                    packet("c", 0, id, 1);
                                }
                            } else {
                                if (configs.autoBuyEquip) {
                                    let find = findID(accessories, id);
                                    if (find) {
                                        if (player.points >= find.price) {
                                            packet("c", 1, id, 1);
                                            packet("c", 0, id, 1);
                                        } else {
                                            if (player.latestTail != 0) {
                                                packet("c", 0, 0, 1);
                                            }
                                        }
                                    } else {
                                        if (player.latestTail != 0) {
                                            packet("c", 0, 0, 1);
                                        }
                                    }
                                } else {
                                    if (player.latestTail != 0) {
                                        packet("c", 0, 0, 1);
                                    }
                                }
                            }
                        }
                    }
                }

                function findAllianceBySid(sid) {
                    return player.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
                }

                function calculatePossibleTrapPositions(x, y, radius) {
                    let trapPositions = [];
                    let numPositions = 16;
                    for (let i = 0; i < numPositions; i++) {
                        let angle = (2 * Math.PI * i) / numPositions;
                        let offsetX = x + radius * Math.cos(angle);
                        let offsetY = y + radius * Math.sin(angle);
                        let position = [offsetX, offsetY];
                        if (!trapPositions.some((pos) => isPositionTooClose(position, pos))) {
                            trapPositions.push(position);
                        }
                    }
                    return trapPositions;
                }

                function isPositionTooClose(position1, position2, minDistance = 50) {
                    let dist = Math.hypot(position1[0] - position2[0], position1[1] - position2[1]);
                    return dist < minDistance;
                }

                function selectToBuild(index, wpn) {
                    packet("z", index, wpn);
                }

                function selectWeapon(index, isPlace) {
                    if (!isPlace) {
                        player.weaponCode = index;
                    }
                    packet("z", index, 1);
                }

                function sendAutoGather() {
                    packet("K", 1, 1);
                }

                function sendAtck(id, angle) {
                    packet("F", id, angle, 1);
                }

                function place(id, rad, rmd) {
                    if (id == undefined) return;
                    let item = items.list[player.items[id]];
                    let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                    let tmpX = player.x2 + tmpS * Math.cos(rad);
                    let tmpY = player.y2 + tmpS * Math.sin(rad);
                    if ((player.alive && inGame && player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? id === 3 || id === 5 ? 299 : 99 : item.group.limit ? item.group.limit : 99))) {
                        selectToBuild(player.items[id]);
                        sendAtck(1, rad);
                        sendAtck(0, rad);
                        selectWeapon(player.weaponCode, 1);
                        if (rmd && getEl("placeVis").checked) {
                            placeVisible.push({
                                x: tmpX
                                , y: tmpY
                                , name: item.name
                                , scale: item.scale
                                , dir: rad
                            });
                            game.tickBase(() => {
                                placeVisible.shift();
                            }, 1)
                        }
                    }
                }

                function checkPlace(id, radian) {
                    if (id == undefined) return;
                    let item = items.list[player.items[id]];
                    let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                    let tmpX = player.x2 + tmpS * Math.cos(radian);
                    let tmpY = player.y2 + tmpS * Math.sin(radian);
                    if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player)) {
                        place(id, radian, 1);
                    }
                }

                function soldierMult() {
                    return player.latestSkin == 6 ? 0.75 : 1;
                }

                function healthBased() {
                    if (player.health == 100) {
                        return 0;
                    }
                    if ((player.skinIndex != 45 && player.skinIndex != 56)) {
                        return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
                    }
                    return 0;
                }

                function getAttacker(damaged) {
                    let attackers = enemy.filter(tmp => {
                        let damages = new Damages(items);
                        let dmg = damages.weapons[tmp.weaponIndex];
                        let by = tmp.weaponIndex < 9 ? [dmg[0], dmg[1], dmg[2], dmg[3]] : [dmg[0], dmg[1]];
                        let rule = {
                            one: tmp.dist2 <= 300
                            , two: by.includes(damaged)
                            , three: tmp.attacked
                        }
                        return rule.one && rule.two && rule.three;
                    });
                    return attackers;
                }

                function healer() {
                    for (let i = 0; i < healthBased(); i++) {
                        place(0, getAttackDir());
                    }
                }

                function predictHeal(random) {
                    for (let Preidict in random) {
                        place(0, getAttackDir());
                    }
                }

                function antiSyncHealing(timearg) {
                    my.antiSync = true;
                    let healAnti = setInterval(() => {
                        if (player.shameCount < 5) {
                            place(0, getAttackDir());
                        }
                    }, 25);
                    setTimeout(() => {
                        clearInterval(healAnti);
                        setTimeout(() => {
                            my.antiSync = false;
                        }, game.tickRate);
                    }, game.tickRate);
                }

                function predictHeal1() {}

                function antiSyncHealing1(timearg) {
                    my.antiSync = true;
                    let healAnti = setInterval(() => {
                        if (player.shameCount < 0) {
                            place(0, getAttackDir());
                        }
                    }, 75);
                    setTimeout(() => {
                        clearInterval(healAnti);
                        setTimeout(() => {
                            my.antiSync = false;
                        }, game.tickRate);
                    }, game.tickRate);
                }

                function applCxC(value) {
                    if (player.health == 100) {
                        return 0;
                    }
                    if (player.skinIndex != 45 && player.skinIndex != 56) {
                        return Math.ceil(value / items.list[player.items[0]].healing);
                    }
                    return 0;
                }

                function calcDmg(value) {
                    return value * player.skinIndex == 6 ? 0.75 : 1;
                }

                function biomeGear(mover, returns) {
                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                        if (returns) return 31;
                        buyEquip(31, 0);
                    } else {
                        if (player.y2 <= config.snowBiomeTop) {
                            if (returns) return mover && player.moveDir == undefined ? 6 : 15;
                            buyEquip(mover && player.moveDir == undefined ? 6 : 15, 0);
                        } else {
                            if (returns) return mover && player.moveDir == undefined ? 6 : 12;
                            buyEquip(mover && player.moveDir == undefined ? 6 : 12, 0);
                        }
                    }
                    if (returns) return 0;
                }
                let advHeal = [];

                class Traps {
                    constructor(UTILS, items) {
                        this.dist = 0;
                        this.aim = 0;
                        this.inTrap = false;
                        this.replaced = false;
                        this.antiTrapped = false;
                        this.info = {};
                        this.notFast = function () {
                            return player.weapons[1] == 10 && ((this.info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
                        }
                        this.testCanPlace = function (id, first = -(Math.PI / 2), repeat = (Math.PI / 2), plus = (Math.PI / 18), radian, replacer, yaboi) {
                            let item = items.list[player.items[id]];
                            let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                            let counts = {
                                attempts: 0
                                , placed: 0
                            };
                            let tmpObjects = [];
                            gameObjects.forEach((p) => {
                                tmpObjects.push({
                                    x: p.x
                                    , y: p.y
                                    , active: p.active
                                    , blocker: p.blocker
                                    , scale: p.scale
                                    , isItem: p.isItem
                                    , type: p.type
                                    , colDiv: p.colDiv
                                    , getScale: function (sM, ig) {
                                        sM = sM || 1;
                                        return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4) ?
                                                             1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                                    }
                                    , });
                            });
                            for (let i = first; i < repeat; i += plus) {
                                counts.attempts++;
                                let relAim = radian + i;
                                let tmpX = player.x2 + tmpS * Math.cos(relAim);
                                let tmpY = player.y2 + tmpS * Math.sin(relAim);
                                let cantPlace = tmpObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                if (cantPlace) continue;
                                if (item.id != 18 && tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                if ((!replacer && yaboi) || useWasd) {
                                    if (useWasd ? false : yaboi.inTrap) {
                                        if (UTILS.getAngleDist(near.aim2 + Math.PI, relAim + Math.PI) <= Math.PI) {
                                            place(2, relAim, 1);
                                        } else {
                                            player.items[4] == 15 && place(4, relAim, 1);
                                        }
                                    } else {
                                        if (UTILS.getAngleDist(near.aim2, relAim) <= config.gatherAngle / 1.5) {
                                            place(2, relAim, 1);
                                        } else {
                                            player.items[4] == 15 && place(4, relAim, 1);
                                        }
                                    }
                                } else {
                                    place(id, relAim, 1);
                                }
                                tmpObjects.push({
                                    x: tmpX
                                    , y: tmpY
                                    , active: true
                                    , blocker: item.blocker
                                    , scale: item.scale
                                    , isItem: true
                                    , type: null
                                    , colDiv: item.colDiv
                                    , getScale: function () {
                                        return this.scale;
                                    }
                                    , });
                                if (UTILS.getAngleDist(near.aim2, relAim) <= 1) {
                                    counts.placed++;
                                }
                            }
                            if (counts.placed > 0 && replacer && item.dmg) {
                                if (near.dist2 <= items.weapons[player.weapons[0]].range + (player.scale * 1.8) && configs.spikeTick) {
                                    instaC.canSpikeTick = true;
                                }
                            }
                        };
                        this.checkSpikeTick = function () {
                            if (![3, 4, 5].includes(near.primaryIndex)) return false;
                            if ((my.autoPush) ? false : near.primaryIndex == undefined ? true : (near.reloads[near.primaryIndex] > game.tickRate)) return false;
                            if (near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                let item = items.list[9];
                                let tmpS = near.scale + item.scale + (item.placeOffset || 0);
                                let danger = 0;
                                let counts = {
                                    attempts: 0
                                    , block: `unblocked`
                                };
                                for (let i = -1; i <= 1; i += 1 / 10) {
                                    counts.attempts++;
                                    let relAim = UTILS.getDirect(player, near, 2, 2) + i;
                                    let tmpX = near.x2 + tmpS * Math.cos(relAim);
                                    let tmpY = near.y2 + tmpS * Math.sin(relAim);
                                    let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                    if (cantPlace) continue;
                                    if (tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                    danger++;
                                    counts.block = `blocked`;
                                    break;
                                }
                                if (danger) {
                                    my.anti0Tick = 1;
                                    player.chat.message = "";
                                    return true;
                                }
                            }
                            return false;
                        }
                        this.protect = function (aim) {
                            if (!configs.antiTrap) return;
                            if (player.items[4]) {
                                this.testCanPlace(4, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), aim + Math.PI);
                                this.antiTrapped = true;
                            }
                        };
                        this.autoPlace = function () {
                            if (enemy.length && configs.autoPlace && !instaC.ticking) {
                                if (game.tick % (Math.max(1, parseInt(getEl("autoPlaceTick")
                                                                      .value)) || 1) === 0) {
                                    if (gameObjects.length) {
                                        let near2 = {
                                            inTrap: true
                                            , };
                                        let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5))
                                        .sort(function (a, b) {
                                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                        })[0];
                                        if (nearTrap) {
                                            near2.inTrap = true;
                                        } else {
                                            near2.inTrap = true;
                                        }
                                        if ((near.dist2 <= 375)) {
                                            if (near.dist2 <= 200) {
                                                this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, 0, {
                                                    inTrap: near2.inTrap
                                                });
                                            } else {
                                                player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                            }
                                        }
                                    } else {
                                        if ((near.dist2 <= 1000)) {
                                            player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        }
                                    }
                                }
                            }
                        };
                        this.replacer = function (findObj) {
                            if (!findObj || !configs.autoReplace) return;
                            if (!inGame) return;
                            if (this.antiTrapped) return;
                            game.tickBase(() => {
                                let objAim = UTILS.getDirect(findObj, player, 0, 2);
                                let objDst = UTILS.getDist(findObj, player, 0, 2);
                                if (getEl("weaponGrind")
                                    .checked && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;
                                if (objDst <= 400 && near.dist2 <= 400) {
                                    let danger = this.checkSpikeTick();
                                    if (!danger && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                        this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    } else {
                                        player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                    }
                                    this.replaced = true;
                                }
                            }, 1);
                        };
                    }
                };

                function calculatePerfectAngle(x1, y1, x2, y2) {
                    return Math.atan2(y2 - y1, x2 - x1);
                }

                function isObjectBroken(object) {
                    let healthThreshold = 20;
                    return object.health < healthThreshold;
                }

                class Instakill {
                    constructor() {
                        this.wait = false;
                        this.can = false;
                        this.isTrue = false;
                        this.nobull = false;
                        this.ticking = false;
                        this.canSpikeTick = false;
                        this.startTick = false;
                        this.readyTick = false;
                        this.canCounter = false;
                        this.revTick = false;
                        this.syncHit = false;
                        this.changeType = function (aee) {
                            this.wait = false;
                            this.isTrue = true;
                            my.autoAim = true;
                            let aef = [aee];
                            let aeg = near.backupNobull;
                            near.backupNobull = false;
                            if (aee == "rev") {
                                selectWeapon(player.weapons[1]);
                                buyEquip(53, 0);
                                sendAutoGather();
                                setTimeout(() => {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(7, 0);
                                    setTimeout(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 225);
                                }, 100);
                            } else if (aee == "nobull") {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                sendAutoGather();
                                setTimeout(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(player.reloads[53] == 0 ? 53 : 6, 0);
                                    setTimeout(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 255);
                                }, 105);
                            } else if (aee == "normal") {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                sendAutoGather();
                                setTimeout(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(player.reloads[53] == 0 ? 53 : 6, 0);
                                    setTimeout(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 170);
                                }, 80);
                            } else {
                                setTimeout(() => {
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 50);
                            }
                        };
                        this.spikeTickType = function () {
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(16, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                if (player.reloads[53] == 0) {
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(53, 0);
                                    buyEquip(16, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                } else {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }
                            }, 1);
                        };
                        this.counterType = function () {
                            if (!configs.counterInsta) {
                                return;
                            }
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(16, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                if (player.reloads[53] == 0) {
                                    buyEquip(53, 0);
                                    buyEquip(16, 1);
                                    if ([9, 12, 13, 15].includes(player.weapons[1]) && player.reloads[player.weapons[1]] == 0) {
                                        selectWeapon(player.weapons[1]);
                                    }
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                } else {
                                    if ([9, 12, 13, 15].includes(player.weapons[1]) && player.reloads[player.weapons[1]] == 0) {
                                        selectWeapon(player.weapons[1]);
                                    }
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                    }, 1);
                                }
                            }, 1);
                        };
                        this.rangeType = function (aeh) {
                            this.isTrue = true;
                            my.autoAim = true;
                            if (aeh == "ageInsta") {
                                my.ageInsta = false;
                                if (player.items[5] == 18) {
                                    place(5, near.aim2);
                                }
                                packet("9", undefined, 1);
                                buyEquip(22, 0);
                                buyEquip(16, 1);
                                game.tickBase(() => {
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(53, 0);
                                    buyEquip(16, 1);
                                    sendAutoGather();
                                    game.tickBase(() => {
                                        sendUpgrade(12);
                                        selectWeapon(player.weapons[1]);
                                        buyEquip(53, 0);
                                        buyEquip(16, 1);
                                        game.tickBase(() => {
                                            sendUpgrade(15);
                                            selectWeapon(player.weapons[1]);
                                            buyEquip(53, 0);
                                            buyEquip(16, 1);
                                            game.tickBase(() => {
                                                sendAutoGather();
                                                this.isTrue = false;
                                                my.autoAim = false;
                                            }, 1);
                                        }, 1);
                                    }, 1);
                                }, 1);
                            } else {
                                selectWeapon(player.weapons[1]);
                                if (player.reloads[53] == 0 && near.dist2 <= 700 && near.skinIndex != 22) {
                                    buyEquip(53, 0);
                                } else {
                                    buyEquip(20, 0);
                                }
                                buyEquip(11, 1);
                                sendAutoGather();
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            }
                        };
                        this.oneTickType = function () {
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            packet('a', near.aim2, 1);
                            if (player.weapons[1] == 15) {
                                my.revAim = true;
                                sendAutoGather();
                            }
                            game.tickBase(() => {
                                let trap1 = gameObjects
                                .filter(e => e.trap && e.active)
                                .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                .find(trap => {
                                    let trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                    return trap !== player && (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) && trapDist <= 30;
                                });
                                my.revAim = false;
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                packet('a', near.aim2, 1);
                                if (player.weapons[1] != 15) {
                                    sendAutoGather();
                                }
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    packet('a', undefined, 1);
                                }, 1);
                            }, 1);
                        };
                        this.threeOneTickType = function () {
                            this.isTrue = true;
                            my.autoAim = true;
                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                            biomeGear();
                            buyEquip(11, 1);
                            packet('a', near.aim2, 1);
                            game.tickBase(() => {
                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                buyEquip(53, 0);
                                buyEquip(11, 1);
                                packet('a', near.aim2, 1);
                                game.tickBase(() => {
                                    let trap1 = gameObjects
                                    .filter(e => e.trap && e.active)
                                    .sort((a, b) => UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2))
                                    .find(trap => {
                                        let trapDist = Math.hypot(trap.y - near.y2, trap.x - near.x2);
                                        return trap !== player && (player.sid === trap.owner.sid || findAllianceBySid(trap.owner.sid)) && trapDist <= 30;
                                    });
                                    if ([6, 22].includes(near.skinIndex) && trap1) io.send();
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(7, 0);
                                    buyEquip(19, 1);
                                    sendAutoGather();
                                    packet('a', near.aim2, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                        packet('a', undefined, 1);
                                    }, 1);
                                }, 1);
                            }, 1);
                        };
                        this.kmTickType = function () {
                            this.isTrue = true;
                            my.autoAim = true;
                            my.revAim = true;
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(11, 1);
                            sendAutoGather();
                            packet('a', near.aim2, 1);
                            game.tickBase(() => {
                                my.revAim = false;
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(19, 1);
                                packet('a', near.aim2, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    packet('a', undefined, 1);
                                }, 1);
                            }, 1);
                        };
                        this.boostTickType = function () {
                            this.isTrue = true;
                            my.autoAim = true;
                            biomeGear();
                            buyEquip(11, 1);
                            packet('a', near.aim2, 1);
                            game.tickBase(() => {
                                if (player.weapons[1] == 15) {
                                    my.revAim = true;
                                }
                                selectWeapon(player.weapons[[9, 12, 13, 15].includes(player.weapons[1]) ? 1 : 0]);
                                buyEquip(53, 0);
                                buyEquip(11, 1);
                                if ([9, 12, 13, 15].includes(player.weapons[1])) {
                                    sendAutoGather();
                                }
                                packet('a', near.aim2, 1);
                                place(4, near.aim2);
                                game.tickBase(() => {
                                    my.revAim = false;
                                    selectWeapon(player.weapons[0]);
                                    buyEquip(7, 0);
                                    buyEquip(19, 1);
                                    if (![9, 12, 13, 15].includes(player.weapons[1])) {
                                        sendAutoGather();
                                    }
                                    packet('a', near.aim2, 1);
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        this.isTrue = false;
                                        my.autoAim = false;
                                        packet('a', undefined, 1);
                                    }, 1);
                                }, 1);
                            }, 1);
                        };
                        this.gotoGoal = function (goto, OT) {
                            let slowDists = (weeeee) => weeeee * config.playerScale;
                            let goal = {
                                a: goto - OT
                                , b: goto + OT
                                , c: goto - slowDists(1)
                                , d: goto + slowDists(1)
                                , e: goto - slowDists(2)
                                , f: goto + slowDists(2)
                                , g: goto - slowDists(4)
                                , h: goto + slowDists(4)
                            };
                            if (enemy.length) {
                                let dst = near.dist2;
                                this.ticking = true;
                                if (dst >= goal.a && dst <= goal.b) {
                                    buyEquip(22, 0);
                                    buyEquip(11, 1);
                                    if (player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0] || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                    }
                                    return {
                                        dir: undefined
                                        , action: 1
                                    };
                                } else {
                                    if (dst < goal.a) {
                                        if (dst >= goal.g) {
                                            if (dst >= goal.e) {
                                                if (dst >= goal.c) {
                                                    buyEquip(40, 0);
                                                    buyEquip(10, 1);
                                                    if (configs.none) {
                                                        player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                                    } else {
                                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                        }
                                                    }
                                                } else {
                                                    buyEquip(6, 0);
                                                    buyEquip(19, 1);
                                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                    }
                                                }
                                            } else {
                                                buyEquip(6, 0);
                                                buyEquip(12, 1);
                                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                }
                                            }
                                        } else {
                                            biomeGear();
                                            buyEquip(11, 1);
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                        return {
                                            dir: near.aim2 + Math.PI
                                            , action: 0
                                        };
                                    } else if (dst > goal.b) {
                                        if (dst <= goal.h) {
                                            if (dst <= goal.f) {
                                                if (dst <= goal.d) {
                                                    buyEquip(40, 0);
                                                    buyEquip(9, 1);
                                                    if (configs.none) {
                                                        player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                                    } else {
                                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                        }
                                                    }
                                                } else {
                                                    buyEquip(6, 0);
                                                    buyEquip(19, 1);
                                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                    }
                                                }
                                            } else {
                                                buyEquip(6, 0);
                                                buyEquip(12, 1);
                                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                }
                                            }
                                        } else {
                                            biomeGear();
                                            buyEquip(11, 1);
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                        return {
                                            dir: near.aim2
                                            , action: 0
                                        };
                                    }
                                    return {
                                        dir: undefined
                                        , action: 0
                                    };
                                }
                            } else {
                                this.ticking = false;
                                return {
                                    dir: undefined
                                    , action: 0
                                };
                            }
                        }

                        this.bowMovement = function () {
                            let moveMent = this.gotoGoal(685, 3);
                            if (moveMent.action) {
                                if (player.reloads[53] == 0 && !this.isTrue) {
                                    this.rangeType("ageInsta");
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }
                        this.tickMovement = function () {
                            let dist = player.weapons[1] == 9 ? 240 : 240;
                            let actionDist = player.weapons[1] == 9 ? 2 : player.weapons[1] == 12 ? 1.5 : player.weapons[1] == 13 ? 1 : player.weapons[1] == 15 ? 2 : 3;
                            let moveMent = this.gotoGoal(238, 3);
                            if (moveMent.action) {
                                if (player.reloads[53] == 0 && !this.isTrue) {
                                    this.boostTickType();
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }
                        this.kmTickMovement = function () {
                            let moveMent = this.gotoGoal(240, 3);
                            if (moveMent.action) {
                                if (near.skinIndex != 22 && player.reloads[53] == 0 && !this.isTrue && ((game.tick - near.poisonTick) % config.serverUpdateRate == 8)) {
                                    this.kmTickType();
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }
                        this.boostTickMovement = function () {
                            let dist = player.weapons[1] == 9 ? 365 : player.weapons[1] == 12 ? 380 : player.weapons[1] == 13 ? 365 : player.weapons[1] == 15 ? 365 : 370;
                            let actionDist = player.weapons[1] == 9 ? 2 : player.weapons[1] == 12 ? 1.5 : player.weapons[1] == 13 ? 1 : player.weapons[1] == 15 ? 2 : 3;
                            let moveMent = this.gotoGoal(372, 3);
                            if (moveMent.action) {
                                if (player.reloads[53] == 0 && !this.isTrue) {
                                    this.boostTickType();
                                } else {
                                    packet("9", moveMent.dir, 1);
                                }
                            } else {
                                packet("9", moveMent.dir, 1);
                            }
                        }

                        this.perfCheck = function (pl, nr) {
                            if (nr.weaponIndex == 11 && UTILS.getAngleDist(nr.aim2 + Math.PI, nr.d2) <= config.shieldAngle) return false;
                            if (![9, 12, 13, 15].includes(player.weapons[1])) return true;
                            let pjs = {
                                x: nr.x2 + (65 * Math.cos(nr.aim2 + Math.PI))
                                , y: nr.y2 + (65 * Math.sin(nr.aim2 + Math.PI))
                            };
                            if (UTILS.lineInRect(pl.x2 - pl.scale, pl.y2 - pl.scale, pl.x2 + pl.scale, pl.y2 + pl.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                return true;
                            }
                            let finds = ais.filter(tmp => tmp.visible)
                            .find((tmp) => {
                                if (UTILS.lineInRect(tmp.x2 - tmp.scale, tmp.y2 - tmp.scale, tmp.x2 + tmp.scale, tmp.y2 + tmp.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                    return true;
                                }
                            });
                            if (finds) return false;
                            finds = liztobj.filter(tmp => tmp.active)
                                .find((tmp) => {
                                let tmpScale = tmp.getScale();
                                if (!tmp.ignoreCollision && UTILS.lineInRect(tmp.x - tmpScale, tmp.y - tmpScale, tmp.x + tmpScale, tmp.y + tmpScale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                    return true;
                                }
                            });
                            if (finds) return false;
                            return true;
                        }
                    }
                };
                class Autobuy {
                    constructor(buyHat, buyAcc) {
                        this.hat = function () {
                            buyHat.forEach((id) => {
                                let find = findID(hats, id);
                                if (find && !player.skins[id] && player.points >= find.price) packet("c", 1, id, 0);
                            });
                        };
                        this.acc = function () {
                            buyAcc.forEach((id) => {
                                let find = findID(accessories, id);
                                if (find && !player.tails[id] && player.points >= find.price) packet("c", 1, id, 1);
                            });
                        };
                    }
                };

                class Autoupgrade {
                    constructor() {
                        this.sb = function (upg) {
                            upg(3);
                            upg(17);
                            upg(31);
                            upg(23);
                            upg(9);
                            upg(38);
                        };
                        this.kh = function (upg) {
                            upg(3);
                            upg(17);
                            upg(31);
                            upg(23);
                            upg(10);
                            upg(38);
                            upg(4);
                            upg(25);
                        };
                        this.pb = function (upg) {
                            upg(5);
                            upg(17);
                            upg(32);
                            upg(23);
                            upg(9);
                            upg(38);
                        };
                        this.ph = function (upg) {
                            upg(5);
                            upg(17);
                            upg(32);
                            upg(23);
                            upg(10);
                            upg(38);
                            upg(28);
                            upg(25);
                        };
                        this.db = function (upg) {
                            upg(7);
                            upg(17);
                            upg(31);
                            upg(23);
                            upg(9);
                            upg(34);
                        };
                    };
                };

                class Damages {
                    constructor(items) {

                        this.calcDmg = function (dmg, val) {
                            return dmg * val;
                        };
                        this.getAllDamage = function (dmg) {
                            return [this.calcDmg(dmg, 0.75), dmg, this.calcDmg(dmg, 1.125), this.calcDmg(dmg, 1.5)];
                        };
                        this.weapons = [];
                        for (let i = 0; i < items.weapons.length; i++) {
                            let wp = items.weapons[i];
                            let name = wp.name.split(" ")
                            .length <= 1 ? wp.name : (wp.name.split(" ")[0] + "_" + wp.name.split(" ")[1]);
                            this.weapons.push(this.getAllDamage(i > 8 ? wp.Pdmg : wp.dmg));
                            this[name] = this.weapons[i];
                        }
                    }
                }

                let tmpList = [];

                let UTILS = new Utils();
                let items = new Items();
                let objectManager = new Objectmanager(GameObject, gameObjects, UTILS, config);
                let store = new Store();
                let hats = store.hats;
                let accessories = store.accessories;
                let projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, UTILS);
                let aiManager = new AiManager(ais, AI, players, items, null, config, UTILS);
                let textManager = new Textmanager();

                let traps = new Traps(UTILS, items);
                let instaC = new Instakill();
                let autoBuy = new Autobuy([6, 7, 22, 12, 53, 40], [11, 21, 18]);
                let autoUpgrade = new Autoupgrade();

                let lastDeath;
                let minimapData;
                let mapMarker = {};
                let mapPings = [];
                let tmpPing;

                let breakTrackers = [];

                let pathFindTest = 0;
                let grid = [];
                let pathFind = {
                    active: false
                    , grid: 40
                    , scale: 1440
                    , x: 14400
                    , y: 14400
                    , chaseNear: false
                    , array: []
                    , lastX: this.grid / 2
                    , lastY: this.grid / 2
                };

                function sendChat(message) {
                    packet("6", message.slice(0, 30));
                }

                let runAtNextTick = [];

                function checkProjectileHolder(x, y, dir, range, speed, indx, layer, sid) {
                    let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
                    let projOffset = config.playerScale * 2;
                    let projXY = {
                        x: indx == 1 ? x : x - projOffset * Math.cos(dir)
                        , y: indx == 1 ? y : y - projOffset * Math.sin(dir)
                        , };
                    let nearPlayer = players.filter((e) => e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale)
                    .sort(function (a, b) {
                        return UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2);
                    })[0];
                    if (nearPlayer) {
                        if (indx == 1) {
                            nearPlayer.shooting[53] = 1;
                        } else {
                            nearPlayer.shootIndex = weaponIndx;
                            nearPlayer.shooting[1] = 1;
                            antiProj(nearPlayer, dir, range, speed, indx, weaponIndx);
                        }
                    }
                }
                let projectileCount = 0;

                function antiProj(tmpObj, dir, range, speed, index, weaponIndex) {
                    if (!tmpObj.isTeam(player)) {
                        tmpDir = UTILS.getDirect(player, tmpObj, 2, 2);
                        if (UTILS.getAngleDist(tmpDir, dir) <= 0.2) {
                            tmpObj.bowThreat[weaponIndex]++;
                            if (index == 5) {
                                projectileCount++;
                            }
                            setTimeout(() => {
                                tmpObj.bowThreat[weaponIndex]--;
                                if (index == 5) {
                                    projectileCount--;
                                }
                            }, range / speed);
                            if (tmpObj.bowThreat[9] >= 1 && (tmpObj.bowThreat[12] >= 1 || tmpObj.bowThreat[15] >= 1)) {
                                place(1, tmpObj.aim2);
                                my.anti0Tick = 4;
                                sendChat("ranged is homo");
                                if (!my.antiSync) {
                                    antiSyncHealing(4);
                                }
                            } else {
                                if (projectileCount >= 2) {
                                    place(1, tmpObj.aim2);
                                    healer();
                                    sendChat("sync is homo");
                                    buyEquip(22, 0);
                                    buyEquip(21, 1);
                                    my.anti0Tick = 4;
                                    if (!my.antiSync) {
                                        antiSyncHealing(4);
                                    }
                                } else {
                                    if (projectileCount === 1) {
                                        buyEquip(6, 0);
                                        buyEquip(21, 1);
                                    } else {
                                        if (projectileCount >= 2) {
                                            return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
                                            healer();
                                            buyEquip(6, 0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                function showItemInfo(item, isWeapon, isStoreItem) {
                    if (player && item) {
                        UTILS.removeAllChildren(itemInfoHolder);
                        itemInfoHolder.classList.add("visible");
                        UTILS.generateElement({
                            id: "itemInfoName"
                            , text: UTILS.capitalizeFirst(item.name)
                            , parent: itemInfoHolder
                        });
                        UTILS.generateElement({
                            id: "itemInfoDesc"
                            , text: item.desc
                            , parent: itemInfoHolder
                        });
                        if (isStoreItem) {

                        } else if (isWeapon) {
                            UTILS.generateElement({
                                class: "itemInfoReq"
                                , text: !item.type ? "primary" : "secondary"
                                , parent: itemInfoHolder
                            });
                        } else {
                            for (let i = 0; i < item.req.length; i += 2) {
                                UTILS.generateElement({
                                    class: "itemInfoReq"
                                    , html: item.req[i] + "<span class='itemInfoReqVal'> x" + item.req[i + 1] + "</span>"
                                    , parent: itemInfoHolder
                                });
                            }
                            if (item.group.limit) {
                                UTILS.generateElement({
                                    class: "itemInfoLmt"
                                    , text: (player.itemCounts[item.group.id] || 0) + "/" + (config.isSandbox ? 99 : item.group.limit)
                                    , parent: itemInfoHolder
                                });
                            }
                        }
                    } else {
                        itemInfoHolder.classList.remove("visible");
                    }
                }

                window.addEventListener("resize", UTILS.checkTrusted(resize));
                let renderDistanceX;
                let renderDistanceY;

                function resize() {
                    screenWidth = window.innerWidth;
                    screenHeight = window.innerHeight;
                    renderDistanceX = maxScreenWidth;
                    renderDistanceY = maxScreenHeight;

                    let scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
                    gameCanvas.width = screenWidth * pixelDensity;
                    gameCanvas.height = screenHeight * pixelDensity;
                    gameCanvas.style.width = screenWidth + "px";
                    gameCanvas.style.height = screenHeight + "px";
                    mainContext.setTransform(
                        scaleFillNative, 0
                        , 0, scaleFillNative
                        , (screenWidth * pixelDensity - (maxScreenWidth * scaleFillNative)) / 2
                        , (screenHeight * pixelDensity - (maxScreenHeight * scaleFillNative)) / 2
                    );
                }
                resize();

                let usingTouch;
                let mals = document.getElementById('touch-controls-fullscreen');
                mals.style.display = 'block';
                mals.addEventListener("mousemove", gameInput, false);

                function gameInput(e) {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
                let clicks = {
                    left: false
                    , middle: false
                    , right: false
                    , };
                let clicked = {
                    g: false
                }
                mals.addEventListener("mousedown", mouseDown, false);

                function mouseDown(e) {
                    if (attackState != 1) {
                        attackState = 1;
                        if (e.button == 0) {
                            clicks.left = true;
                        } else if (e.button == 2) {
                            clicks.right = true;
                        }
                    }
                }
                mals.addEventListener("mouseup", UTILS.checkTrusted(mouseUp));

                function mouseUp(e) {
                    if (attackState != 0) {
                        attackState = 0;
                        if (e.button == 0) {
                            clicks.left = false;
                        } else if (e.button == 1) {
                            clicks.middle = false;
                        } else if (e.button == 2) {
                            clicks.right = false;
                        }
                    }
                }

                function getMoveDir() {
                    let dx = 0;
                    let dy = 0;
                    for (let key in moveKeys) {
                        let tmpDir = moveKeys[key];
                        dx += !!keys[key] * tmpDir[0];
                        dy += !!keys[key] * tmpDir[1];
                    }
                    return dx == 0 && dy == 0 ? undefined : Math.atan2(dy, dx);
                }

                function getSafeDir() {
                    if (!player) {
                        return 0;
                    }
                    if (!player.lockDir) {
                        lastDir = Math.atan2(mouseY - (screenHeight / 2), mouseX - (screenWidth / 2));
                    }
                    return lastDir || 0;
                }
                let plusDir = 0;
                let lastSpin = Date.now();

                function getAttackDir(debug) {
                    if (debug) {
                        if (!player)
                            return "0";
                        if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= 320 && !traps.inTrap)) && near && near.dist2 <= 320 && player.reloads[player.weapons[0]] == 0))
                            lastDir = getEl("weaponGrind")
                                .checked ? "getSafeDir()" : enemy.length ? my.revAim ? "(near.aim2 + Math.PI)" : "near.aim2" : "getSafeDir()";
                        else
                            if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = "getSafeDir()";
                        else
                            if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = "traps.aim";
                        else
                            if (!player.lockDir) {
                                if (configs.noDir) return "undefined";
                                lastDir = "getSafeDir()";
                            }
                        return lastDir;
                    } else {
                        if (!player)
                            return 0;
                        if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= 320 && !traps.inTrap)) && near && near.dist2 <= 320 && player.reloads[player.weapons[0]] == 0))
                            lastDir = getEl("weaponGrind")
                                .checked ? getSafeDir() : enemy.length ? my.revAim ? (near.aim2 + Math.PI) : near.aim2 : getSafeDir();
                        else
                            if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = getSafeDir();
                        else
                            if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                                lastDir = traps.aim;
                        else
                            if (!player.lockDir) {
                                if (configs.noDir) return undefined;
                                lastDir = getSafeDir();
                            }
                        return lastDir || 0;
                    }
                }

                function getVisualDir() {
                    if (!player) {
                        return 0;
                    }
                    lastDir = getSafeDir();
                    return lastDir || 0;
                }

                function keysActive() {
                    return (allianceMenu.style.display != "block" && chatHolder.style.display != "block" && !isMenu);
                }

                function keyDown(event) {
                    let keyNum = event.which || event.keyCode || 0;
                    if (player && player.alive && keysActive()) {
                        if (!keys[keyNum]) {
                            keys[keyNum] = 1;
                            macro[event.key] = 1;
                            if (keyNum == 69) {
                                sendAutoGather();
                            } else if (keyNum == 67) {
                                updateMapMarker();
                            } else if (keyNum == 71) {
                                clicked.g = !clicked.g
                            } else if (player.weapons[keyNum - 49] != undefined) {
                                player.weaponCode = player.weapons[keyNum - 49];
                            } else if (moveKeys[keyNum]) {
                                sendMoveDir();
                            } else if (event.key == "m") {
                                mills.placeSpawnPads = !mills.placeSpawnPads;
                            } else if (event.key == "z") {
                                mills.place = !mills.place;
                            } else if (event.key == "Z") {
                                typeof window.debug == "function" && window.debug();
                            } else if (keyNum == 32) {
                                packet("F", 1, getSafeDir(), 1);
                                packet("F", 0, getSafeDir(), 1);
                            }
                        }
                    }
                }
                addEventListener("keydown", UTILS.checkTrusted(keyDown));

                function keyUp(event) {
                    if (player && player.alive) {
                        let keyNum = event.which || event.keyCode || 0;
                        if (keysActive()) {
                            if (keys[keyNum]) {
                                keys[keyNum] = 0;
                                macro[event.key] = 0;
                                if (moveKeys[keyNum]) {
                                    sendMoveDir();
                                }
                            }
                        }
                    }
                }
                window.addEventListener("keyup", UTILS.checkTrusted(keyUp));

                function sendMoveDir() {
                    let newMoveDir = getMoveDir();
                    if (lastMoveDir == undefined || newMoveDir == undefined || Math.abs(newMoveDir - lastMoveDir) > 0.3) {
                        if (!my.autoPush) {
                            packet("9", newMoveDir, 1);
                        }
                        lastMoveDir = newMoveDir;
                    }
                }

                function bindEvents() {}
                bindEvents();

                function chechPathColl(tmp) {
                    return ((player.scale + tmp.getScale()) / (player.maxSpeed * items.weapons[player.weaponIndex].spdMult)) + (tmp.dmg && !tmp.isTeamObject(player) ? 35 : 0);
                    return tmp.colDiv == 0.5 ? (tmp.scale * tmp.colDiv) :
                        !tmp.isTeamObject(player) && tmp.dmg ? (tmp.scale + player.scale) :
                    tmp.isTeamObject(player) && tmp.trap ? 0 : tmp.scale;
                }

                function checkObject() {
                    let checkColl = gameObjects.filter(tmp => player.canSee(tmp) && tmp.active);
                    for (let y = 0; y < pathFind.grid; y++) {
                        grid[y] = [];
                        for (let x = 0; x < pathFind.grid; x++) {
                            let tmpXY = {
                                x: (player.x2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * x)
                                , y: (player.y2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * y)
                            }
                            if (UTILS.getDist(pathFind.chaseNear ? near : pathFind, tmpXY, pathFind.chaseNear ? 2 : 0, 0) <= (pathFind.chaseNear ? 35 : 60)) {
                                pathFind.lastX = x;
                                pathFind.lastY = y;
                                grid[y][x] = 0;
                                continue;
                            }
                            let find = checkColl.find(tmp => UTILS.getDist(tmp, tmpXY, 0, 0) <= chechPathColl(tmp));
                            if (find) {
                                if (find.trap) {
                                    grid[y][x] = 0;
                                    continue;
                                }
                                grid[y][x] = 1;
                            } else {
                                grid[y][x] = 0;
                            }
                        }
                    }
                }

                function autoPush() {
                    let nearTrap = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= near.scale + tmp.getScale() + 5)
                    .sort(function (a, b) {
                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                    })[0];
                    if (nearTrap) {
                        let spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, nearTrap, 0, 0) <= near.scale + nearTrap.scale + tmp.scale).sort(function (a, b) {
                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                        })[0];
                        if (spike) {
                            let pos = {
                                x: spike.x + Math.cos(UTILS.getDirect(near, spike, 2, 0)) * 250
                                , y: spike.y + Math.sin(UTILS.getDirect(near, spike, 2, 0)) * 250
                                , x2: spike.x + (UTILS.getDist(near, spike, 2, 0) + player.scale) * Math.cos(UTILS.getDirect(near, spike, 2, 0))
                                , y2: spike.y + (UTILS.getDist(near, spike, 2, 0) + player.scale) * Math.sin(UTILS.getDirect(near, spike, 2, 0))
                            };
                            let finds = gameObjects.filter(tmp => tmp.active)
                            .find(tmp => {
                                let tmpScale = tmp.getScale();
                                if (!tmp.ignoreCollision && UTILS.lineInRect(tmp.x - tmpScale, tmp.y - tmpScale, tmp.x + tmpScale, tmp.y + tmpScale, player.x2, player.y2, pos.x2, pos.y2)) {
                                    return true;
                                }
                            });
                            if (finds) {
                                if (my.autoPush) {
                                    my.autoPush = false;
                                    packet("9", lastMoveDir || undefined, 1);
                                }
                            } else {
                                my.autoPush = true;
                                my.pushData = {
                                    x: spike.x
                                    , y: spike.y
                                    , x2: pos.x2
                                    , y2: pos.y2
                                };
                                let scale = player.scale / 10;
                                if (UTILS.lineInRect(player.x2 - scale, player.y2 - scale, player.x2 + scale, player.y2 + scale, near.x2, near.y2, pos.x, pos.y)) {
                                    packet("9", near.aim2, 1);
                                } else {
                                    packet("9", UTILS.getDirect(pos, player, 2, 2), 1);
                                }
                            }
                        } else if (my.autoPush) {
                            my.autoPush = false;
                            packet("9", lastMoveDir || undefined, 1);
                        }
                    } else if (my.autoPush) {
                        my.autoPush = false;
                        packet("9", lastMoveDir || undefined, 1);
                    }
                }

                function addDeadPlayer(tmpObj) {
                    deadPlayers.push(new DeadPlayer(tmpObj.x, tmpObj.y, tmpObj.dir, tmpObj.buildIndex, tmpObj.weaponIndex, tmpObj.weaponVariant, tmpObj.skinColor, tmpObj.scale, tmpObj.name));
                }

                function setInitData(data) {
                    alliances = data.teams;
                }

                function setupGame(yourSID) {
                    keys = {};
                    macro = {};
                    playerSID = yourSID;
                    attackState = 0;
                    inGame = true;
                    packet("F", 0, getAttackDir(), 1);
                    my.ageInsta = true;
                    if (firstSetup) {
                        firstSetup = false;
                        gameObjects.length = 0;
                        liztobj.length = 0;
                    }
                }

                let messageElement = document.createElement('div');
                messageElement.id = 'playerMessage';
                document.body.appendChild(messageElement);

                function showMessage(text) {
                    messageElement.textContent = text;
                    messageElement.style.display = 'block';
                }

                function addPlayer(data, isYou) {
                    let tmpPlayer = findPlayerByID(data[0]);
                    if (!tmpPlayer) {
                        tmpPlayer = new Player(data[0], data[1], config, UTILS, projectileManager
                                               , objectManager, players, ais, items, hats, accessories);
                        players.push(tmpPlayer);
                    }
                    tmpPlayer.spawn(isYou ? true : null);
                    tmpPlayer.visible = false;
                    tmpPlayer.oldPos = {
                        x2: undefined
                        , y2: undefined
                    };
                    tmpPlayer.x2 = undefined;
                    tmpPlayer.y2 = undefined;
                    tmpPlayer.x3 = undefined;
                    tmpPlayer.y3 = undefined;
                    tmpPlayer.setData(data);
                    if (isYou) {
                        if (!player) {
                            window.prepareUI(tmpPlayer);
                        }
                        player = tmpPlayer;
                        camX = player.x;
                        camY = player.y;
                        my.lastDir = 0;
                        updateItems();
                        updateAge();
                        if (player.skins[7]) {
                            my.reSync = true;
                        }
                    }
                }

                function removePlayer(id) {
                    for (let i = 0; i < players.length; i++) {
                        if (players[i].id == id) {
                            showMessage(`${players[i].name} left the game.`);
                            players.splice(i, 1);
                            break;
                        }
                    }
                }

                function updateHealth(sid, value) {
                    tmpObj = findPlayerBySID(sid);
                    if (tmpObj) {
                        tmpObj.oldHealth = tmpObj.health;
                        tmpObj.health = value;
                        tmpObj.judgeShame();
                        if (tmpObj.oldHealth > tmpObj.health) {
                            tmpObj.damaged = tmpObj.oldHealth - tmpObj.health;
                            advHeal.push([sid, value, tmpObj.damaged]);
                        }
                    }
                }

                function killPlayer() {
                    inGame = false;
                    lastDeath = {
                        x: player.x
                        , y: player.y
                        , };
                    if (configs.autoRespawn) {
                        getEl("diedText")
                            .style.display = "none";
                        packet("M", {
                            name: lastsp[0]
                            , moofoll: lastsp[1]
                            , skin: lastsp[2]
                        });
                    }
                }

                function updateItemCounts(index, value) {
                    if (player) {
                        player.itemCounts[index] = value;
                    }
                }

                function updateAge(xp, mxp, age) {
                    if (xp != undefined) {
                        player.XP = xp;
                    }
                    if (mxp != undefined) {
                        player.maxXP = mxp;
                    }
                    if (age != undefined) {
                        player.age = age;
                    }
                }

                function updateUpgrades(points, age) {
                    player.upgradePoints = points;
                    player.upgrAge = age;
                    if (points > 0) {
                        tmpList.length = 0;
                        UTILS.removeAllChildren(upgradeHolder);
                        for (let i = 0; i < items.weapons.length; ++i) {
                            if (items.weapons[i].age == age && (items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                                let e = UTILS.generateElement({
                                    id: "upgradeItem" + i
                                    , class: "actionBarItem"
                                    , onmouseout: function () {
                                        showItemInfo();
                                    }
                                    , parent: upgradeHolder
                                });
                                e.style.backgroundImage = getEl("actionBarItem" + i)
                                    .style.backgroundImage;
                                tmpList.push(i);
                            }
                        }
                        for (let i = 0; i < items.list.length; ++i) {
                            if (items.list[i].age == age && (items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                                let tmpI = (items.weapons.length + i);
                                let e = UTILS.generateElement({
                                    id: "upgradeItem" + tmpI
                                    , class: "actionBarItem"
                                    , onmouseout: function () {
                                        showItemInfo();
                                    }
                                    , parent: upgradeHolder
                                });
                                e.style.backgroundImage = getEl("actionBarItem" + tmpI)
                                    .style.backgroundImage;
                                tmpList.push(tmpI);
                            }
                        }
                        for (let i = 0; i < tmpList.length; i++) {
                            (function (i) {
                                let tmpItem = getEl('upgradeItem' + i);
                                tmpItem.onclick = UTILS.checkTrusted(function () {
                                    packet("H", i);
                                });
                                UTILS.hookTouchEvents(tmpItem);
                            })(tmpList[i]);
                        }
                        if (tmpList.length) {
                            upgradeHolder.style.display = "block";
                            upgradeCounter.style.display = "block";
                            upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
                        } else {
                            upgradeHolder.style.display = "none";
                            upgradeCounter.style.display = "none";
                            showItemInfo();
                        }
                    } else {
                        upgradeHolder.style.display = "none";
                        upgradeCounter.style.display = "none";
                        showItemInfo();
                    }
                }

                let placedSpikePositions = new Set();
                let placedTrapPositions = new Set();

                function toR(e) {
                    let n = ((e * Math.PI) / 180) % (2 * Math.PI);
                    return n > Math.PI ? Math.PI - n : n;
                }

                function toD(e) {
                    let n = ((e / Math.PI) * 360) % 360;
                    return n >= 360 ? n - 360 : n;
                }

                function killObject(sid) {
                    let findObj = findObjectBySid(sid);
                    objectManager.disableBySid(sid);
                    if (findObj && cdf(player, findObj) < 200 && nears.length > 0 && configs.autoReplace) {
                        let enemy = near;
                        let A = player;
                        let dist = cdf(A, enemy);
                        let dir = caf(A, enemy);
                        let dir2 = caf(player, dir + 180);
                        let ignore = [0, 0];
                        let objAim = Math.atan2(findObj.y - player.y2, findObj.x - player.x2);
                        let objDist = Math.hypot(findObj.y - player.y2, findObj.x - player.x2);
                        let nearTrap = liztobj.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= near.scale + tmp.getScale() + 5);
                        let spike = liztobj.find(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) < 87 && !nearTrap);
                        let placeObj = spike ? 4 : 2;
                        if (objDist <= 200 && near.dist2 <= 168 && placeObj != 4 && !traps.checkSpikeTick()) {
                            instaC.canSpikeTick = true;
                            instaC.syncHit = true;
                        }
                        if (dist < 200) {
                            for (let i = 0; i < Math.PI; i += placeObj === 4 || (placeObj === 2 && !traps.checkSpikeTick()) ? toR(items.list[A.items[2]].scale) + 0.6 : Math.PI) {
                                let placed = false;
                                if (!ignore[0]) {
                                    for (let j = 0; j < 0.7 * Math.PI; j += placeObj === 4 || (placeObj === 2 && !traps.checkSpikeTick()) ? 0.9274 : 0.7 * Math.PI) {
                                        place(placeObj, (0.5 * dir || 0.5 * dir2) + i / Math.PI + j);
                                    }
                                    ignore[0] = Math.ceil(items.list[A.items[2]].scale / toD(Math.PI / 12));
                                }
                                placed && (ignore[1] = Math.ceil(items.list[A.items[2]].scale / toD(Math.PI / 12)));
                            }
                            for (let position of placedSpikePositions) {
                                let storedPosition = JSON.parse(position);
                                let distToStoredPosition = Math.hypot(storedPosition[0] - findObj.x, storedPosition[1] - findObj.y);
                                if (distToStoredPosition <= 80) {
                                    placedSpikePositions.delete(position);
                                    break;
                                }
                            }
                        }
                    }
                }

                function potDmg() {
                    if (!player || !gameObjects) return 0;
                    let [playerSpeed, playerXVel, playerYVel, playerDir] = getVelocity(player);
                    let spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player)).sort((a, b) => UTILS.getDist(a, player, 0, 3) - UTILS.getDist(b, player, 0, 3))[0];
                    let ptDmg = 0;

                    if (spike) {
                        let dstSpike = UTILS.getDist(spike, player, 0, 3);
                        if (dstSpike < (player.scale + spike.scale + 50) && myPlayerVelTwr(playerDir, spike, player)) {
                            ptDmg += spike.dmg;
                        }
                    }

                    return ptDmg;
                }

                function myPlayerVelTwr(playerDir, ent, player) {
                    let aTEntity = Math.atan2(ent.y - player.y, ent.x - player.x);
                    let aDiff = Math.abs(aTEntity - playerDir) % (2 * Math.PI);
                    let fThs = Math.PI / 4;

                    return aDiff <= fThs || aDiff >= (2 * Math.PI - fThs);
                }

                function killObjects(sid) {
                    if (player) objectManager.removeAllItems(sid);
                }

                function setTickout(doo, timeout) {
                    if (!ticks.manage[ticks.tick + timeout]) {
                        ticks.manage[ticks.tick + timeout] = [doo];
                    } else {
                        ticks.manage[ticks.tick + timeout].push(doo);
                    }
                }

                function caf(e, t) {
                    return Math.atan2((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
                }

                let found = false;
                let autoQ = false;

                let autos = {
                    insta: {
                        todo: false
                        , wait: false
                        , count: 4
                        , shame: 5
                    }
                    , bull: false
                    , antibull: 0
                    , reloaded: false
                    , stopspin: true
                }

                function getVelocity(user) {
                    let movementDir = caf({
                        x: user.veryOldX
                        , y: user.veryOldY
                    }, user);
                    let speed = cdf({
                        x: user.veryOldX
                        , y: user.veryOldY
                    }, user);
                    let xvel = user.x + (4 * Math.cos(movementDir) * window.pingTime) / 111.1111;
                    let yvel = user.y + (4 * Math.sin(movementDir) * window.pingTime) / 111.1111;
                    return [speed, xvel, yvel, movementDir];
                }

                let getDistance = (x1, y1, x2, y2) => {
                    let dx = x2 - x1;
                    let dy = y2 - y1;
                    return Math.sqrt(dx * dx + dy * dy);
                };

                let getPotentialDamage = (build, user) => {
                    let weapIndex = user.weapons[1] === 10 && !player.reloads[user.weapons[1]] ? 1 : 0;
                    let weap = user.weapons[weapIndex];
                    if (player.reloads[weap]) return 0;
                    let weapon = items.weapons[weap];
                    let inDist = getDistance(build.x, build.y, user.x2, user.y2) <= build.getScale() + weapon.range;
                    return (user.visible && inDist) ? weapon.dmg * (weapon.sDmg || 1) * 3.3 : 0;
                };

                let findPlacementAngle = (player, itemId, build) => {
                    if (!build) return null;
                    let MAX_ANGLE = 2 * Math.PI;
                    let ANGLE_STEP = Math.PI / 360;
                    let item = items.list[player.items[itemId]];
                    let buildingAngle = Math.atan2(build.y - player.y, build.x - player.x);
                    let tmpS = player.scale + (item.scale || 1) + (item.placeOffset || 0);

                    for (let offset = 0; offset < MAX_ANGLE; offset += ANGLE_STEP) {
                        let angles = [(buildingAngle + offset) % MAX_ANGLE, (buildingAngle - offset + MAX_ANGLE) % MAX_ANGLE];
                        for (let angle of angles) {
                            let tmpX = player.x + tmpS * Math.cos(angle);
                            let tmpY = player.y + tmpS * Math.sin(angle);
                            if (objectManager.customCheckItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player, build, liztobj, UTILS, config)) {
                                return angle;
                            }
                        }
                    }
                    return null;
                };

                function calculateDistance(pointA, pointB) {
                    return Math.sqrt(Math.pow((pointA.y - pointB.y), 2) + Math.pow((pointA.x - pointB.x), 2));
                }

                let spikes = {
                    dist: 0
                    , aim: 0
                    , inSpike: false
                    , info: {}
                };

                let dkl = false;
                let itb = false;

                function avoidSpike() {
                    let spike = gameObjects
                    .filter(obj => obj.dmg && obj.active && !obj.isTeamObject(player))
                    .reduce((closest, obj) => {
                        let dist = UTILS.getDist(obj, player, 0, 2);
                        return dist < (closest.dist || Infinity) ? { obj, dist } : closest;
                    }, {}).obj;

                    if (!spike) return;

                    let dstSpike = UTILS.getDist(spike, player, 0, 2);
                    let avSpike = spike.scale + player.scale + 40;

                    if (dstSpike <= avSpike) {
                        if (!itb) {
                            sendChat("avoid spike");
                            itb = true;
                        }
                        packet("9", Math.atan2(player.y - spike.y, player.x - spike.x), 1);
                        dkl = false;
                    } else {
                        if (!dkl) {
                            packet("9", lastMoveDir || undefined, 1);
                            dkl = true;
                            itb = false;
                        }
                    }
                }

                function updatePlayers(data) {

                    avoidSpike();
                    function getAngleDifference(angle1, angle2) {
                        angle1 = angle1 % (2 * Math.PI);
                        angle2 = angle2 % (2 * Math.PI);
                        let diff = Math.abs(angle1 - angle2);
                        if (diff > Math.PI) {
                            diff = (2 * Math.PI) - diff;
                        }
                        return diff;
                    }

                    game.tick++;
                    enemy = [];
                    nears = [];
                    near = [];
                    game.tickSpeed = performance.now() - game.lastTick;
                    game.lastTick = performance.now();
                    players.forEach((tmp) => {
                        tmp.forcePos = !tmp.visible;
                        tmp.visible = false;
                        if ((tmp.timeHealed - tmp.timeDamaged) > 0 && tmp.lastshamecount < tmp.shameCount) {
                            tmp.pinge = (tmp.timeHealed - tmp.timeDamaged);
                        }
                    });
                    for (let i = 0; i < data.length;) {
                        tmpObj = findPlayerBySID(data[i]);
                        if (tmpObj) {
                            tmpObj.t1 = (tmpObj.t2 === undefined) ? game.lastTick : tmpObj.t2;
                            tmpObj.t2 = game.lastTick;
                            tmpObj.veryOldX = tmpObj.x;
                            tmpObj.veryOldY = tmpObj.y;
                            tmpObj.oldPos.x2 = tmpObj.x2;
                            tmpObj.oldPos.y2 = tmpObj.y2;
                            tmpObj.x1 = tmpObj.x;
                            tmpObj.y1 = tmpObj.y;
                            tmpObj.x2 = data[i + 1];
                            tmpObj.y2 = data[i + 2];
                            tmpObj.x3 = tmpObj.x2 + (tmpObj.x2 - tmpObj.oldPos.x2);
                            tmpObj.y3 = tmpObj.y2 + (tmpObj.y2 - tmpObj.oldPos.y2);
                            tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 3] : tmpObj.d2;
                            tmpObj.d2 = data[i + 3];
                            tmpObj.dt = 0;
                            tmpObj.buildIndex = data[i + 4];
                            tmpObj.weaponIndex = data[i + 5];
                            tmpObj.weaponVariant = data[i + 6];
                            tmpObj.team = data[i + 7];
                            tmpObj.isLeader = data[i + 8];
                            tmpObj.oldSkinIndex = tmpObj.skinIndex;
                            tmpObj.oldTailIndex = tmpObj.tailIndex;
                            tmpObj.skinIndex = data[i + 9];
                            tmpObj.tailIndex = data[i + 10];
                            tmpObj.iconIndex = data[i + 11];
                            tmpObj.zIndex = data[i + 12];
                            tmpObj.visible = true;
                            tmpObj.update(game.tickSpeed);
                            tmpObj.dist2 = UTILS.getDist(tmpObj, player, 2, 2);
                            tmpObj.aim2 = UTILS.getDirect(tmpObj, player, 2, 2);
                            tmpObj.dist3 = UTILS.getDist(tmpObj, player, 3, 3);
                            tmpObj.aim3 = UTILS.getDirect(tmpObj, player, 3, 3);
                            tmpObj.damageThreat = 0;
                            if (tmpObj.skinIndex == 45 && tmpObj.shameTimer <= 0) {
                                tmpObj.addShameTimer();
                            }
                            if (tmpObj.oldSkinIndex == 45 && tmpObj.skinIndex != 45) {
                                tmpObj.shameTimer = 0;
                                tmpObj.shameCount = 0;
                                if (tmpObj == player) {
                                    healer();
                                }
                            }

                            if (player.shameCount < 4 && near.dist3 <= 320 && near.reloads[near.primaryIndex] <= game.tickRate * (window.pingTime >= 200 ? 2 : 1)) {
                                autoQ = true;
                                healer();
                            } else {
                                if (autoQ) {
                                    healer();
                                }
                                autoQ = false;
                            }

                            if (tmpObj == player) {
                                if (liztobj.length) {
                                    liztobj.forEach((tmp) => {
                                        tmp.onNear = false;
                                        if (tmp.active) {
                                            if (!tmp.onNear && UTILS.getDist(tmp, tmpObj, 0, 2) <= tmp.scale + items.weapons[tmpObj.weapons[0]].range) {
                                                tmp.onNear = true;
                                            }
                                            if (tmp.isItem && tmp.owner) {
                                                if (!tmp.pps && tmpObj.sid == tmp.owner.sid && UTILS.getDist(tmp, tmpObj, 0, 2) > 700 && !tmp.breakObj && ![13, 14, 20].includes(tmp.id)) {
                                                    tmp.breakObj = true;
                                                    breakObjects.push({
                                                        x: tmp.x
                                                        , y: tmp.y
                                                        , sid: tmp.sid
                                                    });
                                                }
                                            }
                                        }
                                    });

                                    let spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + items.weapons[player.weapons[0]].range || items.weapons[player.weapons[1]].range)).sort(function (a, b) {
                                        return UTILS.getDist(a, player, 0, 5) - UTILS.getDist(b, player, 0, 5);
                                    })[0];

                                    let nearTrap = liztobj.filter(tmp => tmp.trap && tmp.active && UTILS.getDist(tmp, tmpObj, 0, 2) <= (tmpObj.scale + tmp.getScale() + 25) && !tmp.isTeamObject(tmpObj)).sort(function (a, b) {
                                        return UTILS.getDist(a, tmpObj, 0, 2) - UTILS.getDist(b, tmpObj, 0, 2);
                                    })[0];

                                    if (spike) {
                                        traps.dist = UTILS.getDist(spike, tmpObj, 0, 2);
                                        traps.aim = UTILS.getDirect(spike, tmpObj, 0, 2);
                                        traps.inTrap = true;
                                        traps.info = spike;
                                    } else if (nearTrap) {
                                        traps.dist = UTILS.getDist(nearTrap, tmpObj, 0, 2);
                                        traps.aim = UTILS.getDirect(nearTrap, tmpObj, 0, 2);
                                        traps.protect(caf(nearTrap, tmpObj) - Math.PI);
                                        traps.inTrap = true;
                                        traps.info = nearTrap;
                                    } else {
                                        traps.inTrap = false;
                                        traps.info = {};
                                    }
                                } else {
                                    traps.inTrap = false;
                                }
                            }

                            if (tmpObj.weaponIndex < 9) {
                                tmpObj.primaryIndex = tmpObj.weaponIndex;
                                tmpObj.primaryVariant = tmpObj.weaponVariant;
                            } else if (tmpObj.weaponIndex > 8) {
                                tmpObj.secondaryIndex = tmpObj.weaponIndex;
                                tmpObj.secondaryVariant = tmpObj.weaponVariant;
                            }
                        }
                        i += 13;
                    }

                    if (textManager.stack.length) {
                        let stacks = [];
                        let notstacks = [];
                        let num = 0;
                        let num2 = 0;
                        let pos = {
                            x: null
                            , y: null
                        };
                        let pos2 = {
                            x: null
                            , y: null
                        }
                        textManager.stack.forEach((text) => {
                            if (text.value >= 0) {
                                if (num == 0) pos = {
                                    x: text.x
                                    , y: text.y
                                };
                                num += Math.abs(text.value);
                            } else {
                                if (num2 == 0) pos2 = {
                                    x: text.x
                                    , y: text.y
                                };
                                num2 += Math.abs(text.value);
                            }
                        });
                        if (num2 > 0) {
                            textManager.showText(pos2.x, pos2.y, Math.max(45, Math.min(50, num2)), 0.18, 500, num2, "#FF0000");
                        }
                        if (num > 0) {
                            textManager.showText(pos.x, pos.y, Math.max(45, Math.min(50, num)), 0.18, 500, num, "#fff");
                        }
                        textManager.stack = [];
                    }
                    if (runAtNextTick.length) {
                        runAtNextTick.forEach((tmp) => {
                            checkProjectileHolder(...tmp);
                        });
                        runAtNextTick = [];
                    }
                    for (let i = 0; i < data.length;) {
                        tmpObj = findPlayerBySID(data[i]);
                        if (tmpObj) {
                            if (!tmpObj.isTeam(player)) {
                                enemy.push(tmpObj);
                                if (tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + (player.scale * 2)) {
                                    nears.push(tmpObj);
                                }
                            }
                            tmpObj.manageReload();
                            if (tmpObj != player) {
                                tmpObj.addDamageThreat(player);
                            }
                        }
                        i += 13;
                    }
                    if (player && player.alive) {
                        if (enemy.length) {
                            near = enemy.sort(function (tmp1, tmp2) {
                                return tmp1.dist2 - tmp2.dist2;
                            })[0];
                        }
                        if (game.tickQueue[game.tick]) {
                            game.tickQueue[game.tick].forEach((action) => {
                                action();
                            });
                            game.tickQueue[game.tick] = null;
                        }
                        let healTimeout = 140 - window.pingTime;;
                        if (advHeal.length) {
                            advHeal.forEach((updHealth) => {
                                if (window.pingTime < 150) {
                                    let sid = updHealth[0];
                                    let value = updHealth[1];
                                    let totalDamage = 100 - value
                                    let damaged = updHealth[2];
                                    tmpObj = findPlayerBySID(sid);
                                    let bullTicked = false;
                                    if (tmpObj == player) {
                                        if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                                            if (my.reSync) {
                                                my.reSync = false;
                                                tmpObj.setBullTick = true;
                                            }
                                            bullTicked = true;
                                        }
                                        if (inGame) {
                                            let attackers = getAttacker(damaged);
                                            let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                            let includeSpikeDmgs = enemy.length ? !bullTicked && (gearDmgs.includes(damaged) && near.skinIndex == 11) : false;
                                            let dmg = 100 - player.health;
                                            let slowHeal = function (timer, tickbase) {
                                                if (!tickbase && near.primaryIndex == 7 || (player.weapons[0] == 7 && clicks.left) || (near.primaryIndex == 5 && ([17, 15].includes(near.secondaryIndex)))) {
                                                    setTimeout(() => {
                                                        healer();
                                                    }, timer);
                                                } else {
                                                    game.tickBase(() => {
                                                        healer()
                                                    }, 2)
                                                }
                                            }
                                            if (enemy.length) {
                                                if ([0, 7, 8].includes(near.primaryIndex)) {
                                                    if (damaged < 75) {
                                                        slowHeal(healTimeout)
                                                    } else {
                                                        healer()
                                                    }
                                                }
                                                if ([1, 2, 6].includes(near.primaryIndex)) {
                                                    if (damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5) {
                                                        healer()
                                                    } else {
                                                        slowHeal(healTimeout)
                                                    }
                                                }
                                                if (near.primaryIndex == 3) {
                                                    if (near.secondaryIndex == 15) {
                                                        if (near.primaryVariant < 2) {
                                                            if (damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 && game.tick - player.antiTimer > 1) {
                                                                tmpObj.canEmpAnti = true
                                                                tmpObj.antiTimer = game.tick
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        } else {
                                                            if (damaged > 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 && game.tick - player.antiTimer > 1) {
                                                                tmpObj.canEmpAnti = true
                                                                tmpObj.antiTimer = game.tick
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        }
                                                    } else {
                                                        if (damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                            healer()
                                                        } else {
                                                            slowHeal(healTimeout)
                                                        }
                                                    }
                                                }
                                                if (near.primaryIndex == 4) {
                                                    if (near.primaryVariant >= 1) {
                                                        if (damaged >= 10 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                            healer()
                                                        } else {
                                                            slowHeal(healTimeout)
                                                        }
                                                    } else {
                                                        if (damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 3) {
                                                            healer()
                                                        } else {
                                                            slowHeal(healTimeout)
                                                        }
                                                    }
                                                }
                                                if ([undefined, 5].includes(near.primaryIndex)) {
                                                    if (near.secondaryIndex == 10) {
                                                        if (dmg >= (includeSpikeDmgs ? 10 : 20) && tmpObj.damageThreat + dmg >= 80 && tmpObj.shameCount < 6) {
                                                            healer()
                                                        } else {
                                                            slowHeal(healTimeout)
                                                        }
                                                    } else
                                                        if (near.primaryVariant >= 2 || near.primaryVariant == undefined) {
                                                            if (dmg >= (includeSpikeDmgs ? 15 : 20) && tmpObj.damageThreat + dmg >= 50 && tmpObj.shameCount < 6) {
                                                                healer()
                                                            } else {
                                                                slowHeal(healTimeout)
                                                            }
                                                        } else
                                                            if ([undefined || 15].includes(near.secondaryIndex)) {
                                                                if (damaged > (includeSpikeDmgs ? 8 : 20) && player.damageThreat >= 25 && (game.tick - player.antiTimer) > 1) {
                                                                    if (tmpObj.shameCount < 5) {
                                                                        healer()
                                                                    } else {
                                                                        slowHeal(healTimeout)
                                                                    }
                                                                } else {
                                                                    slowHeal(healTimeout)
                                                                }
                                                            } else
                                                                if ([9, 12, 13].includes(near.secondaryIndex)) {
                                                                    if (dmg >= 25 && player.damageThreat + dmg >= 70 && tmpObj.shameCount < 6) {
                                                                        healer()
                                                                    } else {
                                                                        slowHeal(healTimeout)
                                                                    }
                                                                } else {
                                                                    if (damaged > 25 && player.damageThreat + dmg >= 95) {
                                                                        healer()
                                                                    } else {
                                                                        slowHeal(healTimeout)
                                                                    }
                                                                }
                                                }
                                                if (near.primaryIndex == 6) {
                                                    if (near.secondaryIndex == 15) {
                                                        if (damaged >= 25 && tmpObj.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                            healer()
                                                        } else {
                                                            slowHeal(healTimeout)
                                                        }
                                                    } else {
                                                        if (damaged >= 70 && tmpObj.shameCount < 4) {
                                                            healer()
                                                        } else {
                                                            slowHeal(healTimeout)
                                                        }
                                                    }
                                                }
                                                if (damaged >= 30 && near.reloads[near.secondaryIndex] == 0 && near.dist2 <= 150 && player.skinIndex == 11 && player.tailIndex == 21) instaC.canCounter = true
                                            } else {
                                                if (damaged >= 70) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            }
                                        } else {
                                            let dmg = 100 - player.health;
                                            let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                            let includeSpikeDmgs = enemy.length ? !bullTicked && (gearDmgs.includes(damaged) && near.skinIndex == 11) : false;
                                            let slowHeal = function (timer, tickbase) {
                                                if (!tickbase && near.primaryIndex == 7 || (player.weapons[0] == 7 && clicks.left) || (near.primaryIndex == 5 && ([17, 15].includes(near.secondaryIndex)))) {
                                                    setTimeout(() => {
                                                        healer();
                                                    }, timer);
                                                } else {
                                                    game.tickBase(() => {
                                                        healer()
                                                    }, 2)
                                                }
                                            }
                                            if (damaged >= (includeSpikeDmgs ? 8 : 25) && dmg + player.damageThreat >= 80 && (game.tick - player.antiTimer) > 1) {
                                                if (tmpObj.reloads[53] == 0 && tmpObj.reloads[tmpObj.weapons[1]] == 0) {
                                                    tmpObj.canEmpAnti = true;
                                                } else {
                                                    player.soldierAnti = true;
                                                }
                                                tmpObj.antiTimer = game.tick;
                                                let shame = [0, 4, 6, 7, 8].includes(near.primaryIndex) ? 2 : 5;
                                                if (tmpObj.shameCount < shame) {
                                                    healer();
                                                } else {
                                                    if (near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21))) {
                                                        slowHeal(healTimeout)
                                                    } else {
                                                        slowHeal(healTimeout, 1)
                                                    }
                                                }
                                            } else {
                                                if (near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21))) {
                                                    slowHeal(healTimeout)
                                                } else {
                                                    slowHeal(healTimeout, 1)
                                                }
                                            }
                                            if (damaged >= 25 && near.dist2 <= 140 && player.skinIndex == 11 && player.tailIndex == 21) instaC.canCounter = true
                                        }
                                    } else {
                                        if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                                            tmpObj.setPoisonTick = true;
                                        }
                                    }
                                } else {
                                    let [sid, value, damaged] = updHealth;
                                    let totalDamage = 100 - value;
                                    let tmpObj = findPlayerBySID(sid);
                                    let bullTicked = false;

                                    if (tmpObj == player) {
                                        if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                                            if (my.reSync) {
                                                my.reSync = false;
                                                tmpObj.setBullTick = true;
                                                bullTicked = true;
                                            }
                                        }
                                        if (inGame) {
                                            let attackers = getAttacker(damaged);
                                            let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                            let includeSpikeDmgs = enemy.length ? !bullTicked && (gearDmgs.includes(damaged) && near.skinIndex == 11) : false;
                                            let healTimeout = 60;
                                            let dmg = 100 - player.health;
                                            let shameCountThreshold = [2, 5][
                                                [0, 4, 6, 7, 8].includes(near.primaryIndex) ? 0 : 1
                                            ];

                                            let slowHeal = function (timer, tickBase) {
                                                if (!tickBase) setTimeout(() => healer(), timer);
                                                else game.tickBase(() => healer(), 2);
                                            };

                                            if (getEl("healingBeta")
                                                .checked) {
                                                let canHealFast = [0, 7, 8].includes(near.primaryIndex) ? damaged < 75 : [1, 2, 6].includes(near.primaryIndex) ? damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 : [undefined, 5].includes(near.primaryIndex) ? dmg >= (includeSpikeDmgs ? 15 : 20) && tmpObj.damageThreat + dmg >= 50 && tmpObj.shameCount < 6 :
                                                near.primaryIndex == 3 && near.secondaryIndex == 15 ? damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 && game.tick - player.antiTimer > 1 :
                                                near.primaryIndex == 4 ? near.primaryVariant >= 1 ? damaged >= 10 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4 :
                                                damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 3 :
                                                near.primaryIndex == 6 && near.secondaryIndex == 15 ? damaged >= 25 && tmpObj.damageThreat + dmg >= 95 && tmpObj.shameCount < 4 :
                                                damaged >= 25 && player.damageThreat + dmg >= 95;

                                                canHealFast ? healer() : slowHeal(healTimeout);
                                            } else {
                                                let canHealFast = damaged >= (includeSpikeDmgs ? 8 : 25) && dmg + player.damageThreat >= 80 && (game.tick - player.antiTimer) > 1;

                                                if (canHealFast) {
                                                    if (tmpObj.reloads[53] == 0 && tmpObj.reloads[tmpObj.weapons[1]] == 0) tmpObj.canEmpAnti = true;
                                                    else player.soldierAnti = true;
                                                    tmpObj.antiTimer = game.tick;
                                                    if (tmpObj.shameCount < shameCountThreshold) healer();
                                                    else slowHeal(healTimeout, near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21)) ? 0 : 1);
                                                } else {
                                                    slowHeal(healTimeout, near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21)) ? 0 : 1);
                                                }
                                            }
                                        } else {
                                            if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                                                tmpObj.setPoisonTick = true;
                                            }
                                        }
                                    }
                                }
                            });
                            advHeal = [];
                        }
                        players.forEach((tmp) => {
                            if (!tmp.visible && player != tmp) {
                                tmp.reloads = {
                                    0: 0
                                    , 1: 0
                                    , 2: 0
                                    , 3: 0
                                    , 4: 0
                                    , 5: 0
                                    , 6: 0
                                    , 7: 0
                                    , 8: 0
                                    , 9: 0
                                    , 10: 0
                                    , 11: 0
                                    , 12: 0
                                    , 13: 0
                                    , 14: 0
                                    , 15: 0
                                    , 53: 0
                                    , };
                            }
                            if (tmp.setBullTick) {
                                tmp.bullTimer = 0;
                            }
                            if (tmp.setPoisonTick) {
                                tmp.poisonTimer = 0;
                            }
                            tmp.updateTimer();
                        });
                        if (inGame) {
                            if (enemy.length) {
                                if (player.canEmpAnti) {
                                    player.canEmpAnti = false;
                                    if (near.dist2 <= 300 && !my.safePrimary(near) && !my.safeSecondary(near)) {
                                        if (near.reloads[53] == 0) {
                                            player.empAnti = true;
                                            player.soldierAnti = true;
                                        } else {
                                            player.empAnti = true;
                                            player.soldierAnti = true;
                                        }
                                    }
                                }
                                let prehit = gameObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 3) <= (tmp.scale + near.scale))
                                .sort(function (a, b) {
                                    return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                })[0];
                                if (prehit) {
                                    if (near.dist2 <= items.weapons[player.weapons[0]].range + player.scale * 1.8 && configs.predictTick) {
                                        instaC.canSpikeTick = true;
                                        instaC.syncHit = true;
                                        if (configs.revTick && player.weapons[1] == 15 && player.reloads[53] == 0 && instaC.perfCheck(player, near)) {
                                            instaC.revTick = true;
                                        }
                                    }
                                }
                                let antiSpikeTick = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + player.scale))
                                .sort(function (a, b) {
                                    return UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2);
                                })[0];
                                if (antiSpikeTick && !traps.inTrap) {
                                    if (near.dist2 <= items.weapons[5].range + near.scale * 1.8) {
                                        my.anti0Tick = 1;
                                    }
                                }
                            }
                            if ((useWasd ? true : ((player.checkCanInsta(true) >= 220 ? player.checkCanInsta(true) : player.checkCanInsta(false)) >= (player.weapons[1] == 10 ? 95 : 100))) && near.dist2 <= items.weapons[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]].range + near.scale * 1.8 && (instaC.wait || (useWasd && Math.floor(Math.random() * 5) == 0)) && !instaC.isTrue && !my.waitHit && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && (useWasd ? true : (player.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate))) && instaC.perfCheck(player, near)) {
                                if (player.checkCanInsta(true) >= 220) {
                                    instaC.nobull = useWasd ? false : instaC.canSpikeTick ? false : true;
                                } else {
                                    instaC.nobull = false;
                                }
                                instaC.can = true;
                            } else {
                                instaC.can = false;
                            }
                            macro.q && place(0, getAttackDir());
                            macro.f && place(4, getSafeDir());
                            macro.v && place(2, getSafeDir());
                            macro.y && place(5, getSafeDir());
                            macro.h && place(player.getItemType(22), getSafeDir());
                            macro.n && place(3, getSafeDir());
                            if (mills.place && calculateDistance(player, mills) > 95) {
                                let direction = caf({
                                    x: player.veryOldX
                                    , y: player.veryOldY
                                }, player) + Math.PI;

                                let angleOffset = 65 * Math.PI / 180;
                                checkPlace(3, direction - angleOffset);
                                checkPlace(3, direction);
                                checkPlace(3, direction + angleOffset);

                                mills.x = player.x;
                                mills.y = player.y;
                            }

                            if (instaC.can) {
                                instaC.changeType(configs.alwaysRev ? "rev" : "normal");
                            }

                            if (instaC.canCounter) {
                                instaC.canCounter = false;
                                if (player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                                    instaC.counterType();
                                }
                            }
                            if (instaC.canSpikeTick) {
                                instaC.canSpikeTick = false;
                                if (instaC.revTick) {
                                    instaC.revTick = false;
                                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[1]] == 0 && !instaC.isTrue) {
                                        instaC.changeType("rev");
                                    }
                                } else {
                                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                                        instaC.spikeTickType();
                                    }
                                }
                            }
                            if (!clicks.middle && (clicks.left || clicks.right) && !instaC.isTrue) {
                                if ((player.weaponIndex != (clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0])) || player.buildIndex > -1) {
                                    selectWeapon(clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                                }
                                if (player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                                    sendAutoGather();
                                    my.waitHit = 1;
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        my.waitHit = 0;
                                    }, 1);
                                }
                            }
                            if (useWasd && !clicks.left && !clicks.right && !instaC.isTrue && near.dist2 <= (items.weapons[player.weapons[0]].range + near.scale * 1.8) && !traps.inTrap) {
                                if ((player.weaponIndex != player.weapons[0]) || player.buildIndex > -1) {
                                    selectWeapon(player.weapons[0]);
                                }
                                if (player.reloads[player.weapons[0]] == 0 && !my.waitHit) {
                                    sendAutoGather();
                                    my.waitHit = 1;
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        my.waitHit = 0;
                                    }, 1);
                                }
                            }
                            if (traps.inTrap) {
                                if (!clicks.left && !clicks.right && !instaC.isTrue) {
                                    if (player.weaponIndex != (traps.notFast() ? player.weapons[1] : player.weapons[0]) || player.buildIndex > -1) {
                                        selectWeapon(traps.notFast() ? player.weapons[1] : player.weapons[0]);
                                    }
                                    if (player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                                        sendAutoGather();
                                        my.waitHit = 1;
                                        game.tickBase(() => {
                                            sendAutoGather();
                                            my.waitHit = 0;
                                        }, 1);
                                    }
                                }
                            }
                            if (clicked.g && !traps.inTrap) {
                                if (!instaC.isTrue && player.reloads[player.weapons[1]] == 0) {
                                    if (my.ageInsta && player.weapons[0] != 4 && player.weapons[1] == 9 && player.age >= 9 && enemy.length) {
                                        instaC.bowMovement();
                                    } else {
                                        instaC.rangeType();
                                    }
                                }
                            }
                            if (macro.t && !traps.inTrap) {
                                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && (player.weapons[1] == 15 ? (player.reloads[player.weapons[1]] == 0) : true) && (player.weapons[0] == 5 || (player.weapons[0] == 4 && player.weapons[1] == 15))) {
                                    instaC[(player.weapons[0] == 4 && player.weapons[1] == 15) ? "kmTickMovement" : "tickMovement"]();
                                }
                            }
                            if (macro["."] && !traps.inTrap) {
                                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && ([9, 12, 13, 15].includes(player.weapons[1]) ? (player.reloads[player.weapons[1]] == 0) : true)) {
                                    instaC.boostTickMovement();
                                }
                            }
                            if (player.weapons[1] && !clicks.left && !clicks.right && !traps.inTrap && !instaC.isTrue && !(useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8)) {
                                if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                    if (!my.reloaded) {
                                        my.reloaded = true;
                                        let fastSpeed = items.weapons[player.weapons[0]].spdMult < items.weapons[player.weapons[1]].spdMult ? 1 : 0;
                                        if (player.weaponIndex != player.weapons[fastSpeed] || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[fastSpeed]);
                                        }
                                    }
                                } else {
                                    my.reloaded = false;
                                    autos.stopspin = false;
                                    if (player.reloads[player.weapons[0]] > 0) {
                                        if (player.weaponIndex != player.weapons[0] || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[0]);
                                        }
                                    } else if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] > 0) {
                                        if (player.weaponIndex != player.weapons[1] || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[1]);
                                        }
                                        if (!autos.stopspin) {
                                            setTimeout(() => {
                                                autos.stopspin = true;
                                            }, 750);
                                        }
                                    }
                                }
                            }

                            if (!instaC.isTrue && !traps.inTrap && !traps.replaced) {
                                traps.autoPlace();
                            }

                            if (!macro.q && !macro.f && !macro.v && !macro.h && !macro.n) {
                                packet("D", getAttackDir());
                            }

                            let hatChanger = function () {
                                if (my.anti0Tick > 0) {
                                    buyEquip(6, 0);
                                } else {
                                    if (clicks.left || clicks.right) {
                                        if ((player.shameCount >= 2 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                        } else {
                                            if (clicks.left) {
                                                buyEquip(player.reloads[player.weapons[0]] == 0 ? getEl("weaponGrind")
                                                         .checked ? 40 : 7 : player.empAnti ? 22 : player.soldierAnti ? 6 : (getEl("antiBullType")
                                                                                                                             .value == "abreload" && near.antiBull > 0) ? 6 : near.dist2 <= 300 ? (getEl("antiBullType")
                                                        .value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 6 : 6 : biomeGear(1, 1), 0);
                                            } else if (clicks.right) {
                                                buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 22 : player.soldierAnti ? 6 : (getEl("antiBullType")
                                                    .value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 300 ? (getEl("antiBullType")
                                                                                                                           .value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 6 : 6 : biomeGear(1, 1), 0);
                                            }
                                        }

                                    } else if (traps.inTrap) {
                                        if (traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
                                            buyEquip(40, 0);
                                        } else {
                                            if (
                                                ((player.shameCount >= 2 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) &&
                                                ((near && near.dist2 > 140) || !near)
                                            ) {
                                                buyEquip(7, 0);
                                                setTimeout(() => {
                                                    buyEquip(7, 0);
                                                }, 120);
                                            } else {
                                                buyEquip(player.empAnti || near.dist2 > 300 || !enemy.length ? 22 : 6, 0);
                                            }
                                        }
                                    } else {
                                        if (player.empAnti || player.soldierAnti) {
                                            buyEquip(player.empAnti ? 22 : 6, 0);
                                        } else {
                                            if (
                                                ((player.shameCount >= 2 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) &&
                                                ((near && near.dist2 > 140) || !near)
                                            ) {
                                                buyEquip(7, 0);
                                                setTimeout(() => {
                                                    buyEquip(7, 0);
                                                }, 120);
                                            } else {
                                                if (near.dist2 <= 240) {
                                                    buyEquip(
                                                        getEl('antiBullType')
                                                        .value == 'abreload' && near.antiBull > 0 ?
                                                        11 :
                                                        getEl('antiBullType')
                                                        .value == 'abalway' && near.reloads[near.primaryIndex] == 0 ?
                                                        11 :
                                                        11
                                                        , 0
                                                    );
                                                } else {
                                                    biomeGear(1);
                                                }
                                            }
                                        }
                                    }
                                }

                            };

                            let accChanger = function () {
                                if (instaC.can && player.checkCanInsta(true) >= 100) {
                                    buyEquip(21, 1);
                                } else if (clicks.left || clicks.right) {
                                    setTimeout(() => {
                                        buyEquip(21, 1);
                                    }, 0);
                                } else if (near.dist2 <= 300) {
                                    buyEquip(21, 1);
                                } else {
                                    buyEquip(traps.inTrap ? 21 : 11, 1);
                                }
                            };
                            let wasdGears = function () {
                                if (my.anti0Tick > 0) {
                                    buyEquip(6, 0);
                                } else {
                                    if (clicks.left || clicks.right) {
                                        if ((player.shameCount > 2 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                        } else {
                                            if (clicks.left) {
                                                buyEquip(player.reloads[player.weapons[0]] == 0 ? getEl("weaponGrind").checked ? 40 : 7 : 11);
                                            } else if (clicks.right) {
                                                buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 22 : 6, 0);
                                            }
                                        }
                                    } else if (near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap) {
                                        if ((player.shameCount > 2 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                        } else {
                                            buyEquip(player.reloads[player.weapons[0]] == 0 ? 7 : player.empAnti ? 22 : 6, 0);
                                        }
                                    } else if (traps.inTrap) {
                                        if (traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                            buyEquip(40, 0);
                                        } else {
                                            if ((player.shameCount > 2 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                            } else {
                                                buyEquip(player.empAnti ? 22 : 6, 0);
                                            }
                                        }
                                    } else {
                                        if (player.empAnti) {
                                            buyEquip(22, 0);
                                        } else {
                                            if ((player.shameCount > 2 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                                buyEquip(7, 0);
                                            } else {
                                                buyEquip(6, 0);
                                            }
                                        }
                                    }
                                }
                                if (clicks.left || clicks.right) {
                                    if (clicks.left) {
                                        buyEquip(0, 1);
                                    } else if (clicks.right) {
                                        buyEquip(11, 1);
                                    }
                                } else if (near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap) {
                                    buyEquip(0, 1);
                                } else if (traps.inTrap) {
                                    buyEquip(0, 1);
                                } else {
                                    buyEquip(11, 1);
                                }
                            }
                            if (storeMenu.style.display != "block" && !instaC.isTrue && !instaC.ticking) {
                                hatChanger();
                                accChanger();
                            }
                            if (configs.autoPush && enemy.length && !traps.inTrap && !instaC.ticking) {
                                autoPush();
                            } else {
                                if (my.autoPush) {
                                    my.autoPush = false;
                                    packet("9", lastMoveDir || undefined, 1);
                                }
                            }

                            if (instaC.ticking) {
                                instaC.ticking = false;
                            }
                            if (instaC.syncHit) {
                                instaC.syncHit = false;
                            }
                            if (player.empAnti) {
                                player.empAnti = false;
                            }
                            if (player.soldierAnti) {
                                player.soldierAnti = false;
                            }
                            if (my.anti0Tick > 0) {
                                my.anti0Tick--;
                            }
                            if (traps.replaced) {
                                traps.replaced = false;
                            }
                            if (traps.antiTrapped) {
                                traps.antiTrapped = false;
                            }

                            let AutoReplace = () => {
                                let replaceable = [];
                                let playerX = player.x;
                                let playerY = player.y;
                                let gameObjectCount = gameObjects.length;

                                for (let i = 0; i < gameObjectCount; i++) {
                                    let build = gameObjects[i];
                                    if (build.isItem && build.active && build.health > 0) {
                                        let item = items.list[build.id];
                                        let posDist = 35 + item.scale + (item.placeOffset || 0);
                                        let inDistance = cdf(build, player) <= posDist * 2;
                                        if (inDistance) {
                                            let canDeal = 0;
                                            let playersCount = players.length;
                                            for (let j = 0; j < playersCount; j++) {
                                                canDeal += getPotentialDamage(build, players[j]);
                                            }
                                            if (build.health <= canDeal) {
                                                replaceable.push(build);
                                            }
                                        }
                                    }
                                }

                                let findPlacementAngle = (player, itemId, build) => {
                                    if (!build) return null;
                                    let MAX_ANGLE = 2 * Math.PI;
                                    let ANGLE_STEP = Math.PI / 360;
                                    let item = items.list[player.items[itemId]];
                                    let buildingAngle = Math.atan2(build.y - player.y, build.x - player.x);
                                    let tmpS = player.scale + (item.scale || 1) + (item.placeOffset || 0);

                                    for (let offset = 0; offset < MAX_ANGLE; offset += ANGLE_STEP) {
                                        let angles = [(buildingAngle + offset) % MAX_ANGLE, (buildingAngle - offset + MAX_ANGLE) % MAX_ANGLE];
                                        for (let angle of angles) {
                                            return angle;
                                        }
                                    }
                                    return null;
                                };

                                let replace = (() => {
                                    let nearTrap = liztobj.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && cdf(tmp, player) <= tmp.getScale() + 5);
                                    let spike = gameObjects.find(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && cdf(tmp, player) < 87 && !nearTrap.length);
                                    let buildId = spike ? 4 : 2;

                                    replaceable.forEach(build => {
                                        let angle = findPlacementAngle(player, buildId, build);
                                        if (angle !== null) {
                                            place(buildId, angle);
                                            textManager.showText(build.x, build.y, 20, 0.15, 1850, '‚≠ê', '#fff', 2);
                                        }
                                    });
                                });

                                if (near && near.dist3 <= 360) {
                                    replace();
                                }
                                replace;
                            }
                            }
                    }
                }
                for (var i1 = 0; i1 < liztobj.length; i1++) {
                    if (liztobj[i1].active && liztobj[i1].health > 0 && UTILS.getDist(liztobj[i1], player, 0, 2) < 150 && getEl("antipush").checked) {
                        if (liztobj[i1].name.includes("spike") && liztobj[i1]) {
                            if (liztobj[i1].owner.sid != player.sid && clicks.left == false && tmpObj.reloads[tmpObj.secondaryIndex] == 0) {
                                selectWeapon(player.weapons[1]);
                                buyEquip(40, 0);
                                packet("D", UTILS.getDirect(liztobj[i1], player, 0, 2));
                                setTickout(() => {
                                    buyEquip(6, 0);
                                }, 1);
                            }
                        }
                    }
                }

                function ez(context, x, y) {
                    context.fillStyle = "rgba(0, 255, 255, 0.2)";
                    context.beginPath();
                    context.fill();
                    context.closePath();
                    context.globalAlpha = 1;
                }

                function updateLeaderboard(data) {
                    lastLeaderboardData = data;
                    return;
                    UTILS.removeAllChildren(leaderboardData);
                    let tmpC = 1;
                    for (let i = 0; i < data.length; i += 3) {
                        (function (i) {
                            UTILS.generateElement({
                                class: "leaderHolder"
                                , parent: leaderboardData
                                , children: [
                                    UTILS.generateElement({
                                        class: "leaderboardItem"
                                        , style: "color:" + ((data[i] == playerSID) ? "#fff" : "rgba(255,255,255,0.6)")
                                        , text: tmpC + ". " + (data[i + 1] != "" ? data[i + 1] : "unknown")
                                    })
                                    , UTILS.generateElement({
                                        class: "leaderScore"
                                        , text: UTILS.sFormat(data[i + 2]) || "0"
                                    })
                                ]
                            });
                        })(i);
                        tmpC++;
                    }
                }

                function loadGameObject(data) {
                    for (let i = 0; i < data.length;) {
                        objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4]
                                          , data[i + 5], items.list[data[i + 6]], true, (data[i + 7] >= 0 ? {
                            sid: data[i + 7]
                        } : null));

                        i += 8;
                    }
                }

                function loadAI(data) {
                    for (let i = 0; i < ais.length; ++i) {
                        ais[i].forcePos = !ais[i].visible;
                        ais[i].visible = false;
                    }
                    if (data) {
                        let tmpTime = performance.now();
                        for (let i = 0; i < data.length;) {
                            tmpObj = findAIBySID(data[i]);
                            if (tmpObj) {
                                tmpObj.index = data[i + 1];
                                tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                                tmpObj.t2 = tmpTime;
                                tmpObj.x1 = tmpObj.x;
                                tmpObj.y1 = tmpObj.y;
                                tmpObj.x2 = data[i + 2];
                                tmpObj.y2 = data[i + 3];
                                tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 4] : tmpObj.d2;
                                tmpObj.d2 = data[i + 4];
                                tmpObj.health = data[i + 5];
                                tmpObj.dt = 0;
                                tmpObj.visible = true;
                            } else {
                                tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                                tmpObj.x2 = tmpObj.x;
                                tmpObj.y2 = tmpObj.y;
                                tmpObj.d2 = tmpObj.dir;
                                tmpObj.health = data[i + 5];
                                if (!aiManager.aiTypes[data[i + 1]].name)
                                    tmpObj.name = config.cowNames[data[i + 6]];
                                tmpObj.forcePos = true;
                                tmpObj.sid = data[i];
                                tmpObj.visible = true;
                            }
                            i += 7;
                        }
                    }
                }

                function animateAI(sid) {
                    tmpObj = findAIBySID(sid);
                    if (tmpObj) tmpObj.startAnim();
                }

                function gatherAnimation(sid, didHit, index) {
                    tmpObj = findPlayerBySID(sid);
                    if (tmpObj) {
                        tmpObj.startAnim(didHit, index);
                        tmpObj.gatherIndex = index;
                        tmpObj.gathering = 1;
                        if (tmpObj == near && tmpObj.dist2 <= 250) {
                            let weaponName = items.weapons[index].name;
                            if (weaponName == "polearm") {
                                buyEquip(1, 6);
                                if (tmpObj.damaged > 0) {
                                    storeEquip(1, 22);
                                    if (tmpObj.damaged > 0) {
                                        storeEquip(1, 11);
                                        storeEquip(18, 1);
                                        healer();
                                    }
                                }
                            }
                            if (weaponName == "short sword") {
                                buyEquip(1, 6);
                                if (tmpObj.damaged > 0) {
                                    buyEquip(1, 22);
                                    if (tmpObj.damaged > 0) {
                                        buyEquip(1, 11);
                                        buyEquip(18, 1);
                                        healer();
                                    }
                                }
                            }
                        }
                        if (didHit) {
                            let tmpObjects = objectManager.hitObj;
                            objectManager.hitObj = [];
                            game.tickBase(() => {

                                tmpObj = findPlayerBySID(sid);
                                let val =
                                    items.weapons[index].dmg *
                                    config.weaponVariants[
                                        tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]
                                    ].val *
                                    (items.weapons[index].sDmg || 1) *
                                    (tmpObj.skinIndex == 40 ? 3.3 : 1);
                                tmpObjects.forEach((healthy) => {
                                    healthy.health -= val;
                                });
                            }, 1);
                        }
                    }
                }

                function wiggleGameObject(dir, sid) {
                    tmpObj = findObjectBySid(sid);
                    if (tmpObj) {
                        tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
                        tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
                        if (tmpObj.health) {
                            objectManager.hitObj.push(tmpObj);
                        }
                    }
                }

                function shootTurret(sid, dir) {
                    tmpObj = findObjectBySid(sid);
                    if (tmpObj) {
                        if (config.anotherVisual) {
                            tmpObj.lastDir = dir;
                        } else {
                            tmpObj.dir = dir;
                        }
                        tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
                        tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
                    }
                }

                let hahaKills;

                function updatePlayerValue(index, value) {
                    if (player) {
                        player[index] = value;
                        if (index === "points") {
                            if (configs.autoBuy) {
                                autoBuy.hat();
                                autoBuy.acc();
                            }
                        } else if (index === "kills") {
                            hahaKills++;
                            if (configs.killChat) {
                                sendChat("Red Elite for ever!");
                            }
                        }
                    }
                }

                let VISIBLE_ACTION_BAR_ITEMS = [16, 19, 22, 26];
                let HIDDEN_ACTION_BAR_ITEMS = [17, 18, 20, 21, 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38];

                function updatePlayerItemsAndWeapons(data, wpn) {
                    if (data) {
                        if (wpn) {
                            player.weapons = data;
                            player.primaryIndex = player.weapons[0];
                            player.secondaryIndex = player.weapons[1];
                            if (!instaC.isTrue) {
                                selectWeapon(player.weapons[0]);
                            }
                        } else {
                            player.items = data;
                        }
                    }
                }

                function updateActionBarDisplay() {
                    items.weapons.forEach((weapon, index) => {
                        let actionBarItem = getEl(`actionBarItem${index}`);
                        actionBarItem.style.display = player.weapons[weapon.type] === weapon.id ? 'inline-block' : 'none';
                    });

                    VISIBLE_ACTION_BAR_ITEMS.forEach(id => {
                        getEl(`actionBarItem${id}`)
                            .style.display = 'inline-block';
                    });

                    HIDDEN_ACTION_BAR_ITEMS.forEach(id => {
                        getEl(`actionBarItem${id}`)
                            .style.display = 'none';
                    });
                }

                function updateItems(data, wpn) {
                    updatePlayerItemsAndWeapons(data, wpn);
                    updateActionBarDisplay();
                }

                function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
                    projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer, inWindow)
                        .sid = sid;
                    runAtNextTick.push(Array.prototype.slice.call(arguments));
                }

                function remProjectile(sid, range) {
                    for (let i = 0; i < projectiles.length; ++i) {
                        if (projectiles[i].sid == sid) {
                            projectiles[i].range = range;
                            let tmpObjects = objectManager.hitObj;
                            objectManager.hitObj = [];
                            game.tickBase(() => {
                                let val = projectiles[i].dmg;
                                tmpObjects.forEach((healthy) => {
                                    if (healthy.projDmg) {
                                        healthy.health -= val;
                                    }
                                });
                            }, 1);
                        }
                    }
                }

                let gameTitle = getEl("gameName");
                gameTitle.innerText = "Red Will";

                function setPlayerTeam(team, isOwner) {
                    if (player) {
                        player.team = team;
                        player.isOwner = isOwner;
                        if (team == null) {
                            alliancePlayers = [];
                        }
                    }
                }

                function setAlliancePlayers(data) {
                    alliancePlayers = data;
                }

                function updateStoreItems(type, id, index) {
                    if (index) {
                        if (!type) {
                            player.tails[id] = 1;
                        } else {
                            player.latestTail = id;
                        }
                    } else {
                        if (!type) {
                            player.skins[id] = 1;
                            id == 7 && (my.reSync = true);
                        } else {
                            player.latestSkin = id;
                        }
                    }
                }

                function receiveChat(sid, message) {
                    let tmpPlayer = findPlayerBySID(sid);
                    tmpPlayer.chatMessage = message;
                    tmpPlayer.chatCountdown = config.chatCountdown;
                }

                function updateMinimap(data) {
                    minimapData = data;
                }

                function showText(x, y, value, type) {
                    textManager.showText(x, y, 50, 0.18, 500, Math.abs(value), value >= 0 ? "#fff" : "#8ecc51")
                }

                function renderLeaf(x, y, l, r, ctxt) {
                    let endX = x + (l * Math.cos(r));
                    let endY = y + (l * Math.sin(r));
                    let width = l * 0.4;
                    ctxt.moveTo(x, y);
                    ctxt.beginPath();
                    ctxt.quadraticCurveTo(((x + endX) / 2) + (width * Math.cos(r + Math.PI / 2))
                                          , ((y + endY) / 2) + (width * Math.sin(r + Math.PI / 2)), endX, endY);
                    ctxt.quadraticCurveTo(((x + endX) / 2) - (width * Math.cos(r + Math.PI / 2))
                                          , ((y + endY) / 2) - (width * Math.sin(r + Math.PI / 2)), x, y);
                    ctxt.closePath();
                    ctxt.fill();
                    ctxt.stroke();
                }

                function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                    tmpContext = tmpContext || mainContext;
                    tmpContext.beginPath();
                    tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                    if (!dontFill) tmpContext.fill();
                    if (!dontStroke) tmpContext.stroke();
                }

                function renderHealthCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                    tmpContext = tmpContext || mainContext;
                    tmpContext.beginPath();
                    tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                    if (!dontFill) tmpContext.fill();
                    if (!dontStroke) tmpContext.stroke();
                }

                function renderStar(ctxt, spikes, outer, inner) {
                    let rot = Math.PI / 2 * 3;
                    let x, y;
                    let step = Math.PI / spikes;
                    ctxt.beginPath();
                    ctxt.moveTo(0, -outer);
                    for (let i = 0; i < spikes; i++) {
                        x = Math.cos(rot) * outer;
                        y = Math.sin(rot) * outer;
                        ctxt.lineTo(x, y);
                        rot += step;
                        x = Math.cos(rot) * inner;
                        y = Math.sin(rot) * inner;
                        ctxt.lineTo(x, y);
                        rot += step;
                    }
                    ctxt.lineTo(0, -outer);
                    ctxt.closePath();
                }

                function renderHealthStar(ctxt, spikes, outer, inner) {
                    let rot = Math.PI / 2 * 3;
                    let x, y;
                    let step = Math.PI / spikes;
                    ctxt.beginPath();
                    ctxt.moveTo(0, -outer);
                    for (let i = 0; i < spikes; i++) {
                        x = Math.cos(rot) * outer;
                        y = Math.sin(rot) * outer;
                        ctxt.lineTo(x, y);
                        rot += step;
                        x = Math.cos(rot) * inner;
                        y = Math.sin(rot) * inner;
                        ctxt.lineTo(x, y);
                        rot += step;
                    }
                    ctxt.lineTo(0, -outer);
                    ctxt.closePath();
                }

                function renderRect(x, y, w, h, ctxt, dontStroke, dontFill) {
                    if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
                    if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
                }

                function renderHealthRect(x, y, w, h, ctxt, dontStroke, dontFill) {
                    if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
                    if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
                }

                function renderRectCircle(x, y, s, sw, seg, ctxt, dontStroke, dontFill) {
                    ctxt.save();
                    ctxt.translate(x, y);
                    seg = Math.ceil(seg / 2);
                    for (let i = 0; i < seg; i++) {
                        renderRect(0, 0, s * 2, sw, ctxt, dontStroke, dontFill);
                        ctxt.rotate(Math.PI / seg);
                    }
                    ctxt.restore();
                }

                function renderBlob(ctxt, spikes, outer, inner) {
                    let rot = Math.PI / 2 * 3;
                    let x, y;
                    let step = Math.PI / spikes;
                    let tmpOuter;
                    ctxt.beginPath();
                    ctxt.moveTo(0, -inner);
                    for (let i = 0; i < spikes; i++) {
                        tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
                        ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter
                                              , Math.cos(rot + (step * 2)) * inner, Math.sin(rot + (step * 2)) * inner);
                        rot += step * 2;
                    }
                    ctxt.lineTo(0, -inner);
                    ctxt.closePath();
                }

                function renderTriangle(s, ctx) {
                    ctx = ctx || mainContext;
                    let h = s * (Math.sqrt(3) / 2);
                    ctx.beginPath();
                    ctx.moveTo(0, -h / 2);
                    ctx.lineTo(-s / 2, h / 2);
                    ctx.lineTo(s / 2, h / 2);
                    ctx.lineTo(0, -h / 2);
                    ctx.fill();
                    ctx.closePath();
                }

                function prepareMenuBackground() {
                    let tmpMid = config.mapScale / 2;
                    let attempts = 0;
                    for (let i = 0; i < items.list.length * 3;) {
                        if (attempts >= 1000) break;
                        attempts++;
                        let type = items.list[UTILS.randInt(0, items.list.length - 1)];
                        let data = {
                            x: tmpMid + UTILS.randFloat(-1000, 1000)
                            , y: tmpMid + UTILS.randFloat(-600, 600)
                            , dir: UTILS.fixTo(Math.random() * (Math.PI * 2), 2)
                        };
                        if (objectManager.checkItemLocation(data.x, data.y, type.scale, 0.6, type.id, true)) {
                            objectManager.add(i, data.x, data.y, data.dir, type.scale, type.id, type);
                        } else {
                            continue;
                        }
                        i++;
                    }
                }
                let speed = 35;

                function renderDeadPlayers(xOffset, yOffset) {
                    mainContext.fillStyle = "#91b2db";
                    let currentTime = Date.now();
                    deadPlayers.filter(dead => dead.active)
                        .forEach((dead) => {
                        if (!dead.startTime) {
                            dead.startTime = currentTime;
                            dead.angle = 0;
                            dead.radius = 0.1;
                        }
                        let timeElapsed = currentTime - dead.startTime;
                        let maxAlpha = 1;
                        dead.alpha = Math.max(0, maxAlpha - (timeElapsed / 3000));
                        dead.animate(delta);
                        mainContext.globalAlpha = dead.alpha;
                        mainContext.strokeStyle = outlineColor;
                        mainContext.save();
                        mainContext.translate(dead.x - xOffset, dead.y - yOffset);
                        dead.radius -= 0.001;
                        dead.angle += 0.0174533;
                        let moveSpeed = 1;
                        let x = dead.radius * Math.cos(dead.angle);
                        let y = dead.radius * Math.sin(dead.angle);
                        dead.x += x * moveSpeed;
                        dead.y += y * moveSpeed;
                        mainContext.rotate(dead.angle);
                        renderDeadPlayer(dead, mainContext);
                        mainContext.restore();
                        mainContext.fillStyle = "#91b2db";
                        if (timeElapsed >= 3000) {
                            dead.active = false;
                            dead.startTime = null;
                        }
                    });
                }

                function renderPlayers(xOffset, yOffset, zIndex) {
                    mainContext.globalAlpha = 1;
                    mainContext.fillStyle = "#91b2db";
                    for (let i = 0; i < players.length; ++i) {
                        tmpObj = players[i];
                        if (tmpObj.zIndex == zIndex) {
                            tmpObj.animate(delta);
                            if (tmpObj.visible) {
                                tmpObj.skinRot += (0.002 * delta);
                                tmpDir = (!configs.showDir && !useWasd && tmpObj == player) ? configs.attackDir ? getVisualDir() : getAttackDir() : (tmpObj.dir || 0);
                                mainContext.save();
                                mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);

                                mainContext.rotate(tmpDir + tmpObj.dirPlus);
                                renderPlayer(tmpObj, mainContext);
                                mainContext.restore();

                            }
                        }
                    }
                }

                function renderDeadPlayer(obj, ctxt) {
                    ctxt = ctxt || mainContext;
                    ctxt.lineWidth = outlineWidth;
                    ctxt.lineJoin = "miter";
                    let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS || 1);
                    let oHandAngle = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndS || 1) : 1;
                    let oHandDist = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndD || 1) : 1;

                    renderTail2(13, ctxt, obj);

                    if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant || 0].src || "", obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0
                                             , items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    ctxt.fillStyle = "#ececec";
                    renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
                    renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle)
                                 , (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

                    if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant || 0].src || "", obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0
                                             , items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    if (obj.buildIndex >= 0) {
                        let tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                        ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
                    }

                    renderCircle(0, 0, obj.scale, ctxt);

                    renderSkin2(48, ctxt, null, obj)
                }

                function renderPlayer(obj, ctxt) {
                    ctxt = ctxt || mainContext;
                    ctxt.lineWidth = outlineWidth;
                    ctxt.lineJoin = "miter";
                    let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS || 1);
                    let oHandAngle = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndS || 1) : 1;
                    let oHandDist = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndD || 1) : 1;

                    if (obj.tailIndex > 0) {
                        renderTailTextureImage(obj.tailIndex, ctxt, obj);
                    }

                    if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0
                                             , items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    ctxt.fillStyle = config.skinColors[obj.skinColor];
                    renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
                    renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle)
                                 , (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

                    if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                            renderProjectile(obj.scale, 0
                                             , items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                        }
                    }

                    if (obj.buildIndex >= 0) {
                        let tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                        ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
                    }

                    renderCircle(0, 0, obj.scale, ctxt);

                    if (obj.skinIndex > 0) {
                        ctxt.rotate(Math.PI / 2);
                        renderTextureSkin(obj.skinIndex, ctxt, null, obj);
                    }

                }

                let skinSprites2 = {};
                let skinPointers2 = {};

                function renderSkin2(index, ctxt, parentSkin, owner) {
                    tmpSkin = skinSprites2[index];
                    if (!tmpSkin) {
                        let tmpImage = new Image();
                        tmpImage.onload = function () {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
                        skinSprites2[index] = tmpImage;
                        tmpSkin = tmpImage;
                    }
                    let tmpObj = parentSkin || skinPointers2[index];
                    if (!tmpObj) {
                        for (let i = 0; i < hats.length; ++i) {
                            if (hats[i].id == index) {
                                tmpObj = hats[i];
                                break;
                            }
                        }
                        skinPointers2[index] = tmpObj;
                    }
                    if (tmpSkin.isLoaded)
                        ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
                    if (!parentSkin && tmpObj.topSprite) {
                        ctxt.save();
                        ctxt.rotate(owner.skinRot);
                        renderSkin2(index + "_top", ctxt, tmpObj, owner);
                        ctxt.restore();
                    }
                }

                function renderTextureSkin(index, ctxt, parentSkin, owner) {
                    if (!(tmpSkin = skinSprites[index + (txt ? "lol" : 0)])) {
                        let tmpImage = new Image();
                        tmpImage.onload = function () {
                            this.isLoaded = true
                                , this.onload = null
                        }
                            , tmpImage.src = setSkinTextureImage(index, "hat", index)
                            , skinSprites[index + (txt ? "lol" : 0)] = tmpImage
                            , tmpSkin = tmpImage
                    }
                    let tmpObj = parentSkin || skinPointers[index];
                    if (!tmpObj) {
                        for (let i = 0; i < hats.length; ++i) {
                            if (hats[i].id == index) {
                                tmpObj = hats[i];
                                break;
                            }
                        }
                        skinPointers[index] = tmpObj;
                    }
                    if (tmpSkin.isLoaded)
                        ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
                    if (!parentSkin && tmpObj.topSprite) {
                        ctxt.save();
                        ctxt.rotate(owner.skinRot);
                        renderSkin(index + "_top", ctxt, tmpObj, owner);
                        ctxt.restore();
                    }
                }

                function setSkinTextureImage(id, type, id2) {
                    if (true) {
                        if (type == "acc") {
                            return ".././img/accessories/access_" + id + ".png";
                        } else if (type == "hat") {
                            return ".././img/hats/hat_" + id + ".png";
                        } else {
                            return ".././img/weapons/" + id + ".png";
                        }
                    } else {
                        if (type == "acc") {
                            return ".././img/accessories/access_" + id + ".png";
                        } else if (type == "hat") {
                            return ".././img/hats/hat_" + id + ".png";
                        } else {
                            return ".././img/weapons/" + id + ".png";
                        }
                    }
                }

                let skinSprites = {};
                let skinPointers = {};
                let tmpSkin;

                function renderSkin(index, ctxt, parentSkin, owner) {
                    tmpSkin = skinSprites[index];
                    if (!tmpSkin) {
                        let tmpImage = new Image();
                        tmpImage.onload = function () {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
                        skinSprites[index] = tmpImage;
                        tmpSkin = tmpImage;
                    }
                    let tmpObj = parentSkin || skinPointers[index];
                    if (!tmpObj) {
                        for (let i = 0; i < hats.length; ++i) {
                            if (hats[i].id == index) {
                                tmpObj = hats[i];
                                break;
                            }
                        }
                        skinPointers[index] = tmpObj;
                    }
                    if (tmpSkin.isLoaded)
                        ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
                    if (!parentSkin && tmpObj.topSprite) {
                        ctxt.save();
                        ctxt.rotate(owner.skinRot);
                        renderSkin(index + "_top", ctxt, tmpObj, owner);
                        ctxt.restore();
                    }
                }

                function setTailTextureImage(id, type, id2) {
                    if (true) {
                        if (type == "acc") {
                            return ".././img/accessories/access_" + id + ".png";
                        } else if (type == "hat") {
                            return ".././img/hats/hat_" + id + ".png";
                        } else {
                            return ".././img/weapons/" + id + ".png";
                        }
                    } else {
                        if (type == "acc") {
                            return ".././img/accessories/access_" + id + ".png";
                        } else if (type == "hat") {
                            return ".././img/hats/hat_" + id + ".png";
                        } else {
                            return ".././img/weapons/" + id + ".png";
                        }
                    }
                }

                function renderTailTextureImage(index, ctxt, owner) {
                    if (!(tmpSkin = accessSprites[index + (txt ? "lol" : 0)])) {
                        let tmpImage = new Image();
                        tmpImage.onload = function () {
                            this.isLoaded = true
                                , this.onload = null
                        }
                            , tmpImage.src = setTailTextureImage(index, "acc"),
                            accessSprites[index + (txt ? "lol" : 0)] = tmpImage
                            , tmpSkin = tmpImage;
                    }
                    let tmpObj = accessPointers[index];
                    if (!tmpObj) {
                        for (let i = 0; i < accessories.length; ++i) {
                            if (accessories[i].id == index) {
                                tmpObj = accessories[i];
                                break;
                            }
                        }
                        accessPointers[index] = tmpObj;
                    }
                    if (tmpSkin.isLoaded) {
                        ctxt.save();
                        ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                        if (tmpObj.spin)
                            ctxt.rotate(owner.skinRot);
                        ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                        ctxt.restore();
                    }
                }

                let accessSprites = {};
                let accessPointers = {};
                let txt = true;

                function renderTail(index, ctxt, owner) {
                    tmpSkin = accessSprites[index];
                    if (!tmpSkin) {
                        let tmpImage = new Image();
                        tmpImage.onload = function () {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
                        accessSprites[index] = tmpImage;
                        tmpSkin = tmpImage;
                    }
                    let tmpObj = accessPointers[index];
                    if (!tmpObj) {
                        for (let i = 0; i < accessories.length; ++i) {
                            if (accessories[i].id == index) {
                                tmpObj = accessories[i];
                                break;
                            }
                        }
                        accessPointers[index] = tmpObj;
                    }
                    if (tmpSkin.isLoaded) {
                        ctxt.save();
                        ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                        if (tmpObj.spin)
                            ctxt.rotate(owner.skinRot);
                        ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                        ctxt.restore();
                    }
                }

                let accessSprites2 = {};
                let accessPointers2 = {};

                function renderTail2(index, ctxt, owner) {
                    tmpSkin = accessSprites2[index];
                    if (!tmpSkin) {
                        let tmpImage = new Image();
                        tmpImage.onload = function () {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
                        accessSprites2[index] = tmpImage;
                        tmpSkin = tmpImage;
                    }
                    let tmpObj = accessPointers2[index];
                    if (!tmpObj) {
                        for (let i = 0; i < accessories.length; ++i) {
                            if (accessories[i].id == index) {
                                tmpObj = accessories[i];
                                break;
                            }
                        }
                        accessPointers2[index] = tmpObj;
                    }
                    if (tmpSkin.isLoaded) {
                        ctxt.save();
                        ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                        if (tmpObj.spin)
                            ctxt.rotate(owner.skinRot);
                        ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                        ctxt.restore();
                    }
                }

                let toolSprites = {};

                function renderTool(obj, variant, x, y, ctxt) {
                    let tmpSrc = obj.src + (variant || "");
                    let tmpSprite = toolSprites[tmpSrc];
                    if (!tmpSprite) {
                        tmpSprite = new Image();
                        tmpSprite.onload = function () {
                            this.isLoaded = true;
                        }
                        tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
                        toolSprites[tmpSrc] = tmpSprite;
                    }
                    if (tmpSprite.isLoaded)
                        ctxt.drawImage(tmpSprite, x + obj.xOff - (obj.length / 2), y + obj.yOff - (obj.width / 2), obj.length, obj.width);
                }

                function renderProjectiles(layer, xOffset, yOffset) {
                    for (let i = 0; i < projectiles.length; i++) {
                        tmpObj = projectiles[i];
                        if (tmpObj.active && tmpObj.layer == layer && tmpObj.inWindow) {
                            tmpObj.update(delta);
                            if (tmpObj.active && isOnScreen(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.scale)) {
                                mainContext.save();
                                mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                mainContext.rotate(tmpObj.dir);
                                renderProjectile(0, 0, tmpObj, mainContext, 1);
                                mainContext.restore();
                            }
                        }
                    };
                }

                let projectileSprites = {};

                function renderProjectile(x, y, obj, ctxt, debug) {
                    if (obj.src) {
                        let tmpSrc = items.projectiles[obj.indx].src;
                        let tmpSprite = projectileSprites[tmpSrc];
                        if (!tmpSprite) {
                            tmpSprite = new Image();
                            tmpSprite.onload = function () {
                                this.isLoaded = true;
                            }
                            tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
                            projectileSprites[tmpSrc] = tmpSprite;
                        }
                        if (tmpSprite.isLoaded)
                            ctxt.drawImage(tmpSprite, x - (obj.scale / 2), y - (obj.scale / 2), obj.scale, obj.scale);
                    } else if (obj.indx == 1) {
                        ctxt.fillStyle = "#939393";
                        renderCircle(x, y, obj.scale, ctxt);
                    }
                }

                let aiSprites = {};

                function renderAI(obj, ctxt) {
                    let tmpIndx = obj.index;
                    let tmpSprite = aiSprites[tmpIndx];
                    if (!tmpSprite) {
                        let tmpImg = new Image();
                        tmpImg.onload = function () {
                            this.isLoaded = true;
                            this.onload = null;
                        };
                        tmpImg.src = "https://moomoo.io/img/animals/" + obj.src + ".png";
                        tmpSprite = tmpImg;
                        aiSprites[tmpIndx] = tmpSprite;
                    }
                    if (tmpSprite.isLoaded) {
                        let tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
                        ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
                    }
                }

                function renderWaterBodies(xOffset, yOffset, ctxt, padding) {

                    let tmpW = config.riverWidth + padding;
                    let tmpY = (config.mapScale / 2) - yOffset - (tmpW / 2);
                    if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
                        ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
                    }
                }

                let gameObjectSprites = {};

                function getResSprite(obj) {
                    let biomeID = (obj.y >= config.mapScale - config.snowBiomeTop) ? 2 : ((obj.y <= config.snowBiomeTop) ? 1 : 0);
                    let tmpIndex = (obj.type + "_" + obj.scale + "_" + biomeID);
                    let tmpSprite = gameObjectSprites[tmpIndex];
                    if (!tmpSprite) {
                        let blurScale = 6;
                        let tmpCanvas = document.createElement("canvas");
                        tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.1) + outlineWidth;
                        let tmpContext = tmpCanvas.getContext('2d');
                        tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                        tmpContext.rotate(UTILS.randFloat(0, Math.PI));
                        tmpContext.strokeStyle = outlineColor;
                        tmpContext.lineWidth = outlineWidth;
                        if (obj.type == 0) {
                            let tmpScale;
                            let tmpCount = 8;
                            tmpContext.globalAlpha = 1;
                            for (let i = 0; i < 2; ++i) {
                                tmpScale = tmpObj.scale * (!i ? 1 : 0.5);
                                renderStar(tmpContext, tmpCount, tmpScale, tmpScale * 0.7);
                                tmpContext.fillStyle = !biomeID ? (!i ? "#9ebf57" : "#b4db62") : (!i ? "#e3f1f4" : "#fff");
                                tmpContext.fill();
                                if (!i) {
                                    tmpContext.stroke();
                                    tmpContext.globalAlpha = 1;
                                }
                            }
                        } else if (obj.type == 1) {
                            if (biomeID == 2) {
                                tmpContext.fillStyle = "#606060";
                                renderStar(tmpContext, 6, obj.scale * 0.3, obj.scale * 0.71);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = "#89a54c";
                                renderCircle(0, 0, obj.scale * 0.55, tmpContext);
                                tmpContext.fillStyle = "#a5c65b";
                                renderCircle(0, 0, obj.scale * 0.3, tmpContext, true);
                            } else {
                                renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
                                tmpContext.fillStyle = biomeID ? "#e3f1f4" : "#89a54c";
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpContext.fillStyle = biomeID ? "#6a64af" : "#c15555";
                                let tmpRange;
                                let berries = 4;
                                let rotVal = (Math.PI * 2) / berries;
                                for (let i = 0; i < berries; ++i) {
                                    tmpRange = UTILS.randInt(tmpObj.scale / 3.5, tmpObj.scale / 2.3);
                                    renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i)
                                                 , UTILS.randInt(10, 12), tmpContext);
                                }
                            }
                        } else if (obj.type == 2 || obj.type == 3) {
                            tmpContext.fillStyle = (obj.type == 2) ? (biomeID == 2 ? "#938d77" : "#939393") : "#e0c655";
                            renderStar(tmpContext, 3, obj.scale, obj.scale);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = (obj.type == 2) ? (biomeID == 2 ? "#b2ab90" : "#bcbcbc") : "#ebdca3";
                            renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                            tmpContext.fill();
                        }
                        tmpSprite = tmpCanvas;
                        gameObjectSprites[tmpIndex] = tmpSprite;
                    }
                    return tmpSprite;
                }

                let itemSprites = [];

                function getItemSprite(obj, asIcon) {
                    let tmpSprite = itemSprites[obj.id];
                    if (!tmpSprite || asIcon) {
                        let tmpCanvas = document.createElement("canvas");
                        let reScale = ((!asIcon && obj.name == "windmill") ? items.list[4].scale : obj.scale);
                        tmpCanvas.width = tmpCanvas.height = (reScale * 2.5) + outlineWidth + (items.list[obj.id].spritePadding || 0);

                        let tmpContext = tmpCanvas.getContext("2d");
                        tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                        tmpContext.rotate(asIcon ? 0 : (Math.PI / 2));
                        tmpContext.strokeStyle = outlineColor;
                        tmpContext.lineWidth = outlineWidth * (asIcon ? (tmpCanvas.width / 81) : 1);

                        if (obj.name == "apple") {
                            tmpContext.fillStyle = "#c15555";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fillStyle = "#89a54c";
                            let leafDir = -(Math.PI / 2);
                            renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir)
                                       , 25, leafDir + Math.PI / 2, tmpContext);
                        } else if (obj.name == "cookie") {
                            tmpContext.fillStyle = "#cca861";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fillStyle = "#937c4b";
                            let chips = 4;
                            let rotVal = (Math.PI * 2) / chips;
                            let tmpRange;
                            for (let i = 0; i < chips; ++i) {
                                tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i)
                                             , UTILS.randInt(4, 5), tmpContext, true);
                            }
                        } else if (obj.name == "cheese") {
                            tmpContext.fillStyle = "#f4f3ac";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fillStyle = "#c3c28b";
                            let chips = 4;
                            let rotVal = (Math.PI * 2) / chips;
                            let tmpRange;
                            for (let i = 0; i < chips; ++i) {
                                tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i)
                                             , UTILS.randInt(4, 5), tmpContext, true);
                            }
                        } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                            tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                                "#a5974c" : "#939393";
                            let sides = (obj.name == "castle wall") ? 4 : 3;
                            renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                                "#c9b758" : "#bcbcbc";
                            renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                            tmpContext.fill();
                        } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                                   obj.name == "spinning spikes") {
                            tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                            let tmpScale = (obj.scale * 0.6);
                            renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#a5974c";
                            renderCircle(0, 0, tmpScale, tmpContext);
                            tmpContext.fillStyle = "#c9b758";
                            renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                        } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                            tmpContext.fillStyle = "#a5974c";
                            renderCircle(0, 0, reScale, tmpContext);
                            tmpContext.fillStyle = "#c9b758";
                            renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
                            tmpContext.fillStyle = "#a5974c";
                            renderCircle(0, 0, reScale * 0.5, tmpContext);
                        } else if (obj.name == "mine") {
                            tmpContext.fillStyle = "#939393";
                            renderStar(tmpContext, 3, obj.scale, obj.scale);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#bcbcbc";
                            renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                            tmpContext.fill();
                        } else if (obj.name == "sapling") {
                            for (let i = 0; i < 2; ++i) {
                                let tmpScale = obj.scale * (!i ? 1 : 0.5);
                                renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                                tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                                tmpContext.fill();
                                if (!i) tmpContext.stroke();
                            }
                        } else if (obj.name == "pit trap") {
                            tmpContext.fillStyle = "#a5974c";
                            renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = outlineColor;
                            renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                            tmpContext.fill();
                        } else if (obj.name == "boost pad") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#dbd97d";
                            renderTriangle(obj.scale * 1, tmpContext);
                        } else if (obj.name == "turret") {
                            tmpContext.fillStyle = "#a5974c";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#939393";
                            let tmpLen = 50;
                            renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                            renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                        } else if (obj.name == "platform") {
                            tmpContext.fillStyle = "#cebd5f";
                            let tmpCount = 4;
                            let tmpS = obj.scale * 2;
                            let tmpW = tmpS / tmpCount;
                            let tmpX = -(obj.scale / 2);
                            for (let i = 0; i < tmpCount; ++i) {
                                renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpX += tmpS / tmpCount;
                            }
                        } else if (obj.name == "healing pad") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#db6e6e";
                            renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                        } else if (obj.name == "spawn pad") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#71aad6";
                            renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        } else if (obj.name == "blocker") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.rotate(Math.PI / 4);
                            tmpContext.fillStyle = "#db6e6e";
                            renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                        } else if (obj.name == "teleporter") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.rotate(Math.PI / 4);
                            tmpContext.fillStyle = "#d76edb";
                            renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                        }
                        tmpSprite = tmpCanvas;
                        if (!asIcon) {
                            itemSprites[obj.id] = tmpSprite;
                        }
                    }
                    return tmpSprite;
                }

                function getItemSprite2(obj, tmpX, tmpY) {
                    let tmpContext = mainContext;
                    let reScale = (obj.name == "windmill" ? items.list[4].scale : obj.scale);
                    tmpContext.save();
                    tmpContext.translate(tmpX, tmpY);
                    tmpContext.rotate(obj.dir);
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth;
                    if (obj.name == "apple") {
                        tmpContext.fillStyle = "#c15555";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#89a54c";
                        let leafDir = -(Math.PI / 2);
                        renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir)
                                   , 25, leafDir + Math.PI / 2, tmpContext);
                    } else if (obj.name == "cookie") {
                        tmpContext.fillStyle = "#cca861";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#937c4b";
                        let chips = 4;
                        let rotVal = (Math.PI * 2) / chips;
                        let tmpRange;
                        for (let i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i)
                                         , UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "cheese") {
                        tmpContext.fillStyle = "#f4f3ac";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c3c28b";
                        let chips = 4;
                        let rotVal = (Math.PI * 2) / chips;
                        let tmpRange;
                        for (let i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i)
                                         , UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                        tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                            "#a5974c" : "#939393";
                        let sides = (obj.name == "castle wall") ? 4 : 3;
                        renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                            "#c9b758" : "#bcbcbc";
                        renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                               obj.name == "spinning spikes") {
                        tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                        let tmpScale = (obj.scale * 0.6);
                        renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, reScale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, reScale * 0.5, tmpContext);
                    } else if (obj.name == "mine") {
                        tmpContext.fillStyle = "#939393";
                        renderStar(tmpContext, 3, obj.scale, obj.scale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#bcbcbc";
                        renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "sapling") {
                        for (let i = 0; i < 2; ++i) {
                            let tmpScale = obj.scale * (!i ? 1 : 0.5);
                            renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                            tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                            tmpContext.fill();
                            if (!i) tmpContext.stroke();
                        }
                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = outlineColor;
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "boost pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#dbd97d";
                        renderTriangle(obj.scale * 1, tmpContext);
                    } else if (obj.name == "turret") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#939393";
                        let tmpLen = 50;
                        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                    } else if (obj.name == "platform") {
                        tmpContext.fillStyle = "#cebd5f";
                        let tmpCount = 4;
                        let tmpS = obj.scale * 2;
                        let tmpW = tmpS / tmpCount;
                        let tmpX = -(obj.scale / 2);
                        for (let i = 0; i < tmpCount; ++i) {
                            renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpX += tmpS / tmpCount;
                        }
                    } else if (obj.name == "healing pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "spawn pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#71aad6";
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    } else if (obj.name == "blocker") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "teleporter") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#d76edb";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                    }
                    tmpContext.restore();
                }

                let objSprites = [];

                function getObjSprite(obj) {
                    let tmpSprite = objSprites[obj.id];
                    if (!tmpSprite) {
                        let tmpCanvas = document.createElement("canvas");
                        tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0) + 0;
                        let tmpContext = tmpCanvas.getContext("2d");
                        tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                        tmpContext.rotate(Math.PI / 2);
                        tmpContext.strokeStyle = outlineColor;
                        tmpContext.lineWidth = outlineWidth;
                        if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                            tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                            let tmpScale = obj.scale * 0.6;
                            renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#a5974c";
                            renderCircle(0, 0, tmpScale, tmpContext);
                            tmpContext.fillStyle = "#c9b758";
                            renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                        } else if (obj.name == "pit trap") {
                            tmpContext.fillStyle = "#a5974c";
                            renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = outlineColor;
                            renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                            tmpContext.fill();
                        }
                        tmpSprite = tmpCanvas;
                        objSprites[obj.id] = tmpSprite;
                    }
                    return tmpSprite;
                }

                function getMarkSprite(obj, tmpContext, tmpX, tmpY) {
                    let center = {
                        x: screenWidth / 2
                        , y: screenHeight / 2
                        , };
                    tmpContext.lineWidth = outlineWidth;
                    mainContext.globalAlpha = 0.2;
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.save();
                    tmpContext.translate(tmpX, tmpY);
                    tmpContext.rotate(90 ** 10);
                    if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                        tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                        let tmpScale = (obj.scale);
                        renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        if (player && obj.owner && player.sid != obj.owner.sid && !tmpObj.findAllianceBySid(obj.owner.sid)) {
                            tmpContext.fillStyle = "#a34040";
                        } else {
                            tmpContext.fillStyle = "#c9b758";
                        }
                        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                    } else if (obj.name == "turret") {
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#939393";
                        let tmpLen = 50;
                        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                    } else if (obj.name == "teleporter") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#d76edb";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                    } else if (obj.name == "platform") {
                        tmpContext.fillStyle = "#cebd5f";
                        let tmpCount = 4;
                        let tmpS = obj.scale * 2;
                        let tmpW = tmpS / tmpCount;
                        let tmpX = -(obj.scale / 2);
                        for (let i = 0; i < tmpCount; ++i) {
                            renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpX += tmpS / tmpCount;
                        }
                    } else if (obj.name == "healing pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "spawn pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#71aad6";
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    } else if (obj.name == "blocker") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderRectCircle(0, 0, obj.scale * 1.5, 29, 4, tmpContext);
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext);

                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        if (player && obj.owner && player.sid != obj.owner.sid && !tmpObj.findAllianceBySid(obj.owner.sid)) {
                            tmpContext.fillStyle = "#a34040";
                        } else {
                            tmpContext.fillStyle = outlineColor;
                        }
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    }
                    tmpContext.restore();
                }

                function isOnScreen(x, y) {
                    if (x < 0 || x > maxScreenWidth) {
                        return false;
                    }
                    if (y < 0 || y > maxScreenHeight) {
                        return false;
                    }
                    return true;
                }

                function renderGameObjects(layer, xOffset, yOffset) {
                    let tmpSprite;
                    let tmpX;
                    let tmpY;
                    liztobj.forEach((tmp) => {
                        tmpObj = tmp;
                        if (tmpObj.active && liztobj.includes(tmp) && tmpObj.render) {
                            tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
                            tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;
                            if (layer == 0) {
                                tmpObj.update(delta);
                            }
                            mainContext.globalAlpha = tmpObj.alpha;
                            if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                                if (tmpObj.isItem) {
                                    if ((tmpObj.dmg || tmpObj.trap) && !tmpObj.isTeamObject(player)) {
                                        tmpSprite = getObjSprite(tmpObj);
                                    } else {
                                        tmpSprite = getItemSprite(tmpObj);
                                    }

                                    mainContext.save();
                                    mainContext.translate(tmpX, tmpY);
                                    mainContext.rotate(tmpObj.dir);
                                    if (!tmpObj.active) {
                                        mainContext.scale(tmpObj.visScale / tmpObj.scale, tmpObj.visScale / tmpObj.scale);
                                    }
                                    mainContext.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));

                                    if (tmpObj.blocker) {
                                        mainContext.strokeStyle = "#db6e6e";
                                        mainContext.globalAlpha = 0.3;
                                        mainContext.lineWidth = 6;
                                        renderCircle(0, 0, tmpObj.blocker, mainContext, false, true);
                                    }
                                    mainContext.restore();
                                } else {
                                    tmpSprite = getResSprite(tmpObj);
                                    mainContext.drawImage(tmpSprite, tmpX - (tmpSprite.width / 2), tmpY - (tmpSprite.height / 2));
                                }
                            }
                        }
                    });

                    if (layer == 0) {
                        if (placeVisible.length) {
                            placeVisible.forEach((places) => {
                                tmpX = places.x - xOffset;
                                tmpY = places.y - yOffset;
                                markObject(places, tmpX, tmpY);
                            });
                        }
                    }
                }

                function markObject(tmpObj, tmpX, tmpY) {
                    getMarkSprite(tmpObj, mainContext, tmpX, tmpY);
                }

                class MapPing {
                    constructor(color, scale) {
                        this.init = function (x, y) {
                            this.scale = 0;
                            this.x = x;
                            this.y = y;
                            this.active = true;
                        };
                        this.update = function (ctxt, delta) {
                            if (this.active) {
                                this.scale += 0.05 * delta;
                                if (this.scale >= scale) {
                                    this.active = false;
                                } else {
                                    ctxt.globalAlpha = (1 - Math.max(0, this.scale / scale));
                                    ctxt.beginPath();
                                    ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale) *
                                             mapDisplay.width, this.scale, 0, 2 * Math.PI);
                                    ctxt.stroke();
                                }
                            }
                        };
                        this.color = color;
                    }
                }

                function pingMap(x, y) {
                    tmpPing = mapPings.find(pings => !pings.active);
                    if (!tmpPing) {
                        tmpPing = new MapPing("#fff", config.mapPingScale);
                        mapPings.push(tmpPing);
                    }
                    tmpPing.init(x, y);
                }

                function updateMapMarker() {
                    mapMarker.x = player.x;
                    mapMarker.y = player.y;
                }

                let mapDisplay = document.getElementById("mapDisplay");
                let mapContext = mapDisplay.getContext("2d");
                let mapContainer = document.getElementById("mapContainer");

                function renderCirclez(x, y, radius, context, fill = false, glowColor = null) {
                    if (!context) return;
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    if (glowColor) {
                        context.shadowBlur = 15;
                        context.shadowColor = glowColor;
                    }
                    if (fill) {
                        context.fill();
                    } else {
                        context.stroke();
                    }
                    context.shadowBlur = 0;
                }

                function renderMinimap(delta) {
                    if (player && player.alive) {
                        mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);

                        mapContext.strokeStyle = "#444";
                        mapContext.lineWidth = 1;
                        for (let i = 0; i <= mapDisplay.width; i += 30) {
                            mapContext.moveTo(i, 0);
                            mapContext.lineTo(i, mapDisplay.height);
                        }
                        for (let i = 0; i <= mapDisplay.height; i += 30) {
                            mapContext.moveTo(0, i);
                            mapContext.lineTo(mapDisplay.width, i);
                        }
                        mapContext.stroke();

                        mapContext.lineWidth = 4;
                        for (let i = 0; i < mapPings.length; ++i) {
                            let tmpPing = mapPings[i];
                            mapContext.strokeStyle = tmpPing.color;
                            mapContext.shadowBlur = 10;
                            mapContext.shadowColor = tmpPing.color;
                            tmpPing.update(mapContext, delta);
                            let pulseRadius = Math.abs(Math.sin(delta / 500) * 10) + 5;
                            renderCirclez(tmpPing.x, tmpPing.y, pulseRadius, mapContext, false, tmpPing.color);
                        }

                        mapContext.globalAlpha = 1;
                        mapContext.fillStyle = "#00FF00";
                        renderCirclez((player.x / config.mapScale) * mapDisplay.width
                                      , (player.y / config.mapScale) * mapDisplay.height, 7, mapContext, true, "#00FF00");

                        mapContext.fillStyle = "rgba(0, 255, 0, 0.35)";
                        if (player.team && minimapData) {
                            for (let i = 0; i < minimapData.length;) {
                                renderCirclez((minimapData[i] / config.mapScale) * mapDisplay.width
                                              , (minimapData[i + 1] / config.mapScale) * mapDisplay.height, 7, mapContext, true, "rgba(0, 255, 0, 0.35)");
                                i += 2;
                            }
                        }

                        if (mapMarker) {
                            mapContext.fillStyle = "#fff";
                            mapContext.font = "500 34px Montserrat";
                            mapContext.textBaseline = "middle";
                            mapContext.textAlign = "center";
                            mapContext.shadowBlur = 10;
                            mapContext.shadowColor = "#fff";
                            mapContext.fillText("x", (mapMarker.x / config.mapScale) * mapDisplay.width
                                                , (mapMarker.y / config.mapScale) * mapDisplay.height);
                            mapContext.shadowBlur = 0;
                        }
                    }
                }

                let gradient = mapContext.createLinearGradient(0, 0, mapDisplay.width, mapDisplay.height);
                gradient.addColorStop(0, "#1e1e1e");
                gradient.addColorStop(1, "#fff");

                window.addEventListener('keydown', (event) => {
                    if (event.key === 'Tab') {
                        event.preventDefault();
                        mapDisplay.style.width = `1000px`;
                        mapDisplay.style.height = `1000px`;
                        mapDisplay.style.top = '50%';
                        mapDisplay.style.left = '50%';
                        mapDisplay.style.transform = 'translate(-50%, -50%)';
                        mapDisplay.width = 1000;
                        mapDisplay.height = 1000;
                        renderMinimap(0);
                    }
                });

                window.addEventListener('keyup', (event) => {
                    if (event.key === 'Tab') {
                        event.preventDefault();
                        mapDisplay.style.width = `130px`;
                        mapDisplay.style.height = `130px`;
                        mapDisplay.style.top = 'auto';
                        mapDisplay.style.left = '20px';
                        mapDisplay.style.bottom = '20px';
                        mapDisplay.style.transform = 'none';
                        mapDisplay.width = 300;
                        mapDisplay.height = 300;
                        renderMinimap(0);
                    }
                });

                let iconSprites = {};
                let icons = ["crown", "skull"];

                function loadIcons() {
                    for (let i = 0; i < icons.length; ++i) {
                        let tmpSprite = new Image();
                        tmpSprite.onload = function () {
                            this.isLoaded = true;
                        };
                        tmpSprite.src = "./../img/icons/" + icons[i] + ".png";
                        iconSprites[icons[i]] = tmpSprite;
                    }
                }
                loadIcons();

                function cdf(e, t) {
                    return Math.hypot((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
                }

                function updateGame() {
                    if (gameObjects.length && inGame) {
                        gameObjects.forEach((tmp) => {
                            if (UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) <= 1200) {
                                if (!liztobj.includes(tmp)) {
                                    liztobj.push(tmp);
                                    tmp.render = true;
                                }
                            } else {
                                if (liztobj.includes(tmp)) {
                                    if (UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) >= 1200) {
                                        tmp.render = false;
                                        let index = liztobj.indexOf(tmp);
                                        if (index > -1) {
                                            liztobj.splice(index, 1);
                                        }
                                    }
                                } else if (UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) >= 1200) {
                                    tmp.render = false;
                                    let index = liztobj.indexOf(tmp);
                                    if (index > -1) {
                                        liztobj.splice(index, 1);
                                    }
                                } else {
                                    tmp.render = false;
                                    let index = liztobj.indexOf(tmp);
                                    if (index > -1) {
                                        liztobj.splice(index, 1);
                                    }
                                }
                            }
                        })

                    }

                    mainContext.beginPath();
                    mainContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

                    mainContext.globalAlpha = 1;

                    if (player) {
                        if (false) {
                            camX = player.x;
                            camY = player.y;
                        } else {
                            let tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
                            let tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
                            let camSpd = Math.min(tmpDist * 0.0045 * delta, tmpDist);
                            if (tmpDist > 0.05) {
                                camX += camSpd * Math.cos(tmpDir);
                                camY += camSpd * Math.sin(tmpDir);
                            } else {
                                camX = player.x;
                                camY = player.y;
                            }
                        }
                    } else {
                        camX = config.mapScale / 2 + config.riverWidth;
                        camY = config.mapScale / 2;
                    }

                    if (pathFind.active) {
                        if (pathFind.array && (pathFind.chaseNear ? enemy.length : true)) {
                            mainContext.lineWidth = player.scale / 5;
                            mainContext.globalAlpha = 1;
                            mainContext.strokeStyle = "red";
                            mainContext.beginPath();
                            pathFind.array.forEach((path, i) => {
                                let pathXY = {
                                    x: (pathFind.scale / pathFind.grid) * path.x
                                    , y: (pathFind.scale / pathFind.grid) * path.y
                                }
                                let render = {
                                    x: ((player.x2 - (pathFind.scale / 2)) + pathXY.x) - xOffset
                                    , y: ((player.y2 - (pathFind.scale / 2)) + pathXY.y) - yOffset
                                }
                                if (i == 0) {
                                    mainContext.moveTo(render.x, render.y);
                                } else {
                                    mainContext.lineTo(render.x, render.y);
                                }
                            });
                            mainContext.stroke();
                        }
                    }

                    let lastTime = now - (1000 / config.serverUpdateRate);
                    let tmpDiff;
                    for (let i = 0; i < players.length + ais.length; ++i) {
                        tmpObj = players[i] || ais[i - players.length];
                        if (tmpObj && tmpObj.visible) {
                            if (tmpObj.forcePos) {
                                tmpObj.x = tmpObj.x2;
                                tmpObj.y = tmpObj.y2;
                                tmpObj.dir = tmpObj.d2;
                            } else {
                                let total = tmpObj.t2 - tmpObj.t1;
                                let fraction = lastTime - tmpObj.t1;
                                let ratio = (fraction / total);
                                let rate = 170;
                                tmpObj.dt += delta;
                                let tmpRate = Math.min(1.7, tmpObj.dt / rate);
                                tmpDiff = (tmpObj.x2 - tmpObj.x1);
                                tmpObj.x = tmpObj.x1 + (tmpDiff * tmpRate);
                                tmpDiff = (tmpObj.y2 - tmpObj.y1);
                                tmpObj.y = tmpObj.y1 + (tmpDiff * tmpRate);
                                if (config.anotherVisual) {
                                    tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                                } else {
                                    tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                                }
                            }
                        }
                    }

                    let xOffset = camX - (maxScreenWidth / 2);
                    let yOffset = camY - (maxScreenHeight / 2);

                    if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
                        mainContext.fillStyle = "#b6db66";
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
                        mainContext.fillStyle = "#dbc666";
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
                        mainContext.fillStyle = "#fff";
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.snowBiomeTop - yOffset >= 0) {
                        mainContext.fillStyle = "#fff";
                        mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
                        mainContext.fillStyle = "#b6db66";
                        mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth
                                             , maxScreenHeight - (config.snowBiomeTop - yOffset));
                    } else {
                        mainContext.fillStyle = "#b6db66";
                        mainContext.fillRect(0, 0, maxScreenWidth
                                             , (config.mapScale - config.snowBiomeTop - yOffset));
                        mainContext.fillStyle = "#dbc666";
                        mainContext.fillRect(0, (config.mapScale - config.snowBiomeTop - yOffset), maxScreenWidth
                                             , maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
                    }

                    if (!firstSetup) {
                        waterMult += waterPlus * config.waveSpeed * delta;
                        if (waterMult >= config.waveMax) {
                            waterMult = config.waveMax;
                            waterPlus = -1;
                        } else if (waterMult <= 1) {
                            waterMult = waterPlus = 1;
                        }
                        mainContext.globalAlpha = 1;
                        mainContext.fillStyle = "#dbc666";
                        renderWaterBodies(xOffset, yOffset, mainContext, config.riverPadding);
                        mainContext.fillStyle = "#91b2db";
                        renderWaterBodies(xOffset, yOffset, mainContext, (waterMult - 1) * 250);
                    }

                    mainContext.lineWidth = 4;
                    mainContext.strokeStyle = "#000";
                    mainContext.globalAlpha = 0.06;
                    mainContext.beginPath();

                    for (let x = -camX; x < maxScreenWidth; x += 60) {
                        if (x > 0 && isOnScreen(x, maxScreenHeight / 2)) {
                            mainContext.moveTo(x, 0);
                            mainContext.lineTo(x, maxScreenHeight);
                        }
                    }

                    for (let y = -camY; y < maxScreenHeight; y += 60) {
                        if (y > 0 && isOnScreen(maxScreenWidth / 2, y)) {
                            mainContext.moveTo(0, y);
                            mainContext.lineTo(maxScreenWidth, y);
                        }
                    }

                    mainContext.stroke();

                    mainContext.globalAlpha = 1;
                    mainContext.strokeStyle = outlineColor;
                    renderDeadPlayers(xOffset, yOffset);

                    mainContext.globalAlpha = 1;
                    mainContext.strokeStyle = outlineColor;
                    renderGameObjects(-1, xOffset, yOffset);

                    mainContext.globalAlpha = 1;
                    mainContext.lineWidth = outlineWidth;
                    renderProjectiles(0, xOffset, yOffset);

                    renderPlayers(xOffset, yOffset, 0);

                    mainContext.globalAlpha = 1;
                    for (let i = 0; i < ais.length; ++i) {
                        tmpObj = ais[i];
                        if (tmpObj.active && tmpObj.visible) {
                            tmpObj.animate(delta);
                            mainContext.save();
                            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                            mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - (Math.PI / 2));
                            renderAI(tmpObj, mainContext);
                            mainContext.restore();
                        }
                    }

                    renderGameObjects(0, xOffset, yOffset);
                    renderProjectiles(1, xOffset, yOffset);
                    renderGameObjects(1, xOffset, yOffset);
                    renderPlayers(xOffset, yOffset, 1);
                    renderGameObjects(2, xOffset, yOffset);
                    renderGameObjects(3, xOffset, yOffset);

                    mainContext.fillStyle = "#000";
                    mainContext.globalAlpha = 0.09;
                    if (xOffset <= 0) {
                        mainContext.fillRect(0, 0, -xOffset, maxScreenHeight);
                    }
                    if (config.mapScale - xOffset <= maxScreenWidth) {
                        let tmpY = Math.max(0, -yOffset);
                        mainContext.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
                    }
                    if (yOffset <= 0) {
                        mainContext.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset);
                    }
                    if (config.mapScale - yOffset <= maxScreenHeight) {
                        let tmpX = Math.max(0, -xOffset);
                        let tmpMin = 0;
                        if (config.mapScale - xOffset <= maxScreenWidth)
                            tmpMin = maxScreenWidth - (config.mapScale - xOffset);
                        mainContext.fillRect(tmpX, config.mapScale - yOffset
                                             , (maxScreenWidth - tmpX) - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
                    }

                    mainContext.globalAlpha = 1;
                    mainContext.fillStyle = "rgba(0, 0, 70, 0.35)";
                    mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);

                    mainContext.strokeStyle = darkOutlineColor;
                    mainContext.globalAlpha = 1;

                    for (let i = 0; i < players.length + ais.length; ++i) {
                        tmpObj = players[i] || ais[i - players.length];
                        if (tmpObj.visible) {
                            mainContext.strokeStyle = darkOutlineColor;

                            let tmpText = (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (tmpObj.name || ""); + (tmpObj.isPlayer ? " [" + tmpObj.sid + "]" : "");
                            if (tmpText != "") {

                                mainContext.font = "500 " + (tmpObj.nameScale || 30) + "px Montserrat";
                                mainContext.fillStyle = "#fff";
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                mainContext.lineWidth = (tmpObj.nameScale ? 11 : 8);
                                mainContext.lineJoin = "round";
                                mainContext.strokeText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY);
                                mainContext.fillText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY);
                                if (tmpObj.isLeader && iconSprites["crown"].isLoaded) {
                                    let tmpS = config.crownIconScale;
                                    let tmpX = tmpObj.x - xOffset - (tmpS / 2) - (mainContext.measureText(tmpText)
                                                                                  .width / 2) - config.crownPad;
                                    mainContext.drawImage(iconSprites["crown"], tmpX, (tmpObj.y - yOffset - tmpObj.scale) -
                                                          config.nameY - (tmpS / 2) - 5, tmpS, tmpS);
                                }
                                if (tmpObj.iconIndex == 1 && iconSprites["skull"].isLoaded) {
                                    let tmpS = config.crownIconScale;
                                    let tmpX = tmpObj.x - xOffset - (tmpS / 2) + (mainContext.measureText(tmpText)
                                                                                  .width / 2) + config.crownPad;
                                    mainContext.drawImage(iconSprites["skull"], tmpX, (tmpObj.y - yOffset - tmpObj.scale) -
                                                          config.nameY - (tmpS / 2) - 5, tmpS, tmpS);
                                }
                            }

                            if (tmpObj.shameCount > 0) {

                                mainContext.fillStyle = darkOutlineColor;
                                mainContext.roundRect(
                                    tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad
                                    , (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 19
                                    , (config.healthBarWidth * 2) + (config.healthBarPad * 2)
                                    , 17
                                    , 8
                                );
                                mainContext.fill();

                                mainContext.fillStyle = "#aa0000";
                                mainContext.roundRect(
                                    tmpObj.x - xOffset - config.healthBarWidth
                                    , (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 19 + config.healthBarPad
                                    , ((config.healthBarWidth * 2) * (tmpObj.shameCount / 8))
                                    , 17 - config.healthBarPad * 2
                                    , 7
                                );
                                mainContext.fill();
                            }
                            if (tmpObj.health > 0) {

                                mainContext.fillStyle = darkOutlineColor;
                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad
                                                      , (tmpObj.y - yOffset + tmpObj.scale) + config.nameY, (config.healthBarWidth * 2) +
                                                      (config.healthBarPad * 2), 17, 8);
                                mainContext.fill();

                                mainContext.fillStyle = (tmpObj == player || (tmpObj.team && tmpObj.team == player.team)) ? "#8ecc51" : "#cc5151";
                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth
                                                      , (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad
                                                      , ((config.healthBarWidth * 2) * (tmpObj.health / tmpObj.maxHealth)), 17 - config.healthBarPad * 2, 7);
                                mainContext.fill();

                                if (tmpObj.isPlayer) {
                                    mainContext.globalAlpha = 1;
                                    let targetReloads = {
                                        primary: (tmpObj.primaryIndex == undefined ? 1 : ((items.weapons[tmpObj.primaryIndex].speed - tmpObj.reloads[tmpObj.primaryIndex]) / items.weapons[tmpObj.primaryIndex].speed))
                                        , secondary: (tmpObj.secondaryIndex == undefined ? 1 : ((items.weapons[tmpObj.secondaryIndex].speed - tmpObj.reloads[tmpObj.secondaryIndex]) / items.weapons[tmpObj.secondaryIndex].speed))
                                        , turret: (2500 - tmpObj.reloads[53]) / 2500
                                    };
                                    if (!tmpObj.currentReloads) {
                                        tmpObj.currentReloads = {
                                            primary: targetReloads.primary
                                            , secondary: targetReloads.secondary
                                            , turret: targetReloads.turret
                                        };
                                    }

                                    if (getEl("predictType")
                                        .value == "pre2") {
                                        mainContext.lineWidth = 3;
                                        mainContext.strokeStyle = "#fff";
                                        mainContext.globalAlpha = 1;
                                        mainContext.beginPath();
                                        let render = {
                                            x: tmpObj.x2 - xOffset
                                            , y: tmpObj.y2 - yOffset
                                        };
                                        mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                        mainContext.lineTo(render.x, render.y);
                                        mainContext.stroke();
                                    } else if (getEl("predictType")
                                               .value == "pre3") {
                                        mainContext.lineWidth = 3;
                                        mainContext.strokeStyle = "#cc5151";
                                        mainContext.globalAlpha = 1;
                                        mainContext.beginPath();
                                        let render = {
                                            x: tmpObj.x3 - xOffset
                                            , y: tmpObj.y3 - yOffset
                                        };
                                        mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                        mainContext.lineTo(render.x, render.y);
                                        mainContext.stroke();
                                    }

                                }
                            }
                        }
                    }

                    if (player) {

                        if (my.autoPush) {
                            mainContext.lineWidth = 5;
                            mainContext.globalAlpha = 1;
                            mainContext.beginPath();

                            mainContext.strokeStyle = "#ff0000";
                            mainContext.shadowBlur = 10;
                            mainContext.shadowColor = "#ff0000";

                            mainContext.moveTo(player.x - xOffset, player.y - yOffset);
                            mainContext.lineTo(my.pushData.x2 - xOffset, my.pushData.y2 - yOffset);
                            mainContext.lineTo(my.pushData.x - xOffset, my.pushData.y - yOffset);
                            mainContext.stroke();

                            mainContext.shadowBlur = 0;
                            mainContext.shadowColor = "transparent";
                        }

                        mainContext.globalAlpha = 1;
                    }

                    textManager.update(delta, mainContext, xOffset, yOffset);

                    for (let i = 0; i < players.length; ++i) {
                        tmpObj = players[i];
                        if (tmpObj.visible) {
                            if (tmpObj.chatCountdown > 0) {
                                tmpObj.chatCountdown -= delta;
                                if (tmpObj.chatCountdown <= 0)
                                    tmpObj.chatCountdown = 0;
                                mainContext.font = "500 32px Montserrat";
                                let tmpSize = mainContext.measureText(tmpObj.chatMessage);
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                let tmpX = tmpObj.x - xOffset;
                                let tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                                let tmpH = 47;
                                let tmpW = tmpSize.width + 17;
                                mainContext.fillStyle = "rgba(0,0,0,0.2)";
                                mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                                mainContext.fill();
                                mainContext.fillStyle = "#fff";
                                mainContext.fillText(tmpObj.chatMessage, tmpX, tmpY);
                            }
                            if (tmpObj.chat.count > 0) {
                                if (!useWasd) {
                                    tmpObj.chat.count -= delta;
                                    if (tmpObj.chat.count <= 0)
                                        tmpObj.chat.count = 0;
                                    mainContext.font = "500 32px Montserrat";
                                    let tmpSize = mainContext.measureText(tmpObj.chat.message);
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    let tmpX = tmpObj.x - xOffset;
                                    let tmpY = tmpObj.y - tmpObj.scale - yOffset + (90 * 2);
                                    let tmpH = 47;
                                    let tmpW = tmpSize.width + 17;
                                    mainContext.fillStyle = "rgba(0,0,0,0.2)";
                                    mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                                    mainContext.fill();
                                    mainContext.fillStyle = "#ffffff99";
                                    mainContext.fillText(tmpObj.chat.message, tmpX, tmpY);
                                } else {
                                    tmpObj.chat.count = 0;
                                }
                            }
                        }
                    }

                    if (allChats.length) {
                        allChats.filter(ch => ch.active)
                            .forEach((ch) => {
                            if (!ch.alive) {
                                if (ch.alpha <= 1) {
                                    ch.alpha += delta / 250;
                                    if (ch.alpha >= 1) {
                                        ch.alpha = 1;
                                        ch.alive = true;
                                    }
                                }
                            } else {
                                ch.alpha -= delta / 5000;
                                if (ch.alpha <= 0) {
                                    ch.alpha = 0;
                                    ch.active = false;
                                }
                            }
                            if (ch.active) {
                                mainContext.font = "20px Ubuntu";
                                let tmpSize = mainContext.measureText(ch.chat);
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                let tmpX = ch.x - xOffset;
                                let tmpY = ch.y - yOffset - 90;
                                let tmpH = 40;
                                let tmpW = tmpSize.width + 15;

                                mainContext.globalAlpha = ch.alpha;

                                mainContext.fillStyle = ch.owner.isTeam(player) ? "#8ecc51" : "#cc5151";
                                mainContext.strokeStyle = "rgb(25, 25, 25)";
                                mainContext.strokeText(ch.owner.name, tmpX, tmpY - 45);
                                mainContext.fillText(ch.owner.name, tmpX, tmpY - 45);

                                mainContext.lineWidth = 5;
                                mainContext.fillStyle = "#ccc";
                                mainContext.strokeStyle = "rgb(25, 25, 25)";

                                mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                                mainContext.stroke();
                                mainContext.fill();

                                mainContext.fillStyle = "#fff";
                                mainContext.strokeStyle = "#000";
                                mainContext.strokeText(ch.chat, tmpX, tmpY);
                                mainContext.fillText(ch.chat, tmpX, tmpY);
                                ch.y -= delta / 100;
                            }
                        });
                    }

                    mainContext.globalAlpha = 1;

                    renderMinimap(delta);
                }

                window.requestAnimFrame = function () {
                    return null;
                }
                window.rAF = (function () {
                    return window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        function (callback) {
                        window.setTimeout(callback, 1000 / 9);
                    };
                })();

                function doUpdate() {

                    now = performance.now();
                    delta = now - lastUpdate;
                    lastUpdate = now;
                    let timer = performance.now();
                    let diff = timer - fpsTimer.last;
                    if (diff >= 1000) {

                        fpsTimer.ltime = fpsTimer.time * (1000 / diff);

                        fpsTimer.last = timer;
                        fpsTimer.time = 0;
                    }
                    fpsTimer.time++;

                    updateGame();
                    rAF(doUpdate);
                    ms.avg = Math.round((ms.min + ms.max) / 2);
                }

                prepareMenuBackground();
                doUpdate();

                let changeDays = {};

                window.debug = function () {
                    my.waitHit = 0;
                    my.autoAim = false;
                    instaC.isTrue = false;
                    traps.inTrap = false;
                    itemSprites = [];
                    objSprites = [];
                    gameObjectSprites = [];
                };

                window.wasdMode = function () {
                    useWasd = !useWasd;
                };

                window.startGrind = function () {
                    if (getEl("weaponGrind")
                        .checked) {
                        for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                            checkPlace(player.getItemType(22), i);
                        }
                    }
                };

                window.resBuild = function () {
                    if (gameObjects.length) {
                        gameObjects.forEach((tmp) => {
                            tmp.breakObj = false;
                        });
                        breakObjects = [];
                    }
                };

                window.prepareUI = function (tmpObj) {
                    resize();

                    let chatBox = document.getElementById("chatBox");
                    let chatHolder = document.getElementById("chatHolder");
                    let prevChats = [];
                    let prevChatsIndex = 0;

                    function toggleChat() {
                        if (!usingTouch) {
                            if (chatHolder.style.display == "block") {
                                if (chatBox.value) {
                                    sendChat(chatBox.value);
                                }
                                closeChat();
                            } else {
                                storeMenu.style.display = "none";
                                allianceMenu.style.display = "none";
                                chatHolder.style.display = "block";
                                chatBox.focus();
                                resetMoveDir();
                            }
                        } else {
                            setTimeout(function () {
                                let chatMessage = prompt("chat message");
                                if (chatMessage) {
                                    sendChat(chatMessage);
                                }
                            }, 1);
                        }
                        chatBox.value = "";
                        (() => {
                            prevChatsIndex = 0;
                        })();
                    }

                    function closeChat() {
                        chatBox.value = "";
                        chatHolder.style.display = "none";
                    }

                    UTILS.removeAllChildren(actionBar);

                    for (let i = 0; i < (items.weapons.length + items.list.length); ++i) {
                        (function (i) {
                            UTILS.generateElement({
                                id: "actionBarItem" + i
                                , class: "actionBarItem"
                                , style: "display:none;"
                                , onmouseout: function () {
                                    showItemInfo();
                                }
                                , parent: actionBar
                            });
                        })(i);
                    }

                    for (let i = 0; i < (items.list.length + items.weapons.length); ++i) {
                        (function (i) {
                            let tmpCanvas = document.createElement("canvas");
                            tmpCanvas.width = tmpCanvas.height = 66;
                            let tmpContext = tmpCanvas.getContext("2d");
                            tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                            tmpContext.imageSmoothingEnabled = false;
                            tmpContext.webkitImageSmoothingEnabled = false;
                            tmpContext.mozImageSmoothingEnabled = false;

                            if (items.weapons[i]) {
                                tmpContext.rotate((Math.PI / 4) + Math.PI);
                                let tmpSprite = new Image();
                                toolSprites[items.weapons[i].src] = tmpSprite;
                                tmpSprite.onload = function () {
                                    this.isLoaded = true;
                                    let tmpPad = 1 / (this.height / this.width);
                                    let tmpMlt = (items.weapons[i].iPad || 1);
                                    tmpContext.drawImage(this, -(tmpCanvas.width * tmpMlt * config.iconPad * tmpPad) / 2, -(tmpCanvas.height * tmpMlt * config.iconPad) / 2
                                                         , tmpCanvas.width * tmpMlt * tmpPad * config.iconPad, tmpCanvas.height * tmpMlt * config.iconPad);
                                    tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                                    tmpContext.globalCompositeOperation = "source-atop";
                                    tmpContext.fillRect(-tmpCanvas.width / 2, -tmpCanvas.height / 2, tmpCanvas.width, tmpCanvas.height);
                                    getEl('actionBarItem' + i)
                                        .style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                                };
                                tmpSprite.src = "./../img/weapons/" + items.weapons[i].src + ".png";
                                let tmpUnit = getEl('actionBarItem' + i);
                                tmpUnit.onmouseover = UTILS.checkTrusted(function () {
                                    showItemInfo(items.weapons[i], true);
                                });
                                tmpUnit.onclick = UTILS.checkTrusted(function () {
                                    selectWeapon(tmpObj.weapons[items.weapons[i].type]);
                                });
                                UTILS.hookTouchEvents(tmpUnit);
                            } else {
                                let tmpSprite = getItemSprite(items.list[i - items.weapons.length], true);
                                let tmpScale = Math.min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                                tmpContext.globalAlpha = 1;
                                tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                                tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                                tmpContext.globalCompositeOperation = "source-atop";
                                tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                                getEl('actionBarItem' + i)
                                    .style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                                let tmpUnit = getEl('actionBarItem' + i);
                                tmpUnit.onmouseover = UTILS.checkTrusted(function () {
                                    showItemInfo(items.list[i - items.weapons.length]);
                                });
                                tmpUnit.onclick = UTILS.checkTrusted(function () {
                                    selectToBuild(tmpObj.items[tmpObj.getItemType(i - items.weapons.length)]);
                                });
                                UTILS.hookTouchEvents(tmpUnit);
                            }
                        })(i);
                    }
                };
            }(1)
        }
        const x38x849xc = '0d16c4238b5a3df2c575a731f6fc439de4c4a780be80aeb4a383b86850e2f4d0';

        if (localStorage.getItem(oeferrg9 + oerg9 + oefer043vrg9 + wef094j9) === 'true') {
            document.getElementById('redEliteSecurity').style.display = 'none';
            runMod();
        } else {
            document.getElementById('redEliteSecurity').style.display = 'flex';
        }
    } else {
        console.log('!!! EXISTENCE IS FAKE AND WE ALL ARE MADE FOR FUN !!!');
        alert('!!! EXISTENCE IS FAKE AND WE ALL ARE MADE FOR FUN !!!');
    }
})();