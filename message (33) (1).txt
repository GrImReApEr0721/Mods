// ==UserScript==
// @name         Uno Client Priv VERSION made by sad
// @icon         https://th.bing.com/th/id/OIP.j15LI5yTQdOiGPKOVWJeWQHaFj?rs=1&pid=ImgDetMain
// @match        *://*.moomoo.io/*
// @run-at       document_start
// @grant        none
// @version      v0.1
// @description  Keep it Obfstucated best for everyone!
// @author       sad
// ==/UserScript==

/* Normal Mode Has macros(DELETED)
boostspike
double spiketick
spiketick
squad place(trap)

MEMBERS:
Zylex
Mia
Margot
*/
// TEAMSYNC:
function isTeamMember(a){
    if(player.team && a != player && a.team == player.team){
        return true;
    } else {
        return false;
    }
}
let whereverifybutton = document.querySelector("#altcha_checkbox")
function clicktheverify() {
    if (whereverifybutton) {
        whereverifybutton.click()
    }
}

setInterval(clicktheverify, 10);
function ShowSettingTextRed(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#FF0000");
}
function ShowSettingTextGreen(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#00FF00");
}
function ShowSettingTextBlue(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#0000FF");
}
function ShowSettingTextYellow(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#FFFF00");
}
function ShowSettingTextPurple(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#FF00FF");
}
function ShowSettingTextCyan(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#00FFFF");
}
function ShowSettingTextWhite(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#FFFFFF");
}
function ShowSettingTextBlack(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#000000");
}
function ShowSettingTextOrange(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#FFA500");
}
function ShowSettingTextPink(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#FFC0CB");
}
function ShowSettingTextGrey(life, setting) {
    textManager.showText(player.x, player.y, player.scale, 0.1, life, setting, "#808080");
}
// TEAMSYNC:
function isTeamMember(a){
    if(player.team && a != player && a.team == player.team){
        return true;
    } else {
        return false;
    }
}

// Know If Teamate:
function isTeam(tmpObj) {
    return (tmpObj == player || (tmpObj.team && tmpObj.team == player.team));
}
function cdf (e, t){
    try {
        return Math.hypot((t.y2||t.y)-(e.y2||e.y), (t.x2||t.x)-(e.x2||e.x));
    } catch(e){
        return Infinity;
    }
}

document.getElementById("wideAdCard").remove();
document.getElementById("partyButton").remove();
document.getElementById("joinPartyButton").remove();

document.getElementById("linksContainer2").remove();
document.getElementById("mainMenu").style.backgroundImage = "url('https://media.discordapp.net/attachments/1297207987177390113/1331652145895837727/image.png?ex=67926534&is=679113b4&hm=5e0235f0dbca59df1529de4cd859a52e9dda3b433a98aa63a6afc6a97aa08926&=&format=webp&quality=lossless&width=742&height=525')";
document.getElementById("gameName").style.font = "120px  zamruds";

document.getElementById("gameName").style.textShadow = "0px 0px 10px rgba(255, 255, 255, 1)"; // Используем rgba для задания прозрачного голубого цвета
document.getElementById('gameName').style.marginTop = '-200px';
document.getElementById('gameName').innerHTML = 'Uno Reversed';


let founda = false;
let testMode = window.location.hostname == "127.0.0.1";

let scriptTags = document.getElementsByTagName("script");
for (let i = 0; i < scriptTags.length; i++) {
    if (scriptTags[i].src.includes("index-f3a4c1ad.js") && !founda) {
        scriptTags[i].remove();
        founda = true;
        break;
    }
}


document.addEventListener("keydown", function(event) {
    if (event.keyCode === 192) {
        const chatHolder = document.getElementById("gameUI");
        if (chatHolder) {
            const currentDisplay = chatHolder.style.display;
            chatHolder.style.display = currentDisplay === "none" ? "block" : "none";
        }
    }
});
var styleItem = document.createElement("style");
styleItem.type = "text/css";
styleItem.appendChild(document.createTextNode(`
#suggestBox {
    width: 355px;
    border-radius: 3px;
    background-color: rgba(0,0,0,0.5);
    margin: auto;
    text-align: left;
    z-index: 49;
    pointer-events: auto;
    position: relative;
    bottom: 3.5px;
    overflow-y: auto;
}
#suggestBox div {
    background-color: rgba(255,255,255,0);
    color: rgba(255,255,255,1);
    transition: background-color 0.3s, color 0.3s;
}
#suggestBox div:hover {
    background-color: rgba(255,255,255,0.2);
    color: rgba(0,0,0,1);
}
.suggestBoxHard {
    color: rgba(255,255,255,1);
    font-size: 18px;
}
.suggestBoxLight {
    color: rgba(255,255,255,0.7);
    font-size: 18px;
}
`));
document.head.appendChild(styleItem);

window.addEventListener('load', function() {
    var allianceButton = document.getElementById('allianceButton');
    var storeButton = document.getElementById('storeButton');
    if (storeButton) {
        storeButton.style.right = '26px';
        storeButton.style.top = '420px';
    }
    if (allianceButton) {
        allianceButton.style.right = '26px';
        allianceButton.style.top = '479px';
    }
});

function getEl(id) {
    return document.getElementById(id);
}

let newFont = document.createElement("link");
newFont.rel = "stylesheet";
newFont.href = "https://fonts.googleapis.com/css?family=Ubuntu:700";
newFont.type = "text/css";
document.body.append(newFont);

let min = document.createElement("script");
min.src = "https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js";
document.body.append(min);
window.oncontextmenu = function() {
    return false;
};
let autoOneFrameToggled = false;
const {
    sin,
    cos,
    sqrt,

} = Math;
let config = window.config;

// CLIENT:
config.clientSendRate = 9; // Aim Packet Send Rate
config.serverUpdateRate = 9;

// UI:
config.deathFadeout = 0;

config.playerCapacity = 9999;

// CHECK IN SANDBOX:
config.isSandbox = window.location.hostname == "sandbox.moomoo.io";

// CUSTOMIZATION:
config.skinColors = ["#bf8f54", "#cbb091", "#896c4b",
                     "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3",
                     "#8bc373", "#91b2db"
                    ];
config.weaponVariants = [{
    id: 0,
    src: "",
    xp: 0,
    val: 1,
}, {
    id: 1,
    src: "_g",
    xp: 3000,
    val: 1.1,
}, {
    id: 2,
    src: "_d",
    xp: 7000,
    val: 1.18,
}, {
    id: 3,
    src: "_r",
    poison: true,
    xp: 12000,
    val: 1.18,
}, {
    id: 4,
    src: "_e",
    poison: true,
    heal: true,
    xp: 24000,
    val: 1.18,
}];

// VISUAL:
config.anotherVisual = true;
config.useWebGl = false;
config.resetRender = true;

function waitTime(timeout) {
    return new Promise((done) => {
        setTimeout(() => {
            done();
        }, timeout);
    });
}

let botSkts = [];

// STORAGE:
let canStore;
if (typeof(Storage) !== "undefined") {
    canStore = true;
}

function saveVal(name, val) {
    if (canStore)
        localStorage.setItem(name, val);
}

function deleteVal(name) {
    if (canStore)
        localStorage.removeItem(name);
}

function getSavedVal(name) {
    if (canStore)
        return localStorage.getItem(name);
    return null;
}

// CONFIGS:
let gC = function(a, b) {
    try {
        let res = JSON.parse(getSavedVal(a));
        if (typeof res === "object") {
            return b;
        } else {
            return res;
        }
    } catch (e) {
        alert("dieskid");
        return b;
    }
};

function setCommands() {
    return {
        "help": {
            desc: "Show Commands",
            action: function(message) {
                for (let cmds in commands) {
                    addMenuChText("/" + cmds, commands[cmds].desc, "lime", 1);
                }
            }
        },
        "clear": {
            desc: "Clear Chats",
            action: function(message) {
                resetMenuChText();
            }
        },
        "debug": {
            desc: "Debug Mod For Development",
            action: function(message) {
                addDeadPlayer(player);
                addMenuChText("Debug", "Done", "#99ee99", 1);
            }
        },
        "play": {
            desc: "Play Music ( /play [link] )",
            action: function(message) {
                let link = message.split(" ");
                if (link[1]) {
                    let audio = new Audio(link[1]);
                    audio.play();
                } else {
                    addMenuChText("Warn", "Enter Link ( /play [link] )", "#99ee99", 1);
                }
            }
        },
        "bye": {
            desc: "Leave Game",
            action: function(message) {
                window.leave();
            }
        },
    };
}

function setConfigs() {
    return {
    };
}

let commands = setCommands();
let configs = setConfigs();

window.removeConfigs = function() {
    for (let cF in configs) {
        deleteVal(cF, configs[cF]);
    }
};

for (let cF in configs) {
    configs[cF] = gC(cF, configs[cF]);
}

// MENU FUNCTIONS:
window.changeMenu = function() {};
window.debug = function() {};
window.freezePlayer = function() {};
window.wasdMode = function() {};

// PAGE 1:
window.startGrind = function() {};

// PAGE 3:
window.resBuild = function() {};
window.toggleVisual = function() {};

// SOME FUNCTIONS:
window.prepareUI = function() {};
window.leave = function() {};

// nah hahahahahhh why good ping
window.ping = 0;

class deadfuturechickenmodrevival {
    constructor(flarez, lore) {
        this.inGame = false;
        this.lover = flarez + lore;
        this.baby = "ae86";
        this.isBlack = 0;
        this.webSocket = undefined;
        this.checkBaby = function() {
            this.baby !== "ae86" ? this.isBlack++ : this.isBlack--;
            if (this.isBlack >= 1) return "bl4cky";
            return "noting for you";
        };
        this.x2 = 0;
        this.y2 = 0;
        this.chat = "Imagine playing this badass game XDDDDD";
        this.summon = function(tmpObj) {
            this.x2 = tmpObj.x;
            this.y2 = tmpObj.y;
            this.chat = tmpObj.name + " ur so bad XDDDD";
        };
        this.commands = function(cmd) {
            cmd == "rv3link" && window.open("https://florr.io/");
            cmd == "woah" && window.open("https://www.youtube.com/watch?v=MO0AGukzj6M");
            return cmd;
        };
        this.dayte = "11yearold";
        this.memeganoob = "69yearold";
        this.startDayteSpawn = function(tmpObj) {
            let ratio = setInterval(() => {
                this.x2 = tmpObj.x + 20;
                this.y2 = tmpObj.y - 20;
                this.chat = "UR SO BAD LOL";
                if (tmpObj.name == "ae86") {
                    this.chat = "omg ae86 go run";
                    setTimeout(() => {
                        this.inGame = false;
                        clearInterval(ratio);
                    }, 1000);
                }
            }, 1234);
        };
        this.AntiChickenModV69420 = function(tmpObj) {
            return "!c!dc user " + tmpObj.name;
        };
    }
};
class HtmlAction {
    constructor(element) {
        this.element = element;
    };
    add(code) {
        if (!this.element) return undefined;
        this.element.innerHTML += code;
    };
    newLine(amount) {
        let result = `<br>`;
        if (amount > 0) {
            result = ``;
            for (let i = 0; i < amount; i++) {
                result += `<br>`;
            }
        }
        this.add(result);
    };
    checkBox(setting) {
        let newCheck = `<input type = "checkbox"`;
        setting.id && (newCheck += ` id = ${setting.id}`);
        setting.style && (newCheck += ` style = ${setting.style.replaceAll(" ", "")}`);
        setting.class && (newCheck += ` class = ${setting.class}`);
        setting.checked && (newCheck += ` checked`);
        setting.onclick && (newCheck += ` onclick = ${setting.onclick}`);
        newCheck += `>`;
        this.add(newCheck);
    };
    text(setting) {
        let newText = `<input type = "text"`;
        setting.id && (newText += ` id = ${setting.id}`);
        setting.style && (newText += ` style = ${setting.style.replaceAll(" ", "")}`);
        setting.class && (newText += ` class = ${setting.class}`);
        setting.size && (newText += ` size = ${setting.size}`);
        setting.maxLength && (newText += ` maxLength = ${setting.maxLength}`);
        setting.value && (newText += ` value = ${setting.value}`);
        setting.placeHolder && (newText += ` placeHolder = ${setting.placeHolder.replaceAll(" ", "&nbsp;")}`);
        newText += `>`;
        this.add(newText);
    };
    select(setting) {
        let newSelect = `<select`;
        setting.id && (newSelect += ` id = ${setting.id}`);
        setting.style && (newSelect += ` style = ${setting.style.replaceAll(" ", "")}`);
        setting.class && (newSelect += ` class = ${setting.class}`);
        newSelect += `>`;
        for (let options in setting.option) {
            newSelect += `<option value = ${setting.option[options].id}`
            setting.option[options].selected && (newSelect += ` selected`);
            newSelect += `>${options}</option>`;
        }
        newSelect += `</select>`;
        this.add(newSelect);
    };
    button(setting) {
        let newButton = `<button`;
        setting.id && (newButton += ` id = ${setting.id}`);
        setting.style && (newButton += ` style = ${setting.style.replaceAll(" ", "")}`);
        setting.class && (newButton += ` class = ${setting.class}`);
        setting.onclick && (newButton += ` onclick = ${setting.onclick}`);
        newButton += `>`;
        setting.innerHTML && (newButton += setting.innerHTML);
        newButton += `</button>`;
        this.add(newButton);
    };
    selectMenu(setting) {
        let newSelect = `<select`;
        if (!setting.id) {
            alert("please put id skid");
            return;
        }
        window[setting.id + "Func"] = function() {};
        setting.id && (newSelect += ` id = ${setting.id}`);
        setting.style && (newSelect += ` style = ${setting.style.replaceAll(" ", "")}`);
        setting.class && (newSelect += ` class = ${setting.class}`);
        newSelect += ` onchange = window.${setting.id + "Func"}()`;
        newSelect += `>`;
        let last;
        let i = 0;
        for (let options in setting.menu) {
            newSelect += `<option value = ${"option_" + options} id = ${"O_" + options}`;
            setting.menu[options] && (newSelect += ` checked`);
            newSelect += ` style = "color: ${setting.menu[options] ? "#000" : "#fff"}; background: ${setting.menu[options] ? "#8ecc51" : "#cc5151"};">${options}</option>`;
            i++;
        }
        newSelect += `</select>`;

        this.add(newSelect);

        i = 0;
        for (let options in setting.menu) {
            window[options + "Func"] = function() {
                setting.menu[options] = getEl("check_" + options).checked ? true : false;
                saveVal(options, setting.menu[options]);

                getEl("O_" + options).style.color = setting.menu[options] ? "#000" : "#fff";
                getEl("O_" + options).style.background = setting.menu[options] ? "#8ecc51" : "#cc5151";

                //getEl(setting.id).style.color = setting.menu[options] ? "#8ecc51" : "#cc5151";

            };
            this.checkBox({
                id: "check_" + options,
                style: `display: ${i == 0 ? "inline-block" : "none"};`,
                class: "checkB",
                onclick: `window.${options + "Func"}()`,
                checked: setting.menu[options]
            });
            i++;
        }

        last = "check_" + getEl(setting.id).value.split("_")[1];
        window[setting.id + "Func"] = function() {
            getEl(last).style.display = "none";
            last = "check_" + getEl(setting.id).value.split("_")[1];
            getEl(last).style.display = "inline-block";

            //getEl(setting.id).style.color = setting.menu[last.split("_")[1]] ? "#8ecc51" : "#fff";

        };
    };
};
class Html {
    constructor() {
        this.element = null;
        this.action = null;
        this.divElement = null;
        this.startDiv = function(setting, func) {

            let newDiv = document.createElement("div");
            setting.id && (newDiv.id = setting.id);
            setting.style && (newDiv.style = setting.style);
            setting.class && (newDiv.className = setting.class);
            this.element.appendChild(newDiv);
            this.divElement = newDiv;

            let addRes = new HtmlAction(newDiv);
            typeof func == "function" && func(addRes);

        };
        this.addDiv = function(setting, func) {

            let newDiv = document.createElement("div");
            setting.id && (newDiv.id = setting.id);
            setting.style && (newDiv.style = setting.style);
            setting.class && (newDiv.className = setting.class);
            setting.appendID && getEl(setting.appendID).appendChild(newDiv);
            this.divElement = newDiv;

            let addRes = new HtmlAction(newDiv);
            typeof func == "function" && func(addRes);

        };
    };
    set(id) {
        this.element = getEl(id);
        this.action = new HtmlAction(this.element);
    };
    resetHTML(text) {
        if (text) {
            this.element.innerHTML = ``;
        } else {
            this.element.innerHTML = ``;
        }
    };
    setStyle(style) {
        this.element.style = style;
    };
    setCSS(style) {
        this.action.add(`<style>` + style + `</style>`);
    };
};
// MENU
let UnoReverse = document.createElement("div");
UnoReverse.id = 'UnoReverse';
UnoReverse.classList.add('menu-container');
UnoReverse.style = `
  opacity: 0;
  display: none;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(8px);
  border-radius: 15px;
  position: absolute;
  top: 45%;
  left: 50%;
  margin: -250px 0 0 -375px;
  width: 765px;
  height: 460px;
`;
UnoReverse.innerHTML = `
  <style>
    .menu-container {
      animation: glow 1.5s ease-in-out infinite alternate;
    }
    @keyframes glow {
      from {
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);
      }
      to {
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(255, 255, 255, 0.7);
      }
    }
   /* Checkbox styles */
   input[type="checkbox"] {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    width: 35px;
    height: 20px;
    border-radius: 50px;
    background: rgba(0, 0, 0, 0.3);
    box-shadow: inset 0 0 5px rgba(41, 41, 41, 0.5);
    cursor: pointer;
    position: relative;
    left: -5px;
    transition: background-color 0.4s;
    margin-bottom: -4px
}

input:checked[type="checkbox"] {
    background: #4CAF50;
}

input[type="checkbox"]::after {
    content: "";
    position: absolute;
    top: 50%;
    left: 3px;
    transform: translateY(-50%);
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #ffffff;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    transition: left 0.4s;
}

input:checked[type="checkbox"]::after {
    left: calc(100% - 17px);
}
#sidebar {
    position: absolute;
    left: 5px;
    top: 5px;
    width: 200px;
    height: calc(100% - 30px);
    background-color: rgba(7, 7, 7, 0.5);
    color: #ffffff;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
}
#mainmenu {
  position: fixed;
  left: 235px;
  top: 5px;
  width: 525px;
  height: calc(100% - 30px);
  background-color: rgba(7, 7, 7, 0.3);
  color: #ffffff;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  display: flex;
  overflow-y: auto;
}
#mainmenu {
  scrollbar-width: none;
}
#mainmenu::-webkit-scrollbar {
  display: none;
}

.tab-box {
  width: 170px;
  height: 50px;
  background-color: rgba(0, 0, 0, 0.1);
  border: 0px solid rgba(0, 0, 0, 0.1);
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 20px;
  display: flex;
  justify-content: center;
  align-items: center;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.2);
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  cursor: pointer;
  font-size: 20px;
}

.tab-box:hover {
  transform: scale(1.03);
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.8), inset 0 0 8px rgba(255, 255, 255, 0.3);
}

.tab-box.selected {
  transform: scale(1.05);
  box-shadow: 0 0 20px rgba(255, 255, 255, 1), inset 0 0 10px rgba(255, 255, 255, 0.5);
  background-color: rgba(255, 255, 255, 0.1);
  font-size: 22px;
}


.styled-select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-color: rgba(0, 0, 0, 0.3);
    color: #ffffff;
    padding: 8px 12px;
    font-size: 13px;
    border-radius: 15px;
    width: auto+40px;
    height: 30px;
    margin-bottom: 5px;
    border: none;
    outline: none;
    text-align-last: center;
}
.styled-select option {
    background-color: rgba(0, 0, 0, 0.5);
    color: #ffffff;
}

.styled-select:hover, .styled-select:focus {
    background-color: rgba(0, 0, 0, 0.7);
    color: #ffffff;
}
.customText {
    color: #fff;
    background-color: #2c3e50;
    border: 1px solid #444; /* Dark border color */
    border-radius: 8px; /* Rounded corners */
    padding: 8px;
    transition: background-color 0.3s ease;
}

.customText:focus {
    background-color: #333; /* Darker focus color */
}
.slidecontainer {
  width: 100%; /* Width of the outside container */
}

/* The slider itself */
.slider {
  -webkit-appearance: none;  /* Override default CSS styles */
  appearance: none;
  width: 100%; /* Full-width */
  height: 25px; /* Specified height */
  background: #d3d3d3; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: .2s; /* 0.2 seconds transition on hover */
  transition: opacity .2s;
}

/* Mouse-over effects */
.slider:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.slider::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}

.slider::-moz-range-thumb {
  width: 25px; /* Set a specific slider handle width */
  height: 20px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}

  </style>
  <div id = "sidebar">
    <div id = "headline" style="font-size: 25px; color: #b3b3b3;">
       <div style="text-align: center; font-size: 25px; margin-bottom: -40px;">`+GM_info.script.name +" "+ GM_info.script.version +`</div>
      <br><br>
      <div class = "tab-box" selected id = "combat">Combat</div>
      <div class = "tab-box" id = "visual">Visuals</div>
      <div class = "tab-box" id = "misc">Misc/Other</div>
    </div>
    Dev: Zylex

  </div>
<div id = "mainmenu">
    <div id = "Combat" style = "display: block; font-size: 20px;">
        Placements Settings:
        <br>
        <input type = "checkbox" checked id = "Autoplace">
        AutoPlace
        <br>
        <input type = "checkbox" id = "Retrap">
        Retrap
        <br>
        <input type = "checkbox" checked id = "autoPush">
        autoPush
        <br>
        <input type = "checkbox" checked id = "revTick">
        Rev Insta
        <br>
        <input type = "checkbox" checked id = "predictTick">
        predictTick
        <br>
        <input type = "checkbox" checked id = "slowOT">
        Slow OneTick
        <br>
        <input type = "checkbox" checked id = "doSpikeOnReverse">
        ReverseSpikeTick
        <br>
        <input type = "checkbox" checked id = "antiTrap">
        antiTrap
        <br>
        autoPlacetype:
        <select id="autoPlacetype" class="styled-select">
         <option value="smart">smart/oneshot</option>
         <option value="magicplace">magicplace</option>
         <option value="aiplace">aiplace</option>
         <option value="spamtrap">spamtrap</option>
         <option value="spamtrap2">spamtrap2</option>
         <option value="ramdomplc">Honor</option>
         <option selected value="GoodAngle">Bestplace</option>
        </select>
        <br>
        <input type = "checkbox" checked id = "Replace">
        RePlacer
        <br>
        <input type = "checkbox" checked id = "Preplace">
        PrePlacer
        <br>
        InstaType:
        <select id="instaType" class="styled-select">
         <option value="OneShot">Morning/oneshot</option>
         <option selected value="spammer">spammer</option>
        </select>
        <br>
        AntiBullType:
        <select id="antiBullType" class="styled-select">
         <option selected value="noab">Disable/oneshot</option>
         <option value="abreload">Hit SpikeGear</option>
         <option value="abalway">SpikeGear</option>
        </select>
        <br>
        Main Settings:
        <br>
        <input type = "checkbox" checked id = "healingBeta">
        AutoHeal
        <br>
        Other:
        <br>
        <input type = "checkbox" checked id = "antikick">
        AntiKick
        <br>
        <input type = "checkbox" checked id = "safeAntiSpikeTick">
        safeAntiSpikeTick
        <br>
        <input type = "checkbox" checked id = "turretCombat">
        turretCombat
        <br>
        <input type = "checkbox" checked id = "backupNobull">
        Insta With No Bull
        <br>
    </div>
    <div id = "Visual" style = "display: none; font-size: 20px;">
        Visuals:
        <br>
        <input type = "checkbox" checked id = "VelocityOneTick">
        VelocityOneTick(toggle shif T)
        <br>
        <button onclick="window.toggleVisual()">Toggle Another Visual</button>
        <br>
       <input type = "checkbox" checked id = "placeVis">
        PlaceVisual
        <br>
        <input type = "checkbox" id = "StackText">
        StackedText
        <br>
        <input type = "checkbox" id = "BoostSpikers">
        BoostSpike
        <br>
    </div>
    <div id = "Misc" style = "display: none; font-size: 20px;">
        #AutoGrind Settings:
        <br>
        <input type = "checkbox" id = "weaponGrind">
        AutoGrind
        <br>
        <input type = "checkbox" checked id = "spikeTick">
        spikeTick
        <br>
        <input type = "checkbox" checked id = "KillChat">
        killChat:
        <br>
        <button onclick="window.freezePlayer()">Crash player</button>
        <br>
        <button onclick="window.debug()">debug</button>
        <br>
        <input type = "checkbox" checked id = "autoBuy">
        autoBuy
        <br>
        <input type = "checkbox" checked id = "alwaysFlipper">
        alwaysFlipper
        <br>
        <input type = "checkbox" checked id = "AutoBot">
        AutoBotIDK
        <br>
        <input type = "checkbox" checked id = "autoBuyEquip">
        autoBuyEquip
        <br>
        preplaceMore:
        <select id="preplaceMore" class="styled-select">
         <option value="trap">For Retrap</option>
         <option selected value="spike">For Spiketick</option>
        </select>
        <br>
        <br>
        #Song Settings:
        <br>
        Song(z):
         <select id="song" class="styled-select">
         <option selected value="0">Dead Of Night</option>
         <option value="1">none</option>
         <option value="2">none</option>
        </select>
    </div>
    <div id = "seti" style="display: none; font-size: 25px;">
        Profile:
    </div>
</div>
`;
let song1 = new Audio("https://ncs.io/track/download/3db2d7b2-fe13-4063-a618-a29eca83f45f");
let Songs = [song1];
let songC1 = {
    '0:03' : "Baby, this is do or die",
    '0:06' : "Feel it in my veins at night",
    '0:08' : "Emotional suicide",
    '0:11' : "You know it's an eye for eye",
    '0:13' : "I didn't wanna walk,",
    '0:15' : "didn't wanna walk the plank",
    '0:19' : "No,",
    '0:20' : "but then ready or not,",
    '0:21' : "then ready or not it came",
    '0:23' : "Like the thunder,",
    '0:24' : "I was on my way to going under",
    '0:26' : "(under)",
    '0:27' : "Swimming in the pain,",
    '0:28' : "yeah, I was covered",
    '0:30' : "In a tidal wave,",
    '0:32' : "in a tidal wave",
    '0:33' : "But I'm a fighter",
    '0:34' : "(hu)",
    '0:35' : "Tryna take me down,",
    '0:36' : "I'm going higher",
    '0:37' : "(I'm higher)",
    '0:38' : "Baby, you've been playing",
    '0:39' : "with some fire",
    '0:40' : "(you've playing)",
    '0:41' : "You've been playing with fire",
    '0:42' : "(playing with fire)",
    '0:43' : "One day you will see",
    '0:46' : "What you made of me",
    '0:48' : "Found my inner beast",
    '0:49' : "(inner beast)",
    '0:51' : "You'll watch it release",
    '0:53' : "In the dead of night",
    '1:05' : "In the dead of night",
    '1:10' : "In the dead of",
    '1:14' : "  Night  ",
    '1:18' : "Baby, when it's do or die",
    '1:19' : "(when it's do or die)",
    '1:20' : "You know it's an eye for eye",
    '1:22' : "(it's an eye for eye)",
    '1:23' : "Feel the energy align",
    '1:25' : "(oh)",
    '1:26' : "In the dead of night",
    '1:27' : "you've been playing with fire",
    '1:28' : "In the dead of night,",
    '1:31' : "In the dead of night",
    '1:33' : "(in the dead of night)",
    '1:37' : "In the dead of night",
    '1:50' : "You can save your alibi",
    '1:52' : "I already know you lied",
    '1:55' : "Oh no, no don't even try",
    '1:57' : "(don't even try)",
    '1:58' : "Watch the flame in me ignite",
    '2:00' : "You didn't wanna walk,",
    '2:02' : "didn't wanna walk the plank",
    '2:05' : "But then ready or not,",
    '2:07' : "then ready or not it came",
    '2:09' : "Baby, it was dark",
    '2:10' : "It was hard to see",
    '2:12' : "And that's when a spark",
    '2:14' : "lit inside of me,",
    '2:16' : " Oh ",
    '2:17' : "I was lost in reverie,",
    '2:19' : "Oh-oh, oh-oh",
    '2:22' : "One day you will see",
    '2:23' : "(you will see)",
    '2:24' : "What you made of me",
    '2:27' : "What's inside of me",
    '2:28' : "(what's inside of me)",
    '2:30' : "Oh, one day you will see",
    '2:35' : "I found my inner beast",
    '2:37' : "(I found my inner beast)",
    '2:38' : "You'll watch it release",
    '2:41' : "In the dead of night, oh",
    '2:51' : "In the dead of night",
    '2:55' : "(In the dead of)",
    '2:57' : "In the dead of night, oh-woah",
    '3:03' : "In the dead of night",
    '3:05' : "Baby, when it's do or die",
    '3:07' : "You know it's an eye for eye",
    '3:10' : "Feel the energy align",
    '3:12' : "In the dead of night",
    '3:16' : " In the dead of night ",
    '3:18' : "  In the dead of night  ",
    '3:21' : "   In the dead of night   ",
    '3:23' : "    In the dead of night    ",
    '3:26' : "And one day you will see",
    '3:28' : "What you made of me",
    '3:31' : "What's inside of me",
    '3:35' : "Oh, and one day you will see",
    '3:39' : "I found my inner beast",
    '3:42' : "And you'll watch it release",
}
let songC = [songC1];
document.body.appendChild(UnoReverse);

const tabs = document.querySelectorAll('.tab-box');
const contents = document.querySelectorAll('#mainmenu > div');
tabs.forEach(tab => {
    tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('selected'));
        tab.classList.add('selected');
        contents.forEach(content => {
            content.style.display = 'none';
        });
        if (tab.id === "combat") {
            document.getElementById("Combat").style.display = "block";
        } else if (tab.id === "visual") {
            document.getElementById("Visual").style.display = "block";
        } else if (tab.id === "misc") {
            document.getElementById("Misc").style.display = "block";
        } else if (tab.id == "set") {
            document.getElementById("seti").style.display = "block";
        }
    });
});
let HTML = new Html();

let menuChatDiv = document.createElement("div");
menuChatDiv.id = "menuChatDiv";
document.body.appendChild(menuChatDiv);
HTML.set("menuChatDiv");
HTML.setStyle(`
            position: absolute;
            display: none;
            left: 165px;
            top: 405px;
          //  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.65);
            `);
HTML.resetHTML();
HTML.setCSS(`
                    .chDiv {
    color: #fff;
    padding: 10px;
    height: 217px;
    background-color: rgba(0, 0, 0, 0);
    font-family: "HammerSmith One", monospace;
 //   border-radius: 15px;
//    box-shadow: black 1px 2px 19px;
//backdrop-filter: blur(3px);

}
.chMainDiv {
    font-family: "Ubuntu";
    font-size: 16px;
    max-height: 215px;
    overflow-y: scroll;
    scrollbar-width: thin;
    scrollbar-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0);
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    overflow-x: hidden;
}
.chMainDiv::-webkit-scrollbar {
    width: 8px;
}
.chMainDiv::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.5);
}
.chMainDiv::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0, 0, 0, 0.7);
}
.chMainBox {
display:none;
     position: absolute;
    left: 10px;
    bottom: 10px;
    width: 380px;
    height: 25px;
    background-color: rgba(255, 255, 255, 0);
    border-radius: 5px;
    color: rgba(255, 255, 255, 0.75);
    font-family: "HammerSmith One";
    font-size: 12px;
}
            `);
HTML.startDiv({
    id: "mChDiv",
    class: "chDiv"
}, (html) => {
    HTML.addDiv({
        id: "mChMain",
        class: "chMainDiv",
        appendID: "mChDiv"
    }, (html) => {});
    html.text({
        id: "mChBox",
        class: "chMainBox",
        //  placeHolder: `To chat click here or press "Enter" key`
    });
});

let menuChats = getEl("mChMain");
let menuChatBox = getEl("mChBox");
let menuCBFocus = false;
let menuChCounts = 0;

menuChatBox.value = "";
menuChatBox.addEventListener("focus", () => {
    menuCBFocus = true;
});
menuChatBox.addEventListener("blur", () => {
    menuCBFocus = false;
});

function addMenuChText(name, message, color, noTimer) {
    HTML.set("menuChatDiv");
    color = color || "white";
    let time = new Date();
    let min = time.getMinutes();
    let hour = time.getHours();
    let text = ``;
    if (!noTimer) text += `${(hour < 10 ? '0' : '') + hour}:${(min < 10 ? '0' : '') + min}`;
    if (name) text += `${(!noTimer ? " - " : "") + name}`;
    if (message) text += `${(name ? ": " : !noTimer ? " - " : "") + message}\n`;
    text = `<plaintext>${text}`;
    HTML.addDiv({ id: "menuChDisp", style: `color: ${color}`, appendID: "mChMain" }, (html) => {
        html.add(text);
    });
    menuChats.scrollTop = menuChats.scrollHeight;
    menuChCounts++;
}
function chch(name, message, color, noTimer) {
    HTML.set("menuChatDiv");
    color = color || "white";
    let time = new Date();
    let text = ``;
    // if (name) text += `${(!noTimer ? " - " : "") + name}`;
    if (message) text += `${(name ? ": " : !noTimer ? "" : "") + message}\n`;
    HTML.addDiv({ id: "menuChDisp", style: `color: ${color}`, appendID: "mChMain" }, (html) => {
        html.add(text);
    });
    menuChats.scrollTop = menuChats.scrollHeight;
    menuChCounts++;
}

function resetMenuChText() {
    menuChats.innerHTML = ``;
    menuChCounts = 0;
    addMenuChText(null, "", "white", 1) // chat history
}
resetMenuChText();

let menuIndex = 0;
let menus = ["menuMain", "menuConfig", "menuOther"];
window.changeMenu = function() {
    getEl(menus[menuIndex % menus.length]).style.display = "none";
    menuIndex++;
    getEl(menus[menuIndex % menus.length]).style.display = "block";
};

let mStatus = document.createElement("div");
mStatus.id = "status";
getEl("gameUI").appendChild(mStatus);
HTML.set("status");
HTML.setStyle(`
            display: block;
            position: absolute;
            color: #ddd;
            font: 15px Hammersmith One;
            bottom: 215px;
            left: 20px;
            `);
HTML.resetHTML();
HTML.setCSS(`
            .sizing {
                font-size: 15px;
            }
            .mod {
                font-size: 15px;
                display: inline-block;
            }
            `);
HTML.startDiv({
    id: "uehmod",
    class: "sizing"
}, (html) => {
    html.add(`Ping: `);
    HTML.addDiv({
        id: "pingFps",
        class: "mod",
        appendID: "uehmod"
    }, (html) => {
        html.add("None");
    });
    html.newLine();
    html.add(`Packet: `);
    HTML.addDiv({
        id: "packetStatus",
        class: "mod",
        appendID: "uehmod"
    }, (html) => {
        html.add("None");
    });
});

/*function modLog() {
                let logs = [];
                for (let i = 0; i < arguments.length; i++) {
                    logs.push(arguments[i]);
                }
                getEl("modLog").innerHTML = logs;
            }*/

let openMenu = false;

let WS = undefined;
let socketID = undefined;

let useWasd = false;
let secPacket = 0;
let secMax = 120;
let secTime = 1000;
let firstSend = {
    sec: false
};
let game = {
    tick: 0,
    tickQueue: [],
    tickBase: function(set, tick) {
        if (this.tickQueue[this.tick + tick]) {
            this.tickQueue[this.tick + tick].push(set);
        } else {
            this.tickQueue[this.tick + tick] = [set];
        }
    },
    tickRate: (1000 / config.serverUpdateRate),
    tickSpeed: 0,
    lastTick: performance.now()
};
let modConsole = [];

let dontSend = false;
let fpsTimer = {
    last: 0,
    time: 0,
    ltime: 0
}
let lastMoveDir = undefined;
let lastsp = ["cc", 1, "__proto__"];

WebSocket.prototype.nsend = WebSocket.prototype.send;
WebSocket.prototype.send = function(message) {
    if (!WS) {
        WS = this;
        WS.addEventListener("message", function(msg) {
            getMessage(msg);
        });
        WS.addEventListener("close", (event) => {
            if (event.code == 4001) {
                window.location.reload();
            }
        });
    }
    if (WS == this) {
        dontSend = false;

        // EXTRACT DATA ARRAY:
        let data = new Uint8Array(message);
        let parsed = window.msgpack.decode(data);
        let type = parsed[0];
        data = parsed[1];

        // SEND MESSAGE:
        if (type == "6") {

            if (data[0]) {
                // ANTI PROFANITY:
                let profanity = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard", ];
                let tmpString;
                profanity.forEach((profany) => {
                    if (data[0].indexOf(profany) > -1) {
                        tmpString = "";
                        for (let i = 0; i < profany.length; ++i) {
                            if (i == 1) {
                                tmpString += String.fromCharCode(0);
                            }
                            tmpString += profany[i];
                        }
                        let re = new RegExp(profany, "g");
                        data[0] = data[0].replace(re, tmpString);
                    }
                });

                // FIX CHAT:
                data[0] = data[0].slice(0, 30);
            }

        } else if (type == "L") {
            // MAKE SAME CLAN:
            data[0] = data[0] + (String.fromCharCode(0).repeat(7));
            data[0] = data[0].slice(0, 7);
        } else if (type == "M") {
            // APPLY CYAN COLOR:
            data[0].name = data[0].name == "" ? "Botss" : data[0].name;
            data[0].moofoll = true;
            data[0].skin = data[0].skin == 10 ? "__proto__" : data[0].skin;
            lastsp = [data[0].name, data[0].moofoll, data[0].skin];
        } else if (type == "D") {
            if ((my.lastDir == data[0]) || [null, undefined].includes(data[0])) {
                dontSend = true;
            } else {
                my.lastDir = data[0];
            }
        } else if (type == "d") {
            if (!data[2]) {
                dontSend = true;
            } else {
                if (![null, undefined].includes(data[1])) {
                    my.lastDir = data[1];
                }
            }
        } else if (type == "K") {
            if (!data[1]) {
                dontSend = true;
            }
        } else if (type == "S") {
            instaC.wait = !instaC.wait;
            dontSend = true;
        } else if (type == "a") {
            if (data[1]) {
                if (player.moveDir == data[0]) {
                    dontSend = true;
                }
                player.moveDir = data[0];
            } else {
                dontSend = true;
            }
        }
        if (!dontSend) {
            let binary = window.msgpack.encode([type, data]);
            this.nsend(binary);

            // START COUNT:
            if (!firstSend.sec) {
                firstSend.sec = true;
                setTimeout(() => {
                    firstSend.sec = false;
                    secPacket = 0;
                }, secTime);
            }

            secPacket++;
        }
    } else {
        this.nsend(message);
    }
}

function packet(type) {
    // EXTRACT DATA ARRAY:
    let data = Array.prototype.slice.call(arguments, 1);

    // SEND MESSAGE:
    let binary = window.msgpack.encode([type, data]);
    WS.send(binary);
}

function origPacket(type) {
    // EXTRACT DATA ARRAY:
    let data = Array.prototype.slice.call(arguments, 1);

    // SEND MESSAGE:
    let binary = window.msgpack.encode([type, data]);
    WS.nsend(binary);
}

window.leave = function() {
    origPacket("kys", {
        "frvr is so bad": true,
        "sidney is too good": true,
        "dev are too weak": true,
    });
};

//...lol
let io = {
    send: packet
};

function getMessage(message) {
    let data = new Uint8Array(message.data);
    let parsed = window.msgpack.decode(data);
    let type = parsed[0];
    data = parsed[1];
    let events = {
        A: setInitData, // id: setInitData,
        //B: disconnect,
        C: setupGame, // 1: setupGame,
        D: addPlayer, // 2: addPlayer,
        E: removePlayer, // 4: removePlayer,
        a: updatePlayers, // 33: updatePlayers,
        G: updateLeaderboard, // 5: updateLeaderboard,here
        H: loadGameObject, // 6: loadGameObject,
        I: loadAI, // a: loadAI,
        J: animateAI, // aa: animateAI,
        K: gatherAnimation, // 7: gatherAnimation,
        L: wiggleGameObject, // 8: wiggleGameObject,
        M: shootTurret, // sp: shootTurret,
        N: updatePlayerValue, // 9: updatePlayerValue,
        O: updateHealth1, // h: updateHealth,//here
        O: updateHealth, // h: updateHealth,//here
        P: killPlayer, // 11: killPlayer,
        Q: killObject, // 12: killObject,
        R: killObjects, // 13: killObjects,
        S: updateItemCounts, // 14: updateItemCounts,
        T: updateAge, // 15: updateAge,
        U: updateUpgrades, // 16: updateUpgrades,
        V: updateItems, // 17: updateItems,
        X: addProjectile, // 18: addProjectile,
        // Y: remProjectile, // 19: remProjectile,
        //Z: serverShutdownNotice,
        //0: addAlliance,
        //1: deleteAlliance,
        2: allianceNotification, // an: allianceNotification,
        3: setPlayerTeam, // st: setPlayerTeam,
        4: setAlliancePlayers, // sa: setAlliancePlayers,
        5: updateStoreItems, // us: updateStoreItems,
        6: receiveChat, // ch: receiveChat,
        7: updateMinimap, // mm: updateMinimap,
        8: showText, // t: showText,
        9: pingMap, // p: pingMap,
        0: pingSocketResponse,
    };
    if (type == "io-init") {
        socketID = data[0];
    } else {
        if (events[type]) {
            events[type].apply(undefined, data);
        }
    }
}

// MATHS:
Math.lerpAngle = function(value1, value2, amount) {
    let difference = Math.abs(value2 - value1);
    if (difference > Math.PI) {
        if (value1 > value2) {
            value2 += Math.PI * 2;
        } else {
            value1 += Math.PI * 2;
        }
    }
    let value = value2 + ((value1 - value2) * amount);
    if (value >= 0 && value <= Math.PI * 2) return value;
    return value % (Math.PI * 2);
};

// REOUNDED RECTANGLE:
CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    if (r < 0)
        r = 0;
    this.beginPath();
    this.moveTo(x + r, y);
    this.arcTo(x + w, y, x + w, y + h, r);
    this.arcTo(x + w, y + h, x, y + h, r);
    this.arcTo(x, y + h, x, y, r);
    this.arcTo(x, y, x + w, y, r);
    this.closePath();
    return this;
};

// GLOBAL VALUES:
function resetMoveDir() {
    keys = {};
    io.send("e");
}

let allChats = [];
let ticks = {
    tick: 0,
    delay: 0,
    time: [],
    manage: [],
};
let ais = [];
let players = [];
let alliances = [];
let alliancePlayers = [];
let allianceNotifications = [];
let gameObjects = [];
let liztobj = [];
let projectiles = [];
let deadPlayers = [];

let breakObjects = [];

let player;
let playerSID;
let tmpObj;

let enemy = [];
let nears = [];
let near = {
    enemys: [],
    enemy: [],
    nears: [],
    aim: undefined,
    dist: undefined
}
let my = {
    reloaded: false,
    waitHit: 0,
    autoAim: false,
    revAim: false,
    ageInsta: true,
    reSync: false,
    bullTick: 0,
    anti0Tick: 0,
    SpikeAim: false,
    canHat: true,
    canMove: true,
    FastAim: false,
    antiSync: false,
    BullAim: false,
    MillAim: false,
    waitItem: false,
    safePrimary: function(tmpObj) {
        return [0, 8].includes(tmpObj.primaryIndex);
    },
    safeSecondary: function(tmpObj) {
        return [10, 11, 14].includes(tmpObj.secondaryIndex);
    },
    lastDir: 0,
    autoPush: false,
    pushData: {}
}

// FIND OBJECTS BY ID/SID:
function findID(tmpObj, tmp) {
    return tmpObj.find((THIS) => THIS.id == tmp);
}

function findSID(tmpObj, tmp) {
    return tmpObj.find((THIS) => THIS.sid == tmp);
}

function findPlayerByID(id) {
    return findID(players, id);
}

function findPlayerBySID(sid) {
    return findSID(players, sid);
}

function findAIBySID(sid) {
    return findSID(ais, sid);
}

function findObjectBySid(sid) {
    return findSID(gameObjects, sid);
}

function findProjectileBySid(sid) {
    return findSID(gameObjects, sid);
}

let adCard = getEl("adCard");
adCard.remove();
let promoImageHolder = getEl("promoImgHolder");
promoImageHolder.remove();

let chatButton = getEl("chatButton");
chatButton.remove();
let gameCanvas = getEl("gameCanvas");
let mainContext = gameCanvas.getContext("2d");
let mapDisplay = getEl("mapDisplay");
let mapContext = mapDisplay.getContext("2d");
mapDisplay.width = 300;
mapDisplay.height = 300;
let storeMenu = getEl("storeMenu");
let storeHolder = getEl("storeHolder");
let upgradeHolder = getEl("upgradeHolder");
let upgradeCounter = getEl("upgradeCounter");
let chatBox = getEl("chatBox");
chatBox.autocomplete = "off";
chatBox.style.textAlign = "center";
chatBox.style.width = "18em";
let chatHolder = getEl("chatHolder");
let actionBar = getEl("actionBar");
let leaderboardData = getEl("leaderboardData");
let itemInfoHolder = getEl("itemInfoHolder");
let menuCardHolder = getEl("menuCardHolder");
let mainMenu = getEl("mainMenu");
let diedText = getEl("diedText");
let screenWidth;
let screenHeight;
let maxScreenWidth = config.maxScreenWidth;
let maxScreenHeight = config.maxScreenHeight;
let pixelDensity = 1;
let delta;
let now;
let lastUpdate = performance.now();
let camX;
let camY;
let tmpDir;
let mouseX = 0;
let mouseY = 0;
let allianceMenu = getEl("allianceMenu");
let waterMult = 1;
let waterPlus = 0;

let outlineColor = "#525252";
let darkOutlineColor = "#3d3f42";
let outlineWidth = 5.5;

let firstSetup = true;
let keys = {};
let moveKeys = {
    87: [0, -1],
    38: [0, -1],
    83: [0, 1],
    40: [0, 1],
    65: [-1, 0],
    37: [-1, 0],
    68: [1, 0],
    39: [1, 0],
};
let attackState = 0;
let inGame = false;

let macro = {};
let mills = {
    place: 0,
    placeSpawnPads: 0
};
let lastDir;

let lastLeaderboardData = [];

// ON LOAD:
let inWindow = true;
window.onblur = function() {
    inWindow = false;
};
window.onfocus = function() {
    inWindow = true;
    if (player && player.alive) {
        // resetMoveDir();
    }
};
let ms = {
    avg: 0,
    max: 0,
    min: 0,
    delay: 0
}
function pingSocketResponse() {
    let pingTime = window.pingTime;
    const pingDisplay = document.getElementById("pingDisplay")
    pingDisplay.innerText = "";
    if (pingTime > ms.max || isNaN(ms.max)) {
        ms.max = pingTime;
    }
    if (pingTime < ms.min || isNaN(ms.min)) {
        ms.min = pingTime;
    }

    // if (pingTime >= 90) {
    //     doAutoQ = true;
    // } else {
    //     doAutoQ = false;
    // }
}

let placeVisible = [];
let ReplaceVisible = [];
/** CLASS CODES */
let profanityList = [];
class Utils {
    constructor() {

        // MATH UTILS:
        let mathABS = Math.abs,
            mathCOS = Math.cos,
            mathSIN = Math.sin,
            mathPOW = Math.pow,
            mathSQRT = Math.sqrt,
            mathATAN2 = Math.atan2,
            mathPI = Math.PI;

        let _this = this;

        // GLOBAL UTILS:
        this.round = function(n, v) {
            return Math.round(n * v) / v;
        };
        this.toRad = function(angle) {
            return angle * (mathPI / 180);
        };
        this.toAng = function(radian) {
            return radian / (mathPI / 180);
        };
        this.randInt = function(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        };
        this.randFloat = function(min, max) {
            return Math.random() * (max - min + 1) + min;
        };
        this.lerp = function(value1, value2, amount) {
            return value1 + (value2 - value1) * amount;
        };
        this.decel = function(val, cel) {
            if (val > 0)
                val = Math.max(0, val - cel);
            else if (val < 0)
                val = Math.min(0, val + cel);
            return val;
        };
        this.getDistance = function(x1, y1, x2, y2) {
            return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
        };
        this.getDist = function(tmp1, tmp2, type1, type2) {
            let tmpXY1 = {
                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
            };
            let tmpXY2 = {
                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
            };
            return mathSQRT((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
        };
        this.getDirection = function(x1, y1, x2, y2) {
            return mathATAN2(y1 - y2, x1 - x2);
        };
        this.getDirect = function(tmp1, tmp2, type1, type2) {
            let tmpXY1 = {
                x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
            };
            let tmpXY2 = {
                x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
            };
            return mathATAN2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
        };
        this.getAngleDist = function(a, b) {
            let p = mathABS(b - a) % (mathPI * 2);
            return (p > mathPI ? (mathPI * 2) - p : p);
        };
        this.isNumber = function(n) {
            return (typeof n == "number" && !isNaN(n) && isFinite(n));
        };
        this.isString = function(s) {
            return (s && typeof s == "string");
        };
        this.kFormat = function(num) {
            return num > 999 ? (num / 1000).toFixed(1) + "k" : num;
        };
        this.sFormat = function(num) {
            let fixs = [{
                num: 1e3,
                string: "k"
            },
                        {
                            num: 1e6,
                            string: "m"
                        },
                        {
                            num: 1e9,
                            string: "b"
                        },
                        {
                            num: 1e12,
                            string: "q"
                        }
                       ].reverse();
            let sp = fixs.find(v => num >= v.num);
            if (!sp) return num;
            return (num / sp.num).toFixed(1) + sp.string;
        };
        this.capitalizeFirst = function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        };
        this.fixTo = function(n, v) {
            return parseFloat(n.toFixed(v));
        };
        this.sortByPoints = function(a, b) {
            return parseFloat(b.points) - parseFloat(a.points);
        };
        this.lineInRect = function(recX, recY, recX2, recY2, x1, y1, x2, y2) {
            let minX = x1;
            let maxX = x2;
            if (x1 > x2) {
                minX = x2;
                maxX = x1;
            }
            if (maxX > recX2)
                maxX = recX2;
            if (minX < recX)
                minX = recX;
            if (minX > maxX)
                return false;
            let minY = y1;
            let maxY = y2;
            let dx = x2 - x1;
            if (Math.abs(dx) > 0.0000001) {
                let a = (y2 - y1) / dx;
                let b = y1 - a * x1;
                minY = a * minX + b;
                maxY = a * maxX + b;
            }
            if (minY > maxY) {
                let tmp = maxY;
                maxY = minY;
                minY = tmp;
            }
            if (maxY > recY2)
                maxY = recY2;
            if (minY < recY)
                minY = recY;
            if (minY > maxY)
                return false;
            return true;
        };
        this.containsPoint = function(element, x, y) {
            let bounds = element.getBoundingClientRect();
            let left = bounds.left + window.scrollX;
            let top = bounds.top + window.scrollY;
            let width = bounds.width;
            let height = bounds.height;

            let insideHorizontal = x > left && x < left + width;
            let insideVertical = y > top && y < top + height;
            return insideHorizontal && insideVertical;
        };
        this.mousifyTouchEvent = function(event) {
            let touch = event.changedTouches[0];
            event.screenX = touch.screenX;
            event.screenY = touch.screenY;
            event.clientX = touch.clientX;
            event.clientY = touch.clientY;
            event.pageX = touch.pageX;
            event.pageY = touch.pageY;
        };
        this.hookTouchEvents = function(element, skipPrevent) {
            let preventDefault = !skipPrevent;
            let isHovering = false;
            // let passive = window.Modernizr.passiveeventlisteners ? {passive: true} : false;
            let passive = false;
            element.addEventListener("touchstart", this.checkTrusted(touchStart), passive);
            element.addEventListener("touchmove", this.checkTrusted(touchMove), passive);
            element.addEventListener("touchend", this.checkTrusted(touchEnd), passive);
            element.addEventListener("touchcancel", this.checkTrusted(touchEnd), passive);
            element.addEventListener("touchleave", this.checkTrusted(touchEnd), passive);

            function touchStart(e) {
                _this.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (element.onmouseover)
                    element.onmouseover(e);
                isHovering = true;
            }

            function touchMove(e) {
                _this.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (_this.containsPoint(element, e.pageX, e.pageY)) {
                    if (!isHovering) {
                        if (element.onmouseover)
                            element.onmouseover(e);
                        isHovering = true;
                    }
                } else {
                    if (isHovering) {
                        if (element.onmouseout)
                            element.onmouseout(e);
                        isHovering = false;
                    }
                }
            }

            function touchEnd(e) {
                _this.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (isHovering) {
                    if (element.onclick)
                        element.onclick(e);
                    if (element.onmouseout)
                        element.onmouseout(e);
                    isHovering = false;
                }
            }
        };
        this.removeAllChildren = function(element) {
            while (element.hasChildNodes()) {
                element.removeChild(element.lastChild);
            }
        };
        this.generateElement = function(config) {
            let element = document.createElement(config.tag || "div");

            function bind(configValue, elementValue) {
                if (config[configValue])
                    element[elementValue] = config[configValue];
            }
            bind("text", "textContent");
            bind("html", "innerHTML");
            bind("class", "className");
            for (let key in config) {
                switch (key) {
                    case "tag":
                    case "text":
                    case "html":
                    case "class":
                    case "style":
                    case "hookTouch":
                    case "parent":
                    case "children":
                        continue;
                    default:
                        break;
                }
                element[key] = config[key];
            }
            if (element.onclick)
                element.onclick = this.checkTrusted(element.onclick);
            if (element.onmouseover)
                element.onmouseover = this.checkTrusted(element.onmouseover);
            if (element.onmouseout)
                element.onmouseout = this.checkTrusted(element.onmouseout);
            if (config.style) {
                element.style.cssText = config.style;
            }
            if (config.hookTouch) {
                this.hookTouchEvents(element);
            }
            if (config.parent) {
                config.parent.appendChild(element);
            }
            if (config.children) {
                for (let i = 0; i < config.children.length; i++) {
                    element.appendChild(config.children[i]);
                }
            }
            return element;
        };
        this.checkTrusted = function(callback) {
            return function(ev) {
                if (ev && ev instanceof Event && (ev && typeof ev.isTrusted == "boolean" ? ev.isTrusted : true)) {
                    callback(ev);
                } else {
                    //console.error("Event is not trusted.", ev);
                }
            };
        };
        this.randomString = function(length) {
            let text = "";
            let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        };
        this.countInArray = function(array, val) {
            let count = 0;
            for (let i = 0; i < array.length; i++) {
                if (array[i] === val) count++;
            }
            return count;
        };
        this.hexToRgb = function(hex) {
            return hex.slice(1).match(/.{1,2}/g).map(g => parseInt(g, 16));
        };
        this.getRgb = function(r, g, b) {
            return [r / 255, g / 255, b / 255].join(", ");
        };
    }
};
class Animtext {
    // ANIMATED TEXT:
    constructor() {
        this.init = function (x, y, scale, speed, life, text, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.scale = scale;
            this.startScale = this.scale;
            this.maxScale = scale * 1.5;
            this.scaleSpeed = 0.7;
            this.speed = speed;
            this.life = life;
            this.text = text;
            this.acc = 1;
            this.alpha = 0;
            this.maxLife = life;
            this.ranX = UTILS.randFloat(-1, 1);
        };
        this.update = function (delta) {
            if (this.life) {
                this.life -= delta;
                if (config.anotherVisual) {
                    this.y -= this.speed * delta * this.acc;
                    this.acc -= delta / (this.maxLife / 2.5);
                    if (this.life <= 8) {
                        if (this.alpha > 0) {
                            this.alpha = Math.max(0, this.alpha - delta / 12);
                        }
                    } else if (this.alpha < 1) {
                        this.alpha = Math.min(1, this.alpha + delta / 64);
                    }
                    this.x += this.ranX;
                } else {
                    this.y -= this.speed * delta;
                }
                this.scale += this.scaleSpeed * delta;
                if (this.scale >= this.maxScale) {
                    this.scale = this.maxScale;
                    this.scaleSpeed *= -1;
                } else if (this.scale <= this.startScale) {
                    this.scale = this.startScale;
                    this.scaleSpeed = 0;
                }
                if (this.life <= 0) {
                    this.life = 0;
                }
            }
        };
        this.render = function (ctxt, xOff, yOff, value) {
            ctxt.lineWidth = 0xa;
            ctxt.fillStyle = this.color;
            ctxt.font = this.scale + "px " + (config.anotherVisual ? "Hammersmith One" : "Hammersmith One");
            if (config.anotherVisual) {
                ctxt.globalAlpha = this.alpha;
                ctxt.strokeStyle = "#3d3f42";
                ctxt.strokeText(this.text, this.x - xOff, this.y - yOff);
            }
            ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
            ctxt.globalAlpha = 1;
        };
    }
}
;
class Textmanager {
    // TEXT MANAGER:
    constructor() {
        this.texts = [];
        this.stack = [];

        this.update = function (delta, ctxt, xOff, yOff) {
            ctxt.textBaseline = "middle";
            ctxt.textAlign = "center";
            for (let i = 0; i < this.texts.length; ++i) {
                if (this.texts[i].life) {
                    this.texts[i].update(delta);
                    this.texts[i].render(ctxt, xOff, yOff);
                }
            }
        };

        this.showText = function (x, y, scale, speed, life, text, color) {
            let tmpText;
            for (let i = 0; i < this.texts.length; ++i) {
                if (!this.texts[i].life) {
                    tmpText = this.texts[i];
                    break;
                }
            }
            if (!tmpText) {
                tmpText = new Animtext();
                this.texts.push(tmpText);
            }
            tmpText.init(x, y, scale, speed, life, text, color);
        };
    }
}

class GameObject {
    constructor(sid) {
        this.sid = sid;

        // INIT:
        this.init = function(x, y, dir, scale, type, data, owner) {
            data = data || {};
            this.sentTo = {};
            this.gridLocations = [];
            this.active = true;
            this.render = true;
            this.doUpdate = data.doUpdate;
            this.x = x;
            this.y = y;
            this.dir = dir;
            this.lastDir = dir;
            this.xWiggle = 0;
            this.yWiggle = 0;
            this.visScale = scale;
            this.scale = scale;
            this.type = type;
            this.id = data.id;
            this.owner = owner;
            this.name = data.name;
            this.isItem = (this.id != undefined);
            this.group = data.group;
            this.maxHealth = data.health;
            this.health = this.maxHealth;
            this.layer = 2;
            if (this.group != undefined) {
                this.layer = this.group.layer;
            } else if (this.type == 0) {
                this.layer = 3;
            } else if (this.type == 2) {
                this.layer = 0;
            } else if (this.type == 4) {
                this.layer = -1;
            }
            this.colDiv = data.colDiv || 1;
            this.blocker = data.blocker;
            this.ignoreCollision = data.ignoreCollision;
            this.dontGather = data.dontGather;
            this.hideFromEnemy = data.hideFromEnemy;
            this.friction = data.friction;
            this.projDmg = data.projDmg;
            this.dmg = data.dmg;
            this.pDmg = data.pDmg;
            this.pps = data.pps;
            this.zIndex = data.zIndex || 0;
            this.turnSpeed = data.turnSpeed;
            this.req = data.req;
            this.trap = data.trap;
            this.healCol = data.healCol;
            this.teleport = data.teleport;
            this.boostSpeed = data.boostSpeed;
            this.projectile = data.projectile;
            this.shootRange = data.shootRange;
            this.shootRate = data.shootRate;
            this.shootCount = this.shootRate;
            this.spawnPoint = data.spawnPoint;
            this.onNear = 0;
            this.breakObj = false;
            this.alpha = data.alpha || 1;
            this.maxAlpha = data.alpha || 1;
            this.damaged = 0;
        };

        // GET HIT:
        this.changeHealth = function(amount, doer) {
            this.health += amount;
            return (this.health <= 100);
        };

        // GET SCALE:
        this.getScale = function(sM, ig) {
            sM = sM || 1;
            return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4) ?
                                 1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
        };

        // VISIBLE TO PLAYER:
        this.visibleToPlayer = function(player) {
            return !(this.hideFromEnemy) || (this.owner && (this.owner == player ||
                                                            (this.owner.team && player.team == this.owner.team)));
        };

        // UPDATE:
        this.update = function(delta) {
            if (this.active) {
                if (this.xWiggle) {
                    this.xWiggle *= Math.pow(0.99, delta);
                }
                if (this.yWiggle) {
                    this.yWiggle *= Math.pow(0.99, delta);
                }
                let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                if (d2 > 0.01) {
                    this.dir += d2 / 5;
                } else {
                    this.dir = this.lastDir;
                }
            } else {
                if (this.alive) {
                    this.alpha -= delta / (200 / this.maxAlpha);
                    this.visScale += delta / (this.scale / 2.5);
                    if (this.alpha <= 0) {
                        this.alpha = 0;
                        this.alive = false;
                    }
                }
            }
        };
        // CHECK TEAM:
        this.isTeam = function(tmpObj) {
            return (this == tmpObj || (this.team && this.team == tmpObj.team));
        };
        // CHECK TEAM:
        this.isTeamObject = function(tmpObj) {
            return this.owner == null ? true : (this.owner && tmpObj.sid == this.owner.sid || tmpObj.findAllianceBySid(this.owner.sid));
        };
    }
}
class Items {
    constructor() {
        // ITEM GROUPS:
        this.groups = [{
            id: 0,
            name: "food",
            layer: 0
        }, {
            id: 1,
            name: "walls",
            place: true,
            limit: 30,
            layer: 0
        }, {
            id: 2,
            name: "spikes",
            place: true,
            limit: 15,
            layer: 0
        }, {
            id: 3,
            name: "mill",
            place: true,
            limit: 7,
            layer: 1
        }, {
            id: 4,
            name: "mine",
            place: true,
            limit: 1,
            layer: 0
        }, {
            id: 5,
            name: "trap",
            place: true,
            limit: 6,
            layer: -1
        }, {
            id: 6,
            name: "booster",
            place: true,
            limit: 12,
            layer: -1
        }, {
            id: 7,
            name: "turret",
            place: true,
            limit: 2,
            layer: 1
        }, {
            id: 8,
            name: "watchtower",
            place: true,
            limit: 12,
            layer: 1
        }, {
            id: 9,
            name: "buff",
            place: true,
            limit: 4,
            layer: -1
        }, {
            id: 10,
            name: "spawn",
            place: true,
            limit: 1,
            layer: -1
        }, {
            id: 11,
            name: "sapling",
            place: true,
            limit: 2,
            layer: 0
        }, {
            id: 12,
            name: "blocker",
            place: true,
            limit: 3,
            layer: -1
        }, {
            id: 13,
            name: "teleporter",
            place: true,
            limit: 2,
            layer: -1
        }];

        // PROJECTILES:
        this.projectiles = [{
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 25,
            speed: 1.6,
            scale: 103,
            range: 1000
        }, {
            indx: 1,
            layer: 1,
            dmg: 25,
            scale: 20
        }, {
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 35,
            speed: 2.5,
            scale: 103,
            range: 1200
        }, {
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 30,
            speed: 2,
            scale: 103,
            range: 1200
        }, {
            indx: 1,
            layer: 1,
            dmg: 16,
            scale: 20
        }, {
            indx: 0,
            layer: 0,
            src: "bullet_1",
            dmg: 50,
            speed: 3.6,
            scale: 160,
            range: 1400
        }];

        // WEAPONS:
        this.weapons = [{
            id: 0,
            type: 0,
            name: "tool hammer",
            desc: "tool for gathering all resources",
            src: "hammer_1",
            length: 140,
            width: 140,
            xOff: -3,
            yOff: 18,
            dmg: 25,
            range: 65,
            gather: 1,
            speed: 300
        }, {
            id: 1,
            type: 0,
            age: 2,
            name: "hand axe",
            desc: "gathers resources at a higher rate",
            src: "axe_1",
            length: 140,
            width: 140,
            xOff: 3,
            yOff: 24,
            dmg: 30,
            spdMult: 1,
            range: 70,
            gather: 2,
            speed: 400
        }, {
            id: 2,
            type: 0,
            age: 8,
            pre: 1,
            name: "great axe",
            desc: "deal more damage and gather more resources",
            src: "great_axe_1",
            length: 140,
            width: 140,
            xOff: -8,
            yOff: 25,
            dmg: 35,
            spdMult: 1,
            range: 75,
            gather: 4,
            speed: 400
        }, {
            id: 3,
            type: 0,
            age: 2,
            name: "short sword",
            desc: "increased attack power but slower move speed",
            src: "sword_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 46,
            dmg: 35,
            spdMult: 0.85,
            range: 110,
            gather: 1,
            speed: 300
        }, {
            id: 4,
            type: 0,
            age: 8,
            pre: 3,
            name: "katana",
            desc: "greater range and damage",
            src: "samurai_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 59,
            dmg: 40,
            spdMult: 0.8,
            range: 118,
            gather: 1,
            speed: 300
        }, {
            id: 5,
            type: 0,
            age: 2,
            name: "polearm",
            desc: "long range melee weapon",
            src: "spear_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 53,
            dmg: 45,
            knock: 0.2,
            spdMult: 0.82,
            range: 142,
            gather: 1,
            speed: 700
        }, {
            id: 6,
            type: 0,
            age: 2,
            name: "bat",
            desc: "fast long range melee weapon",
            src: "bat_1",
            iPad: 1.3,
            length: 110,
            width: 180,
            xOff: -8,
            yOff: 53,
            dmg: 20,
            knock: 0.7,
            range: 110,
            gather: 1,
            speed: 300
        }, {
            id: 7,
            type: 0,
            age: 2,
            name: "daggers",
            desc: "really fast short range weapon",
            src: "dagger_1",
            iPad: 0.8,
            length: 110,
            width: 110,
            xOff: 18,
            yOff: 0,
            dmg: 20,
            knock: 0.1,
            range: 65,
            gather: 1,
            hitSlow: 0.1,
            spdMult: 1.13,
            speed: 100
        }, {
            id: 8,
            type: 0,
            age: 2,
            name: "stick",
            desc: "great for gathering but very weak",
            src: "stick_1",
            length: 140,
            width: 140,
            xOff: 3,
            yOff: 24,
            dmg: 1,
            spdMult: 1,
            range: 70,
            gather: 7,
            speed: 400
        }, {
            id: 9,
            type: 1,
            age: 6,
            name: "hunting bow",
            desc: "bow used for ranged combat and hunting",
            src: "bow_1",
            req: ["wood", 4],
            length: 120,
            width: 120,
            xOff: -6,
            yOff: 0,
            Pdmg: 25,
            projectile: 0,
            spdMult: 0.75,
            speed: 600
        }, {
            id: 10,
            type: 1,
            age: 6,
            name: "great hammer",
            desc: "hammer used for destroying structures",
            src: "great_hammer_1",
            length: 140,
            width: 140,
            xOff: -9,
            yOff: 25,
            dmg: 10,
            Pdmg: 10,
            spdMult: 0.88,
            range: 75,
            sDmg: 7.5,
            gather: 1,
            speed: 400
        }, {
            id: 11,
            type: 1,
            age: 6,
            name: "wooden shield",
            desc: "blocks projectiles and reduces melee damage",
            src: "shield_1",
            length: 120,
            width: 120,
            shield: 0.2,
            xOff: 6,
            yOff: 0,
            Pdmg: 0,
            spdMult: 0.7
        }, {
            id: 12,
            type: 1,
            age: 8,
            pre: 9,
            name: "crossbow",
            desc: "deals more damage and has greater range",
            src: "crossbow_1",
            req: ["wood", 5],
            aboveHand: true,
            armS: 0.75,
            length: 120,
            width: 120,
            xOff: -4,
            yOff: 0,
            Pdmg: 35,
            projectile: 2,
            spdMult: 0.7,
            speed: 700
        }, {
            id: 13,
            type: 1,
            age: 9,
            pre: 12,
            name: "repeater crossbow",
            desc: "high firerate crossbow with reduced damage",
            src: "crossbow_2",
            req: ["wood", 10],
            aboveHand: true,
            armS: 0.75,
            length: 120,
            width: 120,
            xOff: -4,
            yOff: 0,
            Pdmg: 30,
            projectile: 3,
            spdMult: 0.7,
            speed: 230
        }, {
            id: 14,
            type: 1,
            age: 6,
            name: "mc grabby",
            desc: "steals resources from enemies",
            src: "grab_1",
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 53,
            dmg: 0,
            Pdmg: 0,
            steal: 250,
            knock: 0.2,
            spdMult: 1.05,
            range: 125,
            gather: 0,
            speed: 700
        }, {
            id: 15,
            type: 1,
            age: 9,
            pre: 12,
            name: "musket",
            desc: "slow firerate but high damage and range",
            src: "musket_1",
            req: ["stone", 10],
            aboveHand: true,
            rec: 0.35,
            armS: 0.6,
            hndS: 0.3,
            hndD: 1.6,
            length: 205,
            width: 205,
            xOff: 25,
            yOff: 0,
            Pdmg: 50,
            projectile: 5,
            hideProjectile: true,
            spdMult: 0.6,
            speed: 1500
        }];

        // ITEMS:
        this.list = [{
            group: this.groups[0],
            name: "apple",
            desc: "restores 20 health when consumed",
            req: ["food", 10],
            consume: function(doer) {
                return doer.changeHealth(20, doer);
            },
            scale: 22,
            holdOffset: 15,
            healing: 20,
            itemID: 0,
            itemAID: 16,
        }, {
            age: 3,
            group: this.groups[0],
            name: "cookie",
            desc: "restores 40 health when consumed",
            req: ["food", 15],
            consume: function(doer) {
                return doer.changeHealth(40, doer);
            },
            scale: 27,
            holdOffset: 15,
            healing: 40,
            itemID: 1,
            itemAID: 17,
        }, {
            age: 7,
            group: this.groups[0],
            name: "cheese",
            desc: "restores 30 health and another 50 over 5 seconds",
            req: ["food", 25],
            consume: function(doer) {
                if (doer.changeHealth(30, doer) || doer.health < 100) {
                    doer.dmgOverTime.dmg = -10;
                    doer.dmgOverTime.doer = doer;
                    doer.dmgOverTime.time = 5;
                    return true;
                }
                return false;
            },
            scale: 27,
            holdOffset: 15,
            healing: 30,
            itemID: 2,
            itemAID: 18,
        }, {
            group: this.groups[1],
            name: "wood wall",
            desc: "provides protection for your village",
            req: ["wood", 10],
            projDmg: true,
            health: 380,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 3,
            itemAID: 19,
        }, {
            age: 3,
            group: this.groups[1],
            name: "stone wall",
            desc: "provides improved protection for your village",
            req: ["stone", 25],
            health: 900,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 4,
            itemAID: 20,
        }, {
            age: 7,
            group: this.groups[1],
            name: "castle wall",
            desc: "provides powerful protection for your village",
            req: ["stone", 35],
            health: 1500,
            scale: 52,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 5,
            itemAID: 21,
        }, {
            group: this.groups[2],
            name: "spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 20, "stone", 5],
            health: 400,
            dmg: 20,
            scale: 49,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
            itemID: 6,
            itemAID: 22,
            shadow: {
                offsetX: 5, // Adjust the shadow's X offset as needed
                offsetY: 5, // Adjust the shadow's Y offset as needed
                blur: 20,  // Adjust the shadow's blur as needed
                color: "rgba(0, 0, 0, 0.5)" // Adjust the shadow's color and transparency as needed
            }

        }, {
            age: 5,
            group: this.groups[2],
            name: "greater spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 30, "stone", 10],
            health: 500,
            dmg: 35,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
            itemID: 7,
            itemAID: 23,
        }, {
            age: 9,
            group: this.groups[2],
            name: "poison spikes",
            desc: "poisons enemies when they touch them",
            req: ["wood", 35, "stone", 15],
            health: 600,
            dmg: 30,
            pDmg: 5,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
            itemID: 8,
            itemAID: 24,
        }, {
            age: 9,
            group: this.groups[2],
            name: "spinning spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 30, "stone", 20],
            health: 500,
            dmg: 45,
            turnSpeed: 0.003,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5,
            itemID: 9,
            itemAID: 25,
        }, {
            group: this.groups[3],
            name: "windmill",
            desc: "generates gold over time",
            req: ["wood", 50, "stone", 10],
            health: 400,
            pps: 1,
            turnSpeed: 0.0016,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 45,
            holdOffset: 20,
            placeOffset: 5,
            itemID: 10,
            itemAID: 26,
        }, {
            age: 5,
            group: this.groups[3],
            name: "faster windmill",
            desc: "generates more gold over time",
            req: ["wood", 60, "stone", 20],
            health: 500,
            pps: 1.5,
            turnSpeed: 0.0025,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 47,
            holdOffset: 20,
            placeOffset: 5,
            itemID: 11,
            itemAID: 27,
        }, {
            age: 8,
            group: this.groups[3],
            name: "power mill",
            desc: "generates more gold over time",
            req: ["wood", 100, "stone", 50],
            health: 800,
            pps: 2,
            turnSpeed: 0.005,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 47,
            holdOffset: 20,
            placeOffset: 5,
            itemID: 12,
            itemAID: 28,
        }, {
            age: 5,
            group: this.groups[4],
            type: 2,
            name: "mine",
            desc: "allows you to mine stone",
            req: ["wood", 20, "stone", 100],
            iconLineMult: 12,
            scale: 65,
            holdOffset: 20,
            placeOffset: 0,
            itemID: 13,
            itemAID: 29,
        }, {
            age: 5,
            group: this.groups[11],
            type: 0,
            name: "sapling",
            desc: "allows you to farm wood",
            req: ["wood", 150],
            iconLineMult: 12,
            colDiv: 0.5,
            scale: 110,
            holdOffset: 50,
            placeOffset: -15,
            itemID: 14,
            itemAID: 30,
        }, {
            age: 4,
            group: this.groups[5],
            name: "pit trap",
            desc: "pit that traps enemies if they walk over it",
            req: ["wood", 30, "stone", 30],
            trap: true,
            ignoreCollision: true,
            hideFromEnemy: true,
            health: 500,
            colDiv: 0.2,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5,
            alpha: 0.6,
            itemID: 15,
            itemAID: 31,
        }, {
            age: 4,
            group: this.groups[6],
            name: "boost pad",
            desc: "provides boost when stepped on",
            req: ["stone", 20, "wood", 5],
            ignoreCollision: true,
            boostSpeed: 1.5,
            health: 150,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 16,
            itemAID: 32,
        }, {
            age: 7,
            group: this.groups[7],
            doUpdate: true,
            name: "turret",
            desc: "defensive structure that shoots at enemies",
            req: ["wood", 200, "stone", 150],
            health: 800,
            projectile: 1,
            shootRange: 700,
            shootRate: 2200,
            scale: 43,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 17,
            itemAID: 33,
        }, {
            age: 7,
            group: this.groups[8],
            name: "platform",
            desc: "platform to shoot over walls and cross over water",
            req: ["wood", 20],
            ignoreCollision: true,
            zIndex: 1,
            health: 300,
            scale: 43,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 18,
            itemAID: 34,
        }, {
            age: 7,
            group: this.groups[9],
            name: "healing pad",
            desc: "standing on it will slowly heal you",
            req: ["wood", 30, "food", 10],
            ignoreCollision: true,
            healCol: 15,
            health: 400,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 19,
            itemAID: 35,
        }, {
            age: 9,
            group: this.groups[10],
            name: "spawn pad",
            desc: "you will spawn here when you die but it will dissapear",
            req: ["wood", 100, "stone", 100],
            health: 400,
            ignoreCollision: true,
            spawnPoint: true,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 20,
            itemAID: 36,
        }, {
            age: 7,
            group: this.groups[12],
            name: "blocker",
            desc: "blocks building in radius",
            req: ["wood", 30, "stone", 25],
            ignoreCollision: true,
            blocker: 300,
            health: 400,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 21,
            itemAID: 37,
        }, {
            age: 7,
            group: this.groups[13],
            name: "teleporter",
            desc: "teleports you to a random point on the map",
            req: ["wood", 60, "stone", 60],
            ignoreCollision: true,
            teleport: true,
            health: 200,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5,
            itemID: 22,
            itemAID: 38
        }];

        // CHECK ITEM ID:
        this.checkItem = {
            index: function(id, myItems) {
                return [0, 1, 2].includes(id) ? 0 : [3, 4, 5].includes(id) ? 1 : [6, 7, 8, 9].includes(id) ? 2 : [10, 11, 12].includes(id) ? 3 : [13, 14].includes(id) ? 5 : [15, 16].includes(id) ? 4 : [17, 18, 19, 21, 22].includes(id) ? [13, 14].includes(myItems) ? 6 :
                5 :
                id == 20 ? [13, 14].includes(myItems) ? 7 :
                6 :
                undefined;
            }
        }

        // ASSIGN IDS:
        for (let i = 0; i < this.list.length; ++i) {
            this.list[i].id = i;
            if (this.list[i].pre) this.list[i].pre = i - this.list[i].pre;
        }

        // TROLOLOLOL:
        if (typeof window !== "undefined") {
            function shuffle(a) {
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            }
            //shuffle(this.list);
        }
    }
}
class Objectmanager {
    constructor(GameObject, liztobj, UTILS, config, players, server) {
        let mathFloor = Math.floor,
            mathABS = Math.abs,
            mathCOS = Math.cos,
            mathSIN = Math.sin,
            mathPOW = Math.pow,
            mathSQRT = Math.sqrt;

        this.ignoreAdd = false;
        this.hitObj = [];

        // DISABLE OBJ:
        this.disableObj = function(obj) {
            obj.active = false;
        };

        // ADD NEW:
        let tmpObj;
        this.add = function(sid, x, y, dir, s, type, data, setSID, owner) {
            tmpObj = findObjectBySid(sid);
            if (!tmpObj) {
                tmpObj = gameObjects.find((tmp) => !tmp.active);
                if (!tmpObj) {
                    tmpObj = new GameObject(sid);
                    gameObjects.push(tmpObj);
                }
            }
            if (setSID) {
                tmpObj.sid = sid;
            }
            tmpObj.init(x, y, dir, s, type, data, owner);
        };

        // DISABLE BY SID:
        this.disableBySid = function(sid) {
            let find = findObjectBySid(sid);
            if (find) {
                this.disableObj(find);
            }
        };

        // REMOVE ALL FROM PLAYER:
        this.removeAllItems = function(sid, server) {
            gameObjects.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid).forEach((tmp) => this.disableObj(tmp));
        };

        // CHECK IF PLACABLE:
        this.checkItemLocation = function(x, y, s, sM, indx, ignoreWater, placer) {
            let cantPlace = liztobj.find((tmp) => tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
            if (cantPlace) return false;
            if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;
            return true;
        };
        this.preplaceCheck = function (p371, p372, p373, p374) {
            let v399 = player.x2 + p374 * Math.cos(p372);
            let v400 = player.y2 + p374 * Math.sin(p372);
            let v401 = liztobj.filter(p375 => p375.active && UTILS.getDist(player, p375, 2, 0) < 300);
            const v402 = {
                x: v399,
                y: v400
            };
            let v403 = v401.find(p376 => p376.active && p376.sid !== p373.sid && UTILS.getDist(v402, p376, 0, 0) < p371.scale + (p376.blocker ? p376.blocker : p376.getScale(0.6, p376.isItem)));
            if (v403) {
                return false;
            }
            if (p371.id != 18 && v400 >= config.mapScale / 2 - config.riverWidth / 2 && v400 <= config.mapScale / 2 + config.riverWidth / 2) {
                return false;
            }
            return true;
        };
        let v274 = {
            active: false,
            x: 0,
            y: 0,
            aim: 0,
            info: {},
            dist: 0
        };
        this.canBeBroken = function (p377) {
            if (!inGame || !p377 || !enemy.length) {
                return;
            }
            let v404 = player.weapons[traps.notFast(p377) ? 1 : 0];
            let v405 = player[(v404 < 9 ? "prima" : "seconda") + "ryVariant"];
            let v406 = v405 != undefined ? config.weaponVariants[v405].val : 1;
            let v407 = near.secondaryIndex != undefined && near.primaryIndex != undefined ? near.secondaryIndex == 10 && (p377.health > items.weapons[near.weapons[0]].dmg || near.primaryIndex == 5) ? near.secondaryIndex : near.primaryIndex : 10;
            let v408 = near.secondaryIndex != undefined && near.primaryIndex != undefined ? near[(v407 < 9 ? "prima" : "seconda") + "ryVariant"] : 3;
            let v409 = config.weaponVariants[v408].val;
            let v410 = items.weapons[v404].dmg;
            let v411 = items.weapons[v407].dmg;
            let v412 = 3.3;
            let v413 = 0;
            if (near.reloads[v407] == 0 && this.canHit(near, p377, v407, 50)) {
                v413 += v411 * v412 * v409 * (items.weapons[v404].sDmg || 1);
            }
            if (traps.inTrap && (p377 == traps.info[1] || p377 == traps.info[0]) || v274.active && p377 == v274.info || clicks.right && player.reloads[v404] == 0) {
                v413 += v410 * v412 * v406 * (items.weapons[v404].sDmg || 1);
            }
            if (p377.health <= v413) {
                return true;
            }
            return false;
        };
        this.hitsToBreak = function (p378, p379) {
            if (!inGame || !p378 || !enemy.length || !p379) {
                return;
            }
            let v414 = traps.notFast(p378, p379) ? p379.weapons[1] : p379.weapons[0];
            let v415 = p379[(v414 < 9 ? "prima" : "seconda") + "ryVariant"];
            let v416 = v415 != undefined ? config.weaponVariants[v415].val : 1.18;
            let v417 = items.weapons[v414].dmg;
            let v418 = 3.3;
            let v419 = v417 * v418 * v416 * (items.weapons[v414].sDmg || 1);
            return Math.ceil(p378.health / v419);
        };
        this.canHit = function (p380, p381, p382, p383 = 0) {
            return UTILS.getDist(p380, p381, 2, 0) <= items.weapons[p382].range + p380.scale + p381.scale / 3.25 + p383;
        };
    }
}
class Projectile {
    constructor(players, ais, objectManager, items, config, UTILS, server) {

        // INIT:
        this.init = function(indx, x, y, dir, spd, dmg, rng, scl, owner) {
            this.active = true;
            this.tickActive = true;
            this.indx = indx;
            this.x = x;
            this.y = y;
            this.x2 = x;
            this.y2 = y;
            this.dir = dir;
            this.skipMov = true;
            this.speed = spd;
            this.dmg = dmg;
            this.scale = scl;
            this.range = rng;
            this.r2 = rng;
            this.owner = owner;
        };

        // UPDATE:
        this.update = function(delta) {
            if (this.active) {
                let tmpSpeed = this.speed * delta;
                if (!this.skipMov) {
                    this.x += tmpSpeed * Math.cos(this.dir);
                    this.y += tmpSpeed * Math.sin(this.dir);
                    this.range -= tmpSpeed;
                    if (this.range <= 0) {
                        this.x += this.range * Math.cos(this.dir);
                        this.y += this.range * Math.sin(this.dir);
                        tmpSpeed = 1;
                        this.range = 0;
                        this.active = false;
                    }
                } else {
                    this.skipMov = false;
                }
            }
        };
        this.tickUpdate = function(delta) {
            if (this.tickActive) {
                let tmpSpeed = this.speed * delta;
                if (!this.skipMov) {
                    this.x2 += tmpSpeed * Math.cos(this.dir);
                    this.y2 += tmpSpeed * Math.sin(this.dir);
                    this.r2 -= tmpSpeed;
                    if (this.r2 <= 0) {
                        this.x2 += this.r2 * Math.cos(this.dir);
                        this.y2 += this.r2 * Math.sin(this.dir);
                        tmpSpeed = 1;
                        this.r2 = 0;
                        this.tickActive = false;
                    }
                } else {
                    this.skipMov = false;
                }
            }
        };
    }
};
class Store {
    constructor() {
        // STORE HATS:
        this.hats = [{
            id: 45,
            name: "Shame!",
            dontSell: true,
            price: 0,
            scale: 120,
            desc: "hacks are for winners"
        }, {
            id: 51,
            name: "Moo Cap",
            price: 0,
            scale: 120,
            desc: "coolest mooer around"
        }, {
            id: 50,
            name: "Apple Cap",
            price: 0,
            scale: 120,
            desc: "apple farms remembers"
        }, {
            id: 28,
            name: "Moo Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 29,
            name: "Pig Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 30,
            name: "Fluff Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 36,
            name: "Pandou Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 37,
            name: "Bear Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 38,
            name: "Monkey Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 44,
            name: "Polar Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 35,
            name: "Fez Hat",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 42,
            name: "Enigma Hat",
            price: 0,
            scale: 120,
            desc: "join the enigma army"
        }, {
            id: 43,
            name: "Blitz Hat",
            price: 0,
            scale: 120,
            desc: "hey everybody i'm blitz"
        }, {
            id: 49,
            name: "Bob XIII Hat",
            price: 0,
            scale: 120,
            desc: "like and subscribe"
        }, {
            id: 57,
            name: "Pumpkin",
            price: 50,
            scale: 120,
            desc: "Spooooky"
        }, {
            id: 8,
            name: "Bummle Hat",
            price: 100,
            scale: 120,
            desc: "no effect"
        }, {
            id: 2,
            name: "Straw Hat",
            price: 500,
            scale: 120,
            desc: "no effect"
        }, {
            id: 15,
            name: "Winter Cap",
            price: 600,
            scale: 120,
            desc: "allows you to move at normal speed in snow",
            coldM: 1
        }, {
            id: 5,
            name: "Cowboy Hat",
            price: 1000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 4,
            name: "Ranger Hat",
            price: 2000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 18,
            name: "Explorer Hat",
            price: 2000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 31,
            name: "Flipper Hat",
            price: 2500,
            scale: 120,
            desc: "have more control while in water",
            watrImm: true
        }, {
            id: 1,
            name: "Marksman Cap",
            price: 3000,
            scale: 120,
            desc: "increases arrow speed and range",
            aMlt: 1.3
        }, {
            id: 10,
            name: "Bush Gear",
            price: 3000,
            scale: 160,
            desc: "allows you to disguise yourself as a bush"
        }, {
            id: 48,
            name: "Halo",
            price: 3000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 6,
            name: "Soldier Helmet",
            price: 4000,
            scale: 120,
            desc: "reduces damage taken but slows movement",
            spdMult: 0.94,
            dmgMult: 0.75
        }, {
            id: 23,
            name: "Anti Venom Gear",
            price: 4000,
            scale: 120,
            desc: "makes you immune to poison",
            poisonRes: 1
        }, {
            id: 13,
            name: "Medic Gear",
            price: 5000,
            scale: 110,
            desc: "slowly regenerates health over time",
            healthRegen: 3
        }, {
            id: 9,
            name: "Miners Helmet",
            price: 5000,
            scale: 120,
            desc: "earn 1 extra gold per resource",
            extraGold: 1
        }, {
            id: 32,
            name: "Musketeer Hat",
            price: 5000,
            scale: 120,
            desc: "reduces cost of projectiles",
            projCost: 0.5
        }, {
            id: 7,
            name: "Bull Helmet",
            price: 6000,
            scale: 120,
            desc: "increases damage done but drains health",
            healthRegen: -5,
            dmgMultO: 1.5,
            spdMult: 0.96
        }, {
            id: 22,
            name: "Emp Helmet",
            price: 6000,
            scale: 120,
            desc: "turrets won't attack but you move slower",
            antiTurret: 1,
            spdMult: 0.7
        }, {
            id: 12,
            name: "Booster Hat",
            price: 6000,
            scale: 120,
            desc: "increases your movement speed",
            spdMult: 1.16
        }, {
            id: 26,
            name: "Barbarian Armor",
            price: 8000,
            scale: 120,
            desc: "knocks back enemies that attack you",
            dmgK: 0.6
        }, {
            id: 21,
            name: "Plague Mask",
            price: 10000,
            scale: 120,
            desc: "melee attacks deal poison damage",
            poisonDmg: 5,
            poisonTime: 6
        }, {
            id: 46,
            name: "Bull Mask",
            price: 10000,
            scale: 120,
            desc: "bulls won't target you unless you attack them",
            bullRepel: 1
        }, {
            id: 14,
            name: "Windmill Hat",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "generates points while worn",
            pps: 1.5
        }, {
            id: 11,
            name: "Spike Gear",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "deal damage to players that damage you",
            dmg: 0.45
        }, {
            id: 53,
            name: "Turret Gear",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "you become a walking turret",
            turret: {
                proj: 1,
                range: 700,
                rate: 2500
            },
            spdMult: 0.7
        }, {
            id: 20,
            name: "Samurai Armor",
            price: 12000,
            scale: 120,
            desc: "increased attack speed and fire rate",
            atkSpd: 0.78
        }, {
            id: 58,
            name: "Dark Knight",
            price: 12000,
            scale: 120,
            desc: "restores health when you deal damage",
            healD: 0.4
        }, {
            id: 27,
            name: "Scavenger Gear",
            price: 15000,
            scale: 120,
            desc: "earn double points for each kill",
            kScrM: 2
        }, {
            id: 40,
            name: "Tank Gear",
            price: 15000,
            scale: 120,
            desc: "increased damage to buildings but slower movement",
            spdMult: 0.3,
            bDmg: 3.3
        }, {
            id: 52,
            name: "Thief Gear",
            price: 15000,
            scale: 120,
            desc: "steal half of a players gold when you kill them",
            goldSteal: 0.5
        }, {
            id: 55,
            name: "Bloodthirster",
            price: 20000,
            scale: 120,
            desc: "Restore Health when dealing damage. And increased damage",
            healD: 0.25,
            dmgMultO: 1.2,
        }, {
            id: 56,
            name: "Assassin Gear",
            price: 20000,
            scale: 120,
            desc: "Go invisible when not moving. Can't eat. Increased speed",
            noEat: true,
            spdMult: 1.1,
            invisTimer: 1000
        }];

        // STORE ACCESSORIES:
        this.accessories = [{
            id: 12,
            name: "Snowball",
            price: 1000,
            scale: 105,
            xOff: 18,
            desc: "no effect"
        }, {
            id: 9,
            name: "Tree Cape",
            price: 1000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 10,
            name: "Stone Cape",
            price: 1000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 3,
            name: "Cookie Cape",
            price: 1500,
            scale: 90,
            desc: "no effect"
        }, {
            id: 8,
            name: "Cow Cape",
            price: 2000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 11,
            name: "Monkey Tail",
            price: 2000,
            scale: 97,
            xOff: 25,
            desc: "Super speed but reduced damage",
            spdMult: 1.35,
            dmgMultO: 0.2
        }, {
            id: 17,
            name: "Apple Basket",
            price: 3000,
            scale: 80,
            xOff: 12,
            desc: "slowly regenerates health over time",
            healthRegen: 1
        }, {
            id: 6,
            name: "Winter Cape",
            price: 3000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 4,
            name: "Skull Cape",
            price: 4000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 5,
            name: "Dash Cape",
            price: 5000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 2,
            name: "Dragon Cape",
            price: 6000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 1,
            name: "Super Cape",
            price: 8000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 7,
            name: "Troll Cape",
            price: 8000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 14,
            name: "Thorns",
            price: 10000,
            scale: 115,
            xOff: 20,
            desc: "no effect"
        }, {
            id: 15,
            name: "Blockades",
            price: 10000,
            scale: 95,
            xOff: 15,
            desc: "no effect"
        }, {
            id: 20,
            name: "Devils Tail",
            price: 10000,
            scale: 95,
            xOff: 20,
            desc: "no effect"
        }, {
            id: 16,
            name: "Sawblade",
            price: 12000,
            scale: 90,
            spin: true,
            xOff: 0,
            desc: "deal damage to players that damage you",
            dmg: 0.15
        }, {
            id: 13,
            name: "Angel Wings",
            price: 15000,
            scale: 138,
            xOff: 22,
            desc: "slowly regenerates health over time",
            healthRegen: 3
        }, {
            id: 19,
            name: "Shadow Wings",
            price: 15000,
            scale: 138,
            xOff: 22,
            desc: "increased movement speed",
            spdMult: 1.1
        }, {
            id: 18,
            name: "Blood Wings",
            price: 20000,
            scale: 178,
            xOff: 26,
            desc: "restores health when you deal damage",
            healD: 0.2
        }, {
            id: 21,
            name: "Corrupt X Wings",
            price: 20000,
            scale: 178,
            xOff: 26,
            desc: "deal damage to players that damage you",
            dmg: 0.25
        }];
    }
};
class ProjectileManager {
    constructor(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
        this.addProjectile = function(x, y, dir, range, speed, indx, owner, ignoreObj, layer, inWindow) {
            let tmpData = items.projectiles[indx];
            let tmpProj;
            for (let i = 0; i < projectiles.length; ++i) {
                if (!projectiles[i].active) {
                    tmpProj = projectiles[i];
                    break;
                }
            }
            if (!tmpProj) {
                tmpProj = new Projectile(players, ais, objectManager, items, config, UTILS, server);
                tmpProj.sid = projectiles.length;
                projectiles.push(tmpProj);
            }
            tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
            tmpProj.ignoreObj = ignoreObj;
            tmpProj.layer = layer || tmpData.layer;
            tmpProj.inWindow = inWindow;
            tmpProj.src = tmpData.src;
            return tmpProj;
        };
    }
};
class AiManager {

    // AI MANAGER:
    constructor(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {

        // AI TYPES:
        this.aiTypes = [{
            id: 0,
            src: "cow_1",
            killScore: 150,
            health: 500,
            weightM: 0.8,
            speed: 0.00095,
            turnSpeed: 0.001,
            scale: 72,
            drop: ["food", 50]
        }, {
            id: 1,
            src: "pig_1",
            killScore: 200,
            health: 800,
            weightM: 0.6,
            speed: 0.00085,
            turnSpeed: 0.001,
            scale: 72,
            drop: ["food", 80]
        }, {
            id: 2,
            name: "Bull",
            src: "bull_2",
            hostile: true,
            dmg: 20,
            killScore: 1000,
            health: 1800,
            weightM: 0.5,
            speed: 0.00094,
            turnSpeed: 0.00074,
            scale: 78,
            viewRange: 800,
            chargePlayer: true,
            drop: ["food", 100]
        }, {
            id: 3,
            name: "Bully",
            src: "bull_1",
            hostile: true,
            dmg: 20,
            killScore: 2000,
            health: 2800,
            weightM: 0.45,
            speed: 0.001,
            turnSpeed: 0.0008,
            scale: 90,
            viewRange: 900,
            chargePlayer: true,
            drop: ["food", 400]
        }, {
            id: 4,
            name: "Wolf",
            src: "wolf_1",
            hostile: true,
            dmg: 8,
            killScore: 500,
            health: 300,
            weightM: 0.45,
            speed: 0.001,
            turnSpeed: 0.002,
            scale: 84,
            viewRange: 800,
            chargePlayer: true,
            drop: ["food", 200]
        }, {
            id: 5,
            name: "Quack",
            src: "chicken_1",
            dmg: 8,
            killScore: 2000,
            noTrap: true,
            health: 300,
            weightM: 0.2,
            speed: 0.0018,
            turnSpeed: 0.006,
            scale: 70,
            drop: ["food", 100]
        }, {
            id: 6,
            name: "MOOSTAFA",
            nameScale: 50,
            src: "enemy",
            hostile: true,
            dontRun: true,
            fixedSpawn: true,
            spawnDelay: 60000,
            noTrap: true,
            colDmg: 100,
            dmg: 40,
            killScore: 8000,
            health: 18000,
            weightM: 0.4,
            speed: 0.0007,
            turnSpeed: 0.01,
            scale: 80,
            spriteMlt: 1.8,
            leapForce: 0.9,
            viewRange: 1000,
            hitRange: 210,
            hitDelay: 1000,
            chargePlayer: true,
            drop: ["food", 100]
        }, {
            id: 7,
            name: "Treasure",
            hostile: true,
            nameScale: 35,
            src: "crate_1",
            fixedSpawn: true,
            spawnDelay: 120000,
            colDmg: 200,
            killScore: 5000,
            health: 20000,
            weightM: 0.1,
            speed: 0.0,
            turnSpeed: 0.0,
            scale: 70,
            spriteMlt: 1.0
        }, {
            id: 8,
            name: "MOOFIE",
            src: "wolf_2",
            hostile: true,
            fixedSpawn: true,
            dontRun: true,
            hitScare: 4,
            spawnDelay: 30000,
            noTrap: true,
            nameScale: 35,
            dmg: 10,
            colDmg: 100,
            killScore: 3000,
            health: 7000,
            weightM: 0.45,
            speed: 0.0015,
            turnSpeed: 0.002,
            scale: 90,
            viewRange: 800,
            chargePlayer: true,
            drop: ["food", 1000]
        }, {
            id: 9,
            name: "💀MOOFIE",
            src: "wolf_2",
            hostile: !0,
            fixedSpawn: !0,
            dontRun: !0,
            hitScare: 50,
            spawnDelay: 6e4,
            noTrap: !0,
            nameScale: 35,
            dmg: 12,
            colDmg: 100,
            killScore: 3e3,
            health: 9e3,
            weightM: .45,
            speed: .0015,
            turnSpeed: .0025,
            scale: 94,
            viewRange: 1440,
            chargePlayer: !0,
            drop: ["food", 3e3],
            minSpawnRange: .85,
            maxSpawnRange: .9
        }, {
            id: 10,
            name: "💀Wolf",
            src: "wolf_1",
            hostile: !0,
            fixedSpawn: !0,
            dontRun: !0,
            hitScare: 50,
            spawnDelay: 3e4,
            dmg: 10,
            killScore: 700,
            health: 500,
            weightM: .45,
            speed: .00115,
            turnSpeed: .0025,
            scale: 88,
            viewRange: 1440,
            chargePlayer: !0,
            drop: ["food", 400],
            minSpawnRange: .85,
            maxSpawnRange: .9
        }, {
            id: 11,
            name: "💀Bully",
            src: "bull_1",
            hostile: !0,
            fixedSpawn: !0,
            dontRun: !0,
            hitScare: 50,
            dmg: 20,
            killScore: 5e3,
            health: 5e3,
            spawnDelay: 1e5,
            weightM: .45,
            speed: .00115,
            turnSpeed: .0025,
            scale: 94,
            viewRange: 1440,
            chargePlayer: !0,
            drop: ["food", 800],
            minSpawnRange: .85,
            maxSpawnRange: .9
        }];

        // SPAWN AI:
        this.spawn = function(x, y, dir, index) {
            let tmpObj = ais.find((tmp) => !tmp.active);
            if (!tmpObj) {
                tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server);
                ais.push(tmpObj);
            }
            tmpObj.init(x, y, dir, index, this.aiTypes[index]);
            return tmpObj;
        };
    }

};
class AI {
    constructor(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
        this.sid = sid;
        this.isAI = true;
        this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);

        // INIT:
        this.init = function(x, y, dir, index, data) {
            this.x = x;
            this.y = y;
            this.startX = data.fixedSpawn ? x : null;
            this.startY = data.fixedSpawn ? y : null;
            this.xVel = 0;
            this.yVel = 0;
            this.zIndex = 0;
            this.dir = dir;
            this.dirPlus = 0;
            this.showName = 'aaa';
            this.index = index;
            this.src = data.src;
            if (data.name) this.name = data.name;
            this.weightM = data.weightM;
            this.speed = data.speed;
            this.killScore = data.killScore;
            this.turnSpeed = data.turnSpeed;
            this.scale = data.scale;
            this.maxHealth = data.health;
            this.leapForce = data.leapForce;
            this.health = this.maxHealth;
            this.chargePlayer = data.chargePlayer;
            this.viewRange = data.viewRange;
            this.drop = data.drop;
            this.dmg = data.dmg;
            this.hostile = data.hostile;
            this.dontRun = data.dontRun;
            this.hitRange = data.hitRange;
            this.hitDelay = data.hitDelay;
            this.hitScare = data.hitScare;
            this.spriteMlt = data.spriteMlt;
            this.nameScale = data.nameScale;
            this.colDmg = data.colDmg;
            this.noTrap = data.noTrap;
            this.spawnDelay = data.spawnDelay;
            this.hitWait = 0;
            this.waitCount = 1000;
            this.moveCount = 0;
            this.targetDir = 0;
            this.active = true;
            this.alive = true;
            this.runFrom = null;
            this.chargeTarget = null;
            this.dmgOverTime = {};
        };

        let tmpRatio = 0;
        let animIndex = 0;
        this.animate = function(delta) {
            if (this.animTime > 0) {
                this.animTime -= delta;
                if (this.animTime <= 0) {
                    this.animTime = 0;
                    this.dirPlus = 0;
                    tmpRatio = 0;
                    animIndex = 0;
                } else {
                    if (animIndex == 0) {
                        tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                        if (tmpRatio >= 1) {
                            tmpRatio = 1;
                            animIndex = 1;
                        }
                    } else {
                        tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                    }
                }
            }
        };

        // ANIMATION:
        this.startAnim = function() {
            this.animTime = this.animSpeed = 600;
            this.targetAngle = Math.PI * 0.8;
            tmpRatio = 0;
            animIndex = 0;
        };

    };

};
class addCh {
    constructor(x, y, chat, tmpObj) {
        this.x = x;
        this.y = y;
        this.alpha = 0;
        this.active = true;
        this.alive = false;
        this.chat = chat;
        this.owner = tmpObj;
    };
};
class DeadPlayer {
    constructor(x, y, dir, buildIndex, weaponIndex, weaponVariant, skinColor, scale, name) {
        this.x = x;
        this.y = y;
        this.lastDir = dir;
        this.dir = dir + Math.PI;
        this.buildIndex = buildIndex;
        this.weaponIndex = weaponIndex;
        this.weaponVariant = weaponVariant;
        this.skinColor = skinColor;
        this.scale = scale;
        this.visScale = 0;
        this.name = name;
        this.alpha = 1;
        this.active = true;
        this.animate = function(delta) {
            let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
            if (d2 > 0.01) {
                this.dir += d2 / 20;
            } else {
                this.dir = this.lastDir;
            }
            if (this.visScale < this.scale) {
                this.visScale += delta / (this.scale / 2);
                if (this.visScale >= this.scale) {
                    this.visScale = this.scale;
                }
            }
            this.alpha -= delta / 30000;
            if (this.alpha <= 0) {
                this.alpha = 0;
                this.active = false;
            }
        }
    }
};
class Player {
    constructor(id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
        this.id = id;
        this.sid = sid;
        this.tmpScore = 0;
        this.team = null;
        this.latestSkin = 0;
        this.oldSkinIndex = 0;
        this.skinIndex = 0;
        this.latestTail = 0;
        this.oldTailIndex = 0;
        this.tailIndex = 0;
        this.hitTime = 0;
        this.lastHit = 0;
        this.showName = 'NOOO';
        this.tails = {};
        for (let i = 0; i < accessories.length; ++i) {
            if (accessories[i].price <= 0)
                this.tails[accessories[i].id] = 1;
        }
        this.skins = {};
        for (let i = 0; i < hats.length; ++i) {
            if (hats[i].price <= 0)
                this.skins[hats[i].id] = 1;
        }
        this.points = 0;
        this.dt = 0;
        this.hidden = false;
        this.itemCounts = {};
        this.isPlayer = true;
        this.pps = 0;
        this.moveDir = undefined;
        this.skinRot = 0;
        this.lastPing = 0;
        this.iconIndex = 0;
        this.skinColor = 0;
        this.dist2 = 0;
        this.aim2 = 0;
        this.maxSpeed = 1;
        this.chat = {
            message: null,
            count: 0
        };
        this.backupNobull = true;
        this.circle = false;
        this.circleRad = 200;
        this.circleRadSpd = 0.1;
        this.cAngle = 0;
        // SPAWN:
        this.spawn = function(moofoll) {
            this.attacked = false;
            this.timeDamaged = 0;
            this.timeHealed = 100;
            this.pinge = 0;
            this.millPlace = 'NOOO';
            this.lastshamecount = 0;
            this.death = false;
            this.spinDir = 0;
            this.sync = false;
            this.antiBull = 0;
            this.bullTimer = 0;
            this.poisonTimer = 0;
            this.active = true;
            this.alive = true;
            this.lockMove = false;
            this.lockDir = false;
            this.minimapCounter = 0;
            this.chatCountdown = 0;
            this.shameCount = 0;
            this.shameTimer = 0;
            this.sentTo = {};
            this.gathering = 0;
            this.gatherIndex = 0;
            this.shooting = {};
            this.shootIndex = 9;
            this.autoGather = 0;
            this.animTime = 0;
            this.animSpeed = 0;
            this.mouseState = 0;
            this.buildIndex = -1;
            this.weaponIndex = 0;
            this.weaponCode = 0;
            this.weaponVariant = 0;
            this.primaryIndex = undefined;
            this.secondaryIndex = undefined;
            this.dmgOverTime = {};
            this.noMovTimer = 0;
            this.maxXP = 300;
            this.XP = 0;
            this.age = 1;
            this.kills = 0;
            this.upgrAge = 2;
            this.upgradePoints = 0;
            this.x = 0;
            this.y = 0;
            this.oldXY = {
                x: 0,
                y: 0
            };
            this.zIndex = 0;
            this.xVel = 0;
            this.yVel = 0;
            this.slowMult = 1;
            this.dir = 0;
            this.dirPlus = 0;
            this.targetDir = 0;
            this.targetAngle = 0;
            this.maxHealth = 100;
            this.health = this.maxHealth;
            this.oldHealth = this.maxHealth;
            this.damaged = 0;
            this.scale = config.playerScale;
            this.speed = config.playerSpeed;
            this.resetMoveDir();
            this.resetResources(moofoll);
            this.items = [0, 3, 6, 10];
            this.weapons = [0];
            this.shootCount = 0;
            this.weaponXP = [3000];
            this.reloads = {
                0: 0,
                1: 0,
                2: 0,
                3: 0,
                4: 0,
                5: 0,
                6: 0,
                7: 0,
                8: 0,
                9: 0,
                10: 0,
                11: 0,
                12: 0,
                13: 0,
                14: 0,
                15: 0,
                53: 0,
            };
            this.bowThreat = {
                9: 0,
                12: 0,
                13: 0,
                15: 0,
            };
            this.damageThreat = 0;
            this.inTrap = false;
            this.canEmpAnti = false;
            this.empAnti = false;
            this.soldierAnti = false;
            this.BarbarianAnti = false;
            this.poisonTick = 0;
            this.bullTick = 0;
            this.setPoisonTick = false;
            this.setBullTick = false;
            this.antiTimer = 2;
        };

        // RESET MOVE DIR:
        this.resetMoveDir = function() {
            this.moveDir = undefined;
        };

        // RESET RESOURCES:
        this.resetResources = function(moofoll) {
            for (let i = 0; i < config.resourceTypes.length; ++i) {
                this[config.resourceTypes[i]] = moofoll ? 100 : 0;
            }
        };

        // ADD ITEM:
        this.getItemType = function(id) {
            let findindx = this.items.findIndex((ids) => ids == id);
            if (findindx != -1) {
                return findindx;
            } else {
                return items.checkItem.index(id, this.items);
            }
        };

        // SET DATA:
        this.setData = function(data) {
            this.id = data[0];
            this.sid = data[1];
            this.name = data[2];
            this.x = data[3];
            this.y = data[4];
            this.dir = data[5];
            this.health = data[6];
            this.maxHealth = data[7];
            this.scale = data[8];
            this.skinColor = data[9];
        };
        let plaguemask =false;
        // UPDATE POISON TICK:
        this.updateTimer = function() {
            this.bullTimer -= 1;
            if (this.bullTimer <= 0) {
                this.setBullTick = false;
                this.bullTick = game.tick - 1;
                this.bullTimer = config.serverUpdateRate;
            }
            this.poisonTimer -= 1;
            if (this.poisonTimer < 0) {
                this.setPoisonTick = false;
                this.poisonTick = game.tick - 1;
                this.poisonTimer = config.serverUpdateRate;
                plaguemask = true;
                setTimeout(() => {
                    plaguemask = false;
                }, 1000);
            } else if(this.poisonTimer >= 0) {
                plaguemask = false;
            }
        };
        this.update = function(delta) {
            if (this.sid == playerSID) {
                this.circleRad = parseInt() || 0;
                this.circleRadSpd = parseFloat() || 0;
                this.cAngle += this.circleRadSpd;
            }
            if (this.active) {

                // MOVE:
                let gear = {
                    skin: findID(hats, this.skinIndex),
                    tail: findID(accessories, this.tailIndex)
                }
                let spdMult = ((this.buildIndex >= 0) ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (gear.skin ? (gear.skin.spdMult || 1) : 1) * (gear.tail ? (gear.tail.spdMult || 1) : 1) * (this.y <= config.snowBiomeTop ? ((gear.skin && gear.skin.coldM) ? 1 : config.snowSpeed) : 1) * this.slowMult;
                this.maxSpeed = spdMult;

            }
        };

        let tmpRatio = 0;
        let animIndex = 0;
        this.animate = function(delta) {
            if (this.animTime > 0) {
                this.animTime -= delta;
                if (this.animTime <= 0) {
                    this.animTime = 0;
                    this.dirPlus = 0;
                    tmpRatio = 0;
                    animIndex = 0;
                } else {
                    if (animIndex == 0) {
                        tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                        if (tmpRatio >= 1) {
                            tmpRatio = 1;
                            animIndex = 1;
                        }
                    } else {
                        tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                        this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                    }
                }
            }
        };

        // GATHER ANIMATION:
        this.startAnim = function(didHit, index) {
            this.animTime = this.animSpeed = items.weapons[index].speed;
            this.targetAngle = (didHit ? -config.hitAngle : -Math.PI);
            tmpRatio = 0;
            animIndex = 0;
        };

        // CAN SEE:
        this.canSee = function(other) {
            if (!other) return false;
            let dx = Math.abs(other.x - this.x) - other.scale;
            let dy = Math.abs(other.y - this.y) - other.scale;
            return dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3;
        };

        // SHAME SYSTEM:
        this.judgeShame = function() {
            this.lastshamecount = this.shameCount;
            if (this.oldHealth < this.health) {
                if (this.hitTime) {
                    let timeSinceHit = game.tick - this.hitTime;
                    this.lastHit = game.tick;
                    this.hitTime = 0;
                    if (timeSinceHit < 2) {
                        this.shameCount++;
                    } else {
                        this.shameCount = Math.max(0, this.shameCount - 2);
                    }
                }
            } else if (this.oldHealth > this.health) {
                this.hitTime = game.tick;
            }
        };
        this.addShameTimer = function() {
            this.shameCount = 0;
            this.shameTimer = 30;
            let interval = setInterval(() => {
                this.shameTimer--;
                if (this.shameTimer <= 0) {
                    clearInterval(interval);
                }
            }, 1000);
        };

        // CHECK TEAM:
        this.isTeam = function(tmpObj) {
            return (this == tmpObj || (this.team && this.team == tmpObj.team));
        };

        // FOR THE PLAYER:
        this.findAllianceBySid = function(sid) {
            return this.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
        };
        this.checkCanInsta = function(nobull) {
            let totally = 0;
            if (this.alive && inGame) {
                let primary = {
                    weapon: this.weapons[0],
                    variant: this.primaryVariant,
                    dmg: this.weapons[0] == undefined ? 0 : items.weapons[this.weapons[0]].dmg,
                };
                let secondary = {
                    weapon: this.weapons[1],
                    variant: this.secondaryVariant,
                    dmg: this.weapons[1] == undefined ? 0 : items.weapons[this.weapons[1]].Pdmg,
                };
                let bull = this.skins[7] && !nobull ? 1.5 : 1;
                let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1;
                if (primary.weapon != undefined && this.reloads[primary.weapon] == 0) {
                    totally += primary.dmg * pV * bull;
                }
                if (secondary.weapon != undefined && this.reloads[secondary.weapon] == 0) {
                    totally += secondary.dmg;
                }
                if (this.skins[53] && this.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate) && near.skinIndex != 22) {
                    totally += 25;
                }
                totally *= near.skinIndex == 6 ? 0.75 : 1;
                return totally;
            }
            return 0;
        };

        // UPDATE WEAPON RELOAD:
        this.manageReload = function() {
            if (this.shooting[53]) {
                this.shooting[53] = 0;
                this.reloads[53] = (2500 - game.tickRate);
            } else {
                if (this.reloads[53] > 0) {
                    this.reloads[53] = Math.max(0, this.reloads[53] - game.tickRate);
                }
            }
            // PREPLACER
            if (this.reloads[this.weaponIndex] <= 1/20) {
                // place(2, getAttackDir());
                let index = this.weaponIndex;
                let nearObja = liztobj.filter((e) => (e.active || e.alive) && e.health < e.maxHealth && e.group !== undefined && UTILS.getDist(e, player, 0, 2) <= (items.weapons[player.weaponIndex].range + e.scale));
                for(let i = 0; i < nearObja.length; i++) {
                    let aaa = nearObja[i];

                    let val = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * 3.3;
                    let valaa = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1);
                    if(aaa.health - (valaa) <= 0 && near.length) {
                        place(near.dist2<((near.scale * 1.8) + 50)?4:2, caf(aaa, player) + Math.PI)
                        console.log("preplaced");
                    }
                }
            }
            if (this.gathering || this.shooting[1]) {
                if (this.gathering) {
                    this.gathering = 0;
                    this.reloads[this.gatherIndex] = (items.weapons[this.gatherIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                    this.attacked = true;
                }
                if (this.shooting[1]) {
                    this.shooting[1] = 0;
                    this.reloads[this.shootIndex] = (items.weapons[this.shootIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                    this.attacked = true;
                }
            } else {
                this.attacked = false;
                if (this.buildIndex < 0) {
                    if (this.reloads[this.weaponIndex] > 0) {
                        this.reloads[this.weaponIndex] = Math.max(0, this.reloads[this.weaponIndex] - game.tickRate);
                        if (this == player) {
                            if (getEl("weaponGrind").checked) {
                                for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                    checkPlace(player.getItemType(22), i);
                                }
                            }
                        }
                        if (this.reloads[this.primaryIndex] == 0 && this.reloads[this.weaponIndex] == 0) {
                            this.antiBull++;
                            game.tickBase(() => {
                                this.antiBull = 0;
                            }, 1);
                        }
                    }
                }
            }
        }
        // UNOREVERSE CODE
        function _0x3eab(){const _0x816252=['30Qhyvgi','weapons','left','isTrue','atan2','preplacer','sqrt','yVel','range','39868AHNfDJ','alive','length','checked','stype','filter','getDist','buildHealth','5485248HdQuoQ','Preplace','inTrap','9529736MNMlUO','damage','240877lDshnc','aim2','trunc','deg2rad','gatherAnimation','378168NKGEKe','damagePerShot','sort','dmg','216128EhgpEZ','dist2','abs','getDirect','getElementById','1976721tqFRMa','absorb','value'];_0x3eab=function(){return _0x816252;};return _0x3eab();}const _0x1d2772=_0x4c85;(function(_0x21dc42,_0x46665c){const _0x507ba7=_0x4c85,_0x450dde=_0x21dc42();while(!![]){try{const _0x1824bf=parseInt(_0x507ba7(0x1c1))/0x1+-parseInt(_0x507ba7(0x1a3))/0x2+parseInt(_0x507ba7(0x1a8))/0x3+-parseInt(_0x507ba7(0x1b4))/0x4*(-parseInt(_0x507ba7(0x1ab))/0x5)+parseInt(_0x507ba7(0x1bc))/0x6+parseInt(_0x507ba7(0x19f))/0x7+-parseInt(_0x507ba7(0x1bf))/0x8;if(_0x1824bf===_0x46665c)break;else _0x450dde['push'](_0x450dde['shift']());}catch(_0x988d1c){_0x450dde['push'](_0x450dde['shift']());}}}(_0x3eab,0x99739));var preplaceDelay={'killObject':-0x1,'gatherAnimation':-0x1,'total':function(){const _0x4aa890=_0x4c85;return new Date()-Math[_0x4aa890(0x1a5)](Math[_0x4aa890(0x1c3)](this['killObject']-this[_0x4aa890(0x19e)]));}};function _0x4c85(_0x5373f1,_0x5287ca){const _0x3eabe0=_0x3eab();return _0x4c85=function(_0x4c8592,_0x42bdaa){_0x4c8592=_0x4c8592-0x19e;let _0x365b3a=_0x3eabe0[_0x4c8592];return _0x365b3a;},_0x4c85(_0x5373f1,_0x5287ca);}let closestBuild=[];function findTargetBuildToSpike(_0xa645bb,_0x2b5284,_0x4749b5,_0x551fe6){const _0x1653eb=_0x4c85;if(!document[_0x1653eb(0x1a7)]('sp')[_0x1653eb(0x1b7)])return;if(!enemy[_0x1653eb(0x1b6)])return;closestBuild=gameObjects['filter'](_0x3f82eb=>_0x3f82eb['active']&&_0x3f82eb[_0x1653eb(0x1bb)])[_0x1653eb(0x1a1)]((_0x579aa9,_0x5a7537)=>UTILS[_0x1653eb(0x1ba)](_0x579aa9,player,0x0,0x2)-UTILS[_0x1653eb(0x1ba)](_0x5a7537,player,0x0,0x2))[0x0];if(!closestBuild)return;_0xa645bb=0xfa,preplaceDelay,_0x2b5284=0xfa,_0x4749b5=UTILS[_0x1653eb(0x1ba)](closestBuild,player,0x0,0x2),_0x551fe6=UTILS[_0x1653eb(0x1a6)](closestBuild,player,0x0,0x2);if(player[_0x1653eb(0x1b5)]&&_0x4749b5<_0xa645bb&&near[_0x1653eb(0x1a4)]<_0x2b5284&&!traps[_0x1653eb(0x1be)]&&!instaC[_0x1653eb(0x1ae)]&&!instaC['canSpikeTick']&&!clicks['middle']&&!clicks[_0x1653eb(0x1ad)]){if(closestBuild[_0x1653eb(0x1bb)]<items[_0x1653eb(0x1ac)][player[_0x1653eb(0x1ac)][0x1]==0xa?player['weapons'][0x1]:player[_0x1653eb(0x1ac)][0x0]][_0x1653eb(0x1a2)]*0x2){if(document[_0x1653eb(0x1a7)](_0x1653eb(0x1b8))[_0x1653eb(0x1aa)]=='D')for(let _0x524b9c=0x0;_0x524b9c<0x6;_0x524b9c++){let _0x545633=_0x524b9c+0x2d*(_0x524b9c%0x2?-0x1:0x1)/0xb4*Math['PI']+near[_0x1653eb(0x1c2)];checkPlace(0x2,_0x524b9c);}else for(let _0x5adff2=0x0;_0x5adff2<0x4;_0x5adff2++){let _0x489256=_0x5adff2+0x2d*(_0x5adff2%0x2?-0x1:0x1)/0xb4*Math['PI']+near[_0x1653eb(0x1c2)];checkPlace(0x2,_0x5adff2);}}}}this[_0x1d2772(0x1b0)]=function(){const _0x1448da=_0x1d2772;if(traps[_0x1448da(0x1be)])return;if(!getEl(_0x1448da(0x1bd))[_0x1448da(0x1b7)]&&preplaceDelay)return;const _0x59ece0=items[_0x1448da(0x1ac)][player['weaponIndex']][_0x1448da(0x1b3)]+0x46,_0x3aa46e=_0x59ece0**0x2,{x2:_0x44f077,y2:_0x502119}=player,_0x4f8ec5=gameObjects[_0x1448da(0x1b9)](_0x3d3bd2=>{const {x2:_0x1ec9a2,y2:_0x236670,buildHealth:_0x3505ff}=_0x3d3bd2,_0x1a0839=(_0x1ec9a2-_0x44f077)**0x2+(_0x236670-_0x502119)**0x2;return near&&_0x3505ff<=272.58&&_0x1a0839<=_0x3aa46e;});if(_0x4f8ec5[_0x1448da(0x1b6)]>0x0){const {x2:_0x1b5f48,y2:_0x31e339}=_0x4f8ec5[0x0],_0x8181c=UTILS[_0x1448da(0x1a6)]({'x2':_0x1b5f48,'y2':_0x31e339},player,0x0,0x2),_0x5cbc14=0x46;let _0x2cb004=Math[_0x1448da(0x1b1)](near['xVel']*near['xVel']+near[_0x1448da(0x1b2)]*near[_0x1448da(0x1b2)]),_0x2ee721=Math[_0x1448da(0x1af)](near[_0x1448da(0x1b2)],near['xVel']),_0x2e58f9=null,_0x59587d=Infinity;for(let _0x1f5a16=0x0;_0x1f5a16<0x168;_0x1f5a16+=0x1e){let _0xd5c799=UTILS[_0x1448da(0x1c4)](_0x1f5a16),_0x1d2ada=UTILS['getDist'](near,player,0x0,0x2)+_0x2cb004*Math['sin'](_0x2ee721)+_0x5cbc14;_0x1d2ada<_0x59587d&&(_0x59587d=_0x1d2ada,_0x2e58f9=_0xd5c799);}const _0x11a846=0x5,_0x9a41a=(_0x4f8ec5[0x0]['buildHealth']-player[_0x1448da(0x1c0)])/(player[_0x1448da(0x1a0)]-_0x4f8ec5[0x0][_0x1448da(0x1a9)]),_0x371db2=_0x59587d/_0x2cb004;_0x9a41a+_0x11a846<=_0x371db2&&this['testCanPlace'](0x4,_0x2e58f9,_0x2e58f9+Math['PI']*0x2,Math['PI']/0x18,_0x8181c,_0x5cbc14);}};
        // FOR ANTI INSTA:
        this.addDamageThreat = function (tmpObj) {
            const defaultPrimaryDmg = 45;
            const defaultSecondaryDmg = 35;
            const bullMultiplier = 1.5;
            const defaultVariantVal = 1.18;
            const skinIndexPenalty = 0.75;
            const closeRangeThreshold = 300;
            const additionalThreatReloadTickRate = game.tickRate;
            const additionalThreatValue = 25;

            let { primaryIndex, primaryVariant, secondaryIndex, secondaryVariant, reloads, dist2 } = this;
            let { weapons } = items;
            let { weaponVariants } = config;

            let primary = {
                weapon: primaryIndex,
                variant: primaryVariant,
                dmg: primaryIndex === undefined ? defaultPrimaryDmg : weapons[primaryIndex].dmg
            };

            let secondary = {
                weapon: secondaryIndex,
                variant: secondaryVariant,
                dmg: secondaryIndex === undefined ? defaultSecondaryDmg : weapons[secondaryIndex].Pdmg
            };

            let primaryVariantValue = primary.variant !== undefined ? weaponVariants[primary.variant].val : defaultVariantVal;
            let secondaryVariantValue = secondary.variant !== undefined && ![9, 12, 17, 15].includes(secondary.weapon) ? weaponVariants[secondary.variant].val : defaultVariantVal;

            let damageThreat = 0;

            if (primary.weapon === undefined || reloads[primary.weapon] === 0) {
                damageThreat += primary.dmg * primaryVariantValue * bullMultiplier;
            }

            if (secondary.weapon === undefined || reloads[secondary.weapon] === 0) {
                damageThreat += secondary.dmg * secondaryVariantValue;
            }

            if (reloads[53] <= additionalThreatReloadTickRate) {
                damageThreat += additionalThreatValue;
            }

            damageThreat *= tmpObj.skinIndex === 6 ? skinIndexPenalty : 1;

            if (!this.isTeam(tmpObj) && dist2 <= closeRangeThreshold) {
                tmpObj.damageThreat += damageThreat;
            }
        };

        // ANTI
        this.addDamageProbability = function (tmpObj) {
            let primary = {
                weapon: this.primaryIndex,
                variant: this.primaryVariant
            };
            primary.dmg = primary.weapon == undefined ? 45 : items.weapons[primary.weapon].dmg;
            let secondary = {
                weapon: this.secondaryIndex,
                variant: this.secondaryVariant
            };
            secondary.dmg = secondary.weapon == undefined ? 50 : items.weapons[secondary.weapon].Pdmg;
            let bull = 1.5;
            let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
            let sV = secondary.variant != undefined ? [9, 12, 17, 15].includes(secondary.weapon) ? 1 : config.weaponVariants[secondary.variant].val : 1.18;
            if (primary.weapon == undefined ? true : this.reloads[primary.weapon] == 0) {
                this.damageProbably += primary.dmg * pV * bull * 0.75;
            }
            if (secondary.weapon == undefined ? true : this.reloads[secondary.weapon] == 0) {
                this.damageProbably += secondary.dmg * sV;
            }
            this.damageProbably *= 0.75;
            if (!this.isTeam(tmpObj)) {
                if (this.dist2 <= 300) {
                    tmpObj.damageProbably += this.damageProbably;
                }
            }
        };
    }
};

// SOME CODES:
function sendUpgrade(index) {
    player.reloads[index] = 0;
    packet("H", index);
}

function storeEquip(id, index) {
    packet("c", 0, id, index);
}

function storeBuy(id, index) {
    packet("c", 1, id, index);
}

function buyEquip(id, index) {
    let nID = player.skins[6] ? 6 : 0;
    if (player.alive && inGame) {
        if (index == 0) {
            if (player.skins[id]) {
                if (player.latestSkin != id) {
                    packet("c", 0, id, 0);
                }
            } else {
                if (getEl("autoBuyEquip").checked) {
                    let find = findID(hats, id);
                    if (find) {
                        if (player.points >= find.price) {
                            packet("c", 1, id, 0);
                            packet("c", 0, id, 0);
                        } else {
                            if (player.latestSkin != nID) {
                                packet("c", 0, nID, 0);
                            }
                        }
                    } else {
                        if (player.latestSkin != nID) {
                            packet("c", 0, nID, 0);
                        }
                    }
                } else {
                    if (player.latestSkin != nID) {
                        packet("c", 0, nID, 0);
                    }
                }
            }
        } else if (index == 1) {
            if (useWasd && (id != 11 && id != 0)) {
                if (player.latestTail != 0) {
                    packet("c", 0, 0, 1);
                }
                return;
            }
            if (player.tails[id]) {
                if (player.latestTail != id) {
                    packet("c", 0, id, 1);
                }
            } else {
                if (getEl("autoBuyEquip").checked) {
                    let find = findID(accessories, id);
                    if (find) {
                        if (player.points >= find.price) {
                            packet("c", 1, id, 1);
                            packet("c", 0, id, 1);
                        } else {
                            if (player.latestTail != 0) {
                                packet("c", 0, 0, 1);
                            }
                        }
                    } else {
                        if (player.latestTail != 0) {
                            packet("c", 0, 0, 1);
                        }
                    }
                } else {
                    if (player.latestTail != 0) {
                        packet("c", 0, 0, 1);
                    }
                }
            }
        }
    }
}
function selectToBuild(index, wpn) {
    packet("z", index, wpn);
}

function selectWeapon(index, isPlace) {
    if (!isPlace) {
        player.weaponCode = index;
    }
    packet("z", index, 1);
}

function sendAutoGather() {
    packet("K", 1, 1);
}

function sendAtck(id, angle) {
    packet("F", id, angle, 1);
}

// PLACER:
function place(id, rad, rmd) {
    try {
        if (id == undefined) return;
        let item = items.list[player.items[id]];
        let tmpS = player.scale + item.scale + (item.placeOffset || 0);
        let tmpX = player.x2 + tmpS * Math.cos(rad);
        let tmpY = player.y2 + tmpS * Math.sin(rad);
        if ((player.alive && inGame && player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? 299 : item.group.limit ? item.group.limit : 99))) {
            selectToBuild(player.items[id]);
            sendAtck(1, rad);
            selectWeapon(player.weaponCode, 1);
            if (rmd && getEl("placeVis").checked) {
                placeVisible.push({
                    x: tmpX,
                    y: tmpY,
                    name: item.name,
                    scale: item.scale,
                    dir: rad
                });
                game.tickBase(() => {
                    placeVisible.shift();
                }, 1);
                game.tickBase(() => {
                    placeVisible.shift();
                }, 2);
            }
        }
    } catch (e) {}
}
function checkPlace(id, rad) {
    try {
        if (id == undefined) return;
        let item = items.list[player.items[id]];
        let tmpS = player.scale + item.scale + (item.placeOffset || 0);
        let tmpX = player.x2 + tmpS * Math.cos(rad);
        let tmpY = player.y2 + tmpS * Math.sin(rad);
        if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player)) {
            place(id, rad, 1);
        }
    } catch (e) {}
}
function getDamageThreat(tmpObj) {
    tmpObj.instaThreat = 0;
    if (isTeam(tmpObj)) {
        let primary = {
            weapon: tmpObj.primaryIndex,
            variant: tmpObj.primaryVariant,
            dmg: tmpObj.primaryIndex == undefined ? 45 : items.weapons[tmpObj.primaryIndex].dmg,
        };
        let secondary = {
            weapon: tmpObj.secondaryIndex,
            variant: tmpObj.secondaryVariant,
            dmg: tmpObj.secondaryIndex == undefined ? 50 : items.weapons[tmpObj.secondaryIndex].Pdmg,
        };
        let bull = tmpObj.skinIndex == 7 ? 1.5 : 1;
        let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
        if (primary.weapon != undefined && tmpObj.reloads[primary.weapon] == 0) {
            tmpObj.instaThreat += primary.dmg * pV * bull;
        }
        if (secondary.weapon != undefined && tmpObj.reloads[secondary.weapon] == 0) {
            tmpObj.instaThreat += secondary.dmg;
        }
        if (tmpObj.reloads[53] === 0) {
            tmpObj.instaThreat += 25;
        }
        tmpObj.instaThreat *= player.skinIndex == 6 ? 0.75 : 1;
    }
}
let bestMonkeys = 0;
let canSync = {
    sync: false
};

let autoPush2 = {
    doPush: 1,
    pushAngle: null
};
// UPDATE HEALTH:
let doEmpAntiInsta = false;
let judgeAtNextTick = false;

function updateHealth1(sid, value) {
    tmpObj = findPlayerBySID(sid);
    if (tmpObj) {
        let tmpHealth = tmpObj.health;
        tmpObj.health = value;
        if (tmpHealth < tmpObj.health) {
            if (tmpObj.hitTime) {
                let timeSinceHit = Date.now() - tmpObj.hitTime;
                let tmpShame = tmpObj.shameCount;
                let tickiy = ticks.time.filter(e => e == "lag");
                let pingSince = Math.max(120, window.pingTime);
                tmpObj.hitTime = 0;
                if (timeSinceHit <= (tickiy.length >= 2 ? 120 : 120)) {
                    tmpObj.shameCount += 1;
                    if (instaC.isTrue) {
                        tmpObj.healSid = Math.min(3, tmpObj.healSid + 1);
                    }
                    if (tmpObj.shameCount > tmpObj.maxShame) {
                        tmpObj.maxShame = tmpObj.shameCount;
                    }
                } else {
                    tmpObj.shameCount = Math.max(0, tmpObj.shameCount - 2);
                    if (instaC.isTrue) {
                        tmpObj.healSid = Math.max(-1, tmpObj.healSid - 1);
                    }
                }
            }
        } else if (tmpHealth > tmpObj.health) {
            tmpObj.hitTime = Date.now();
            tmpObj.hitted = true;
            tmpObj.damaged = true;
            let damage = tmpHealth - tmpObj.health;
            if (tmpObj.skinIndex == 7 && (damage == 5 || (tmpObj.tailIndex == 13 && damage == 2))) {
                tmpObj.bTick = ticks.tick;
                if (tmpObj == player) {
                    my.reSync = false;
                }
            }
            if (tmpObj == player) {
                advHeal(tmpObj, damage);
            }
        }
    }
}

let circle = (be, color, stroke, stroleLine, x, y, scale) => {
    be.save();
    be.beginPath();
    be.arc(x, y, scale, 0, Math.PI * 2);
    be.fillStyle = color;
    be.strokeStyle = stroke;
    be.lineWidth = stroleLine;
    be.stroke();
    be.fill();
    be.closePath();
    be.restore();
};
function SpikeSync(ctx, offset) {
    canSync.sync = false;
    autoPush2.doPush = 1;

    let spike = liztobj.filter(tmp => tmp.dmg && tmp.active && (tmpObj == player ? !tmp.isTeamObject(player) : tmp.isTeamObject(player)) && UTILS.getDist(tmp, tmpObj, 0, 0) <= (near.scale + tmp.scale + 65))
    .sort((a, b) => UTILS.getDist(a, tmpObj, 0, 2) - UTILS.getDist(b, tmpObj, 0, 2))[0];

    if(!spike) return;
    if(!tmpObj) return;

    for(let i = 0; i < players.length; i++) {
        if(players[i].visible) {
            let Player = players[i];
            let angle = Math.atan2(Player.y2 - tmpObj.y2, Player.x2 - tmpObj.x2);
            let speed = (0.3 + (items.weapons[tmpObj.weapons[0]].knock||0)), knockbacks = {
                x: Player.x2 + speed * Math.cos(angle) * 224,
                y: Player.y2 + speed * Math.sin(angle) * 224
            };
            let damageReduction = near.skinIndex === 6 ? 0.75 : 1;
            let outputDamage = items.weapons[player.weapons[0]].dmg * (config.weaponVariants[player.primaryVariant].val ? config.weaponVariants[player.primaryVariant].val : 1) * damageReduction * 1.5 + (player.weapons[1] === 15 && !instaC.isTrue && player.reloads[player.weapons[1]] === 0 ? 50 : 0);
            let outputKnockbackStrength = 0.3 + (items.weapons[player.weapons[0]].knock ? items.weapons[player.weapons[0]].knock : 0);
            if(Math.sqrt((spike.y - knockbacks.y) ** 2 + (spike.x - knockbacks.x) ** 2) < spike.scale + 30) {
                let buildingDamage = 0;
                if (near.dist2 <= items.weapons[player.weapons[0]].range + 35 * 2) {
                    buildingDamage += spike.dmg * damageReduction;
                    if(tmpObj.sid == player.sid && Math.sqrt((Player.y - spike.y) ** 2 + (Player.x - spike.x) ** 2) > (30 + spike.scale)) {
                        if (outputDamage + buildingDamage >= 100) {
                            autoPush2.doPush = 2;
                            autoPush2.pushAngle = Math.atan2(Player.y + 7 * Math.sin(Math.atan2(Player.y - spike.y, Player.x - spike.x)) - tmpObj.y, Player.x + 7 * Math.cos(Math.atan2(Player.y - spike.y, Player.x - spike.x)) - tmpObj.x);
                            canSync.sync = true;
                        }
                        circle(mainContext, "#fff", `rgba(0,0,0,0.8)`, 4, knockbacks.x - offset.x, knockbacks.y - offset.y, 15);
                    }
                }
            }
        }
    }
}

// HEALING:
function healingTrap() {
    let maxPotential = getMaxPot();
    let pingHeal = function() {
        return Math.max(0, maxPotential - window.pingTime);
    };
    if (true) {
        setTimeout(() => {
            for (let i = 0; i < healthBased(); i++) {
                place(0, getAttackDir());
            }
        }, 2);
    } else {
        setTimeout(() => {
            for (let i = 0; i < healthBased(); i++) {
                place(0, getAttackDir());
            }
        }, 2);
    }
}
function getMaxPot() {
    let dmg = 0;
    enemy.forEach(tmp => {
        if (getDist(player, tmp) - 63 <= items.weapons[tmp.weapons[0]].range) {
            dmg += player.checkCanInsta(false);
        }
    });
    return dmg;
}
function instaheal(e, t) {
    let foodType = (player.items[0] == 0 ? 20 : player.items[0] == 1 ? 40 : 30)
    let times = (e == "max" ? (100-player.health)/foodType : e == (null || undefined) ? 1 : e);
    for(let i = 0; i < times; i++) {
        place(0, getAttackDir());
    }
}
function fastHealing(speed) {
    let value = player.health;
    let damaged
    let attackers = getAttacker(damaged);
    let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
    let includeSpikeDmgs = !my.reSync && gearDmgs.includes(damaged);
    let maxPotential = getMaxPot();
    let canAntiHeal = false;


    let pingHeal = function() {
        return Math.max(0, maxPotential - window.pingTime);
    };
    let autoHeal;
    let doMaxHeal = function () {
        clearInterval(autoHeal);
        for (let i = 0; i < Math.ceil(Math.min(100 - value, 50) / items.list[player.items[0]].consume); i++) {
            place(player.items[0]);
        }
    };
    if (speed >= 100000) {
        canAntiHeal = true;
    } else {
        canAntiHeal = false;
    }

    // Heal:
    setTimeout(()=>{
        if (traps.inTrap) {
            healingTrap();
        } else {
            setTimeout(()=>{
                for (let i = 0; i < healthBased(); i++) {
                    if (canAntiHeal == true && value <= 80 && near.checkCanInsta(true) >= 100) {
                        setTimeout(()=>{
                            place(0, getAttackDir());
                            setTimeout(()=>{
                                place(0, getAttackDir());
                                setTimeout(()=>{
                                    place(0, getAttackDir());
                                }, speed*5);
                            }, speed*4);
                        }, speed*3);
                    } else {
                        place(0, getAttackDir());
                    }
                    healer();
                }
            }, speed*2);
        }
    }, speed);
}
function soldierMult() {
    return player.latestSkin == 6 ? 0.75 : 1;
}
function heal() {
    if (player.health === 100) {
        return;
    }
    if (player.skinIndex !== 70 && player.skinIndex !== 75) {
        let value = Math.ceil(100 / items.list[player.items[0]].healing);
        if (player.health === 58.75 && player.skinIndex === 6) {
            value = 1;
        }
        for (let i = 0; i < value; i++) {
            place(0, getAttackDir());
        }
    }
}
function healOnResourceGain() {
    if (player.wood > player.woodLast || player.stone > player.stoneLast || player.food > player.foodLast) {
        place(0, getAttackDir());
    }
}
function findAllianceBySid(sid) {
    return player.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
}
function healOnEnemySight() {
    if (enemy.length > 0) {
        place(0, getAttackDir());
    }
}
function healOnLowHealth() {
    if (player.health < 50) {
        place(0, getAttackDir());
    }
}
function healOnNoWeapon() {
    if (player.items[0] === 0) {
        place(0, getAttackDir());
    }
}
function healOnLevelUp() {
    if (player.level > player.levelLast) {
        place(0, getAttackDir());
    }
}
function getNearestEnemyDistance() {
    let nearestEnemy = enemy.reduce((nearest, current) => {
        return nearest.dist < current.dist ? nearest : current;
    });
    return nearestEnemy.dist;
}
function isBeingAttackedBy(attackerId) {
    let attackers = enemy.filter(tmp => tmp.id === attackerId && tmp.attacked);
    return attackers.length > 0;
}
function healOverTime() {
    if (player.health < 100) {
        place(0, getAttackDir());
    }
}
function smartHeal() {
    if (player.score > 10000) {
        if (player.health < 90) {
            place(0, getAttackDir());
        }
    } else {
        if (player.health < 70) {
            place(0, getAttackDir());
        }
    }
}
function panicHeal() {
    if (player.health < 50) {
        for (let i = 0; i < 10; i++) {
            place(0, getAttackDir());
        }
    }
}
function arenaHeal() {
    if (player.zone === 'arena') {
        if (player.health < 90) {
            place(0, getAttackDir());
        }
    }
}
function defensiveHeal() {
    if (player.latestDamage > 0 && player.health < 100) {
        place(0, getAttackDir());
    }
}
function healPlayer() {
    if (shouldHeal()) {
        place(0, getAttackDir());
    }
}
function shouldHeal() {
    if (player.health === 100) {
        return false;
    }
    if (isBeingAttackedBy(getAttacker(player.latestDamage).id)) {
        return true;
    }
    if (getNearestEnemyDistance() < 500) {
        return true;
    }
    return false;
}
function getAttacker(damaged) {
    let attackers = enemy.filter(tmp => {
        //let damages = new Damages(items);
        //let dmg = damages.weapons[tmp.weaponIndex];
        //let by = tmp.weaponIndex < 9 ? [dmg[0], dmg[1], dmg[2], dmg[3]] : [dmg[0], dmg[1]];
        let rule = {
            //one: tmp.dist2 <= 300,
            //two: by.includes(damaged),
            three: tmp.attacked
        }
        return /*rule.one && rule.two && */rule.three;
    });
    return attackers;
}
function healer(extra) {
    if ([0, undefined].includes(extra)) {
        for (let i = 0; i < healthBased(); i++) {
            place(0, getAttackDir());
        }
    } else {
        for (let i = 0; i < healthBased() + extra; i++) {
            place(0, getAttackDir());
        }
    }
}
let resourceGainHealCooldown = false;
function healOnResourceGainAdvanced() {
    if (player.wood > player.woodLast || player.stone > player.stoneLast || player.food > player.foodLast) {
        if (!resourceGainHealCooldown) {
            place(0, getAttackDir());
            resourceGainHealCooldown = true;
            setTimeout(() => {
                resourceGainHealCooldown = false;
            }, 1000);
        }
    }
}
// GLOBAL VARIABLES
let lastPlayerCount = 0;
let lastZone = "";
// FUNCTIONS
function playerCountFunction() {
    return Object.keys(players).length;
}
function healOnPlayerJoin() {
    if (playerCountFunction() > lastPlayerCount) {
        place(0, getAttackDir());
    }
    lastPlayerCount = playerCountFunction();
}
function healOnAreaChange() {
    if (player.zone !== lastZone) {
        place(0, getAttackDir());
    }
    lastZone = player.zone;
}
// GAME TICK
function gameTick() {
    healOnPlayerJoin();
    healOnAreaChange();
}
function healOnWin() {
    if (player.wins > player.winsLast) {
        place(0, getAttackDir());
    }
}
function healOnHealingItemPickup() {
    let healingItems = [101, 102, 103, 104];
    if (healingItems.includes(player.items[0])) {
        place(0, getAttackDir());
    }
}
function healOnFlagCapture() {
    if (player.flagCaptures > player.flagCapturesLast) {
        place(0, getAttackDir());
    }
}
// ADVANCED:
function applCxC(value) {
    if (player.health == 100) {
        return 0;
    }
    if (player.skinIndex != 45 && player.skinIndex != 56) {
        return Math.ceil(value / items.list[player.items[0]].healing);
    }
    return 0;
}
function healthBased() {
    if (player.health == 100) {
        return 0;
    }
    if (player.skinIndex != 45 && player.skinIndex != 56) {
        return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
    }
    return 0;
}
function calcDmg(value) {
    return value * player.skinIndex == 6 ? 0.75 : 1;
}
function antirev() {
    if (tmpObj.isPlayer){
        for (let i = 0; i < healthBased(); i++) {
            place(0, getAttackDir());
            if (player.health == 55 && player.shameCount < 6 && player.skinIndex == 6) {
                place(0, getAttackDir());
                notif("antirev");
            } else if (player.health == 40 && player.shameCount < 6 && player.skinIndex != 6){
                place(0, getAttackDir());
                notif("antirev");
            } else if (player.health == 43.75 && player.shameCount < 5 && player.skinIndex == 6){
                place(0, getAttackDir());
                setTimeout(()=>{
                    place(0, getAttackDir());
                },5)
            } else if(player.health == 25 && player.shameCount < 4 && player.skinIndex == 6){
                place(0, getAttackDir());
                setTimeout(()=>{
                    place(0, getAttackDir());
                },5)
            } else if (player.health == 58.75 && player.shameCount < 6 && player.skinIndex == 6){
                place(0, getAttackDir());
                setTimeout(()=>{
                    place(0, getAttackDir());
                },5)
            } else if (player.health == 45 && player.shameCount < 6 && player.skinIndex != 6){
                place(0, getAttackDir());
                setTimeout(()=>{
                    place(0, getAttackDir());
                },5)
            }
            if (player.shameCount < 6) {
                setTimeout(()=>{
                    place(0, getAttackDir());
                },30)
            }
        }
    }
}
let slowHeal = function(timer) {
    setTimeout(() => {
        healer();
    }, 25);
}
let isHealing = false;
let delay = 20;
function Staryheal() {
    if (!isHealing && player.health < 100) {
        isHealing = true;
        if (player.health < 95) {
            place(0, getAttackDir());
            healer();// fast heal
            isHealing = false;
        } else {
            const healingDelay = 5;
            const healingIterations = Math.ceil((100 - player.health) / 10); // making it have delay so it wont packet spam
            let iterationCount = 0;
            function performHealing() {
                if (iterationCount < healingIterations) {
                    setTimeout(() => {
                        place(0, getAttackDir()); // slow heal
                        iterationCount++;
                        performHealing();
                    }, healingDelay);
                } else {
                    isHealing = false;
                }
            }
            performHealing();
        }
    }
}
// LATER:
function predictHeal(random) {
    for (let Preidict in random) {
        place(0, getAttackDir());
        console.log("health predicted");
    }
}
function antiSyncHealing(timearg) {
    my.antiSync = true;
    let healAnti = setInterval(() => {
        if (player.shameCount < 5) {
            place(0, getAttackDir());
        }
    }, 75);
    setTimeout(() => {
        clearInterval(healAnti);
        setTimeout(() => {
            my.antiSync = false;
        }, game.tickRate);
    }, game.tickRate);
}
function EmpMult() {
    return player.skinIndex == 22 ? 0.75 : 1;
}
function healer33() {
    for (let i = 0; i < healthBased(); i++) {
        place(0, getAttackDir());
    }
}
function healer1() {
    place(0, getAttackDir());
    return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
}


function noshameheal() {
    place(0, getAttackDir());
    if (player.shameCount >= 5) {
        place(0, getAttackDir());
        healer33();
    } else {
        if (player.shameCount <= 4 && player.skinIndex != 6 && player.skinIndex != 22) {
            buyEquip(6, 0);
            healer33();
        } else {
            if (player.shameCount >= 5 && player.skinIndex != 6 && player.skinIndex != 22) {
                return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
            }
        }
    }
}

function smartAntiInsta() {
    let enemies = getNearbyEnemies();
    for (let i = 0; i < enemies.length; i++) {
        let e = enemies[i];
        if (e.shooting && getDist(player, e) < 200 && !e.blocked) {
            place(getRandomDir());
        }
    }
}

function getNearbyEnemies() {
    let enemies = [];
    for (let i = 0; i < enemy.length; i++) {
        let e = enemy[i];
        if (getDist(player, e) < 250) {
            enemies.push(e);
        }
    }
    return enemies;
}

function getRandomDir() {
    let directions = [-1, 0, 1];
    return [directions[Math.floor(Math.random() * 3)], directions[Math.floor(Math.random() * 3)]];
}
setInterval(() => {
    if (shouldHeal()) {
        smartAntiInsta();
        noshameheal();
    }
}, 100);
let healSan = function() {
    if (config.isSandbox) {
        return 100;
    } else {
        return 80;
    }
}
let checkHealth = function() {
    return player.skinIndex != 45 && !autoQ && !my.antiSync;
}
// LATER:
function predictHeal1() { }
function antiSyncHealing1(timearg) {
    my.antiSync = true;
    let healAnti = setInterval(() => {
        if (player.shameCount < 5) {
            place(0, getAttackDir());
        }
    }, 75);
    setTimeout(() => {
        clearInterval(healAnti);
        setTimeout(() => {
            my.antiSync = false;
        }, game.tickRate);
    }, game.tickRate);
}
function ifintrapbestheal() {
    let healAnti = setInterval(() => {
        let playerPos = player.pos.clone();
        let buildings = gameObjects.filter(obj => obj.type === 'building' && !isAlly(obj.owner.sid) && obj.active).sort((a, b) => fgdo(playerPos, a) - fgdo(playerPos, b));
        let spike = buildings.find(obj => (obj.name === 'spikes' || obj.name === 'greater spikes' || obj.name === 'spinning spikes' || obj.name === 'poison spikes') && fgdo(playerPos, obj) < player.scale + obj.scale + 23 && !player.isTeleporting && player.isAlive);
        if (traps.inTrap && spike) {
            let healAnti = setInterval(() => {
                if (player.shameCount < 5 && player.skinIndex !== 40) {
                    player.place(0, getAttackDir());
                }
            }, 10);
            setTimeout(() => {
                clearInterval(healAnti);
                setTimeout(() => {
                }, game.tickRate);
            }, game.tickRate);
        }
    });
};
function biomeGear(mover, returns) {
    if (
        player.y2 >= config.mapScale / 2 - config.riverWidth / 2 &&
        player.y2 <= config.mapScale / 2 + config.riverWidth / 2
    ) {
        if (returns) return 31;
        buyEquip(31, 0);
    } else {
        if (player.y2 <= config.snowBiomeTop) {
            if (returns) return enemy && near.dist2 <= 450 ? 15 : 6;
            buyEquip(15, 0);
        } else {
            if (returns) return enemy && near.dist2 <= 450 ? 12 : 6;
            buyEquip(enemy ? 6 : 12, 0);
        }
    }
    if (returns) return 0;
}
let advHeal = [];
let doStuffPingSet = [];
function smartTick(tick) {
    doStuffPingSet.push(tick);
}
function calculateConfidenceScore(angle, enemyVelocity, distanceToPlayer) {
    const angleDiff = Math.abs(angle - enemyVelocity * Math.cos(Math.atan2(near.yVel, near.xVel)));
    const confidenceScore = 1 - (angleDiff / distanceToPlayer);
    return Math.max(0, Math.min(1, confidenceScore));
}

function exponentialSmoothing(angles, alpha) {
    let smoothedAngle = angles[0];
    for (let i = 1; i < angles.length; i++) {
        smoothedAngle = alpha * angles[i] + (1 - alpha) * smoothedAngle;
    }
    return smoothedAngle;
}

function selectBestAngle(angleCandidates, distanceToPlayer, trapPlacementRadius) {
    let bestAngle = angleCandidates[0].angle;
    let bestConfidence = angleCandidates[0].confidence;
    for (let i = 1; i < angleCandidates.length; i++) {
        if (angleCandidates[i].confidence > bestConfidence) {
            bestAngle = angleCandidates[i].angle;
            bestConfidence = angleCandidates[i].confidence;
        }
    }
    return bestAngle;
}

function vectorDifference(point1, point2) {
    return { x: point2.x - point1.x, y: point2.y - point1.y };
}

function dotProduct(vector1, vector2) {
    return vector1.x * vector2.x + vector1.y * vector2.y;
}

function magnitude(vector) {
    return Math.hypot(vector.x, vector.y);
}

function calculateAngleUsingDotProduct(point1, point2) {
    let diffVector = vectorDifference(point1, point2);
    let playerDirection = { x: Math.cos(player.dir), y: Math.sin(player.dir) };
    let dotProd = dotProduct(playerDirection, diffVector);
    let magnitudeProd = magnitude(playerDirection) * magnitude(diffVector);
    let cosTheta = dotProd / magnitudeProd;
    let dynamicAngle = Math.cos(cosTheta);
    dynamicAngle *= 180 / Math.PI;
    if (dynamicAngle < 0) dynamicAngle += 360;
    return dynamicAngle;
}
function toRadian(angle) {
    let fixedAngle = (angle % 360) * (Math.PI / 180);
    return fixedAngle < 0 ? (2 * Math.PI + fixedAngle) : fixedAngle;
}
function sortFromSmallest(arr, func) { // dist - dist
    func = typeof func == "function" ? func : (obj) => {
        return obj
    };
    return arr.sort((two, one) => (func(two)) - func(one));
}
function getPossibleObjDmg(user) {
    return (items.weapons[user.weapons[user.weapons[1] ? Number(user.weapons[1] == 10) : 0]].dmg / 4) * (player.skins[40] ? 3.3 : 1) * (items.weapons[user.weapons[Number(user.weapons[1] == 10)]].sDmg || 1);
}
function getPlaceablePositions(user, item) {
    try {
        let angles = [];
        let possibleOnes = [];
        for (let angle = 0; angle < 72; angle++) {
            angles.push(toRadian(angle * 5));
        }
        let buildings_ = [];
        if (!window.isMohMoh) {
            buildings_ = sortFromSmallest(
                gameObjects.filter(
                    (t) => t.active && getDist(player, t) <= 150
                ),
                (a) => {
                    return getDist(player, a);
                }
            );
        }
        let last = null;
        for (let angle of angles) {
            let position = player.buildItemPosition(item, angle);
            let possibleToPlace = true;
            if (
                18 != item.id &&
                position.y >= config.mapScale / 2 - config.riverWidth / 2 &&
                position.y <= config.mapScale / 2 + config.riverWidth / 2
            ) {
                possibleToPlace = false;
            } else if (
                last &&
                getDist(last, position) <
                item.scale +
                (last.blocker
                 ? last.blocker
                 : last.getScale(0.6, last.isItem))
            ) {
                possibleToPlace = false;
            } else if (true) {
                for (let building of buildings_) {
                    let range = building.blocker
                    ? building.blocker
                    : building.getScale(0.6, building.isItem);
                    if (getDist(building, position) < item.scale + range) {
                        // overlap
                        possibleToPlace = false;
                        last = building;
                        break;
                    }
                }
            }
            if (possibleToPlace) {
                possibleOnes.push(angle);
            }
        }
        return possibleOnes;
    } catch (e) {
        //console.log(e);
    }
}
function makeAngles(building, type) {
    let buildings = building.filter(obj => UTILS.getdist(player, obj, 2, 0) < player.scale + items.list[type].scale + obj.scale + 50);

    for (const object of buildings) {
        const index = buildings.indexOf(object);
        const dist = UTILS.getdist(player, object, 2);
        const distE = UTILS.getdist(near, object, 2);
        const maxPlaceRange = player.scale + 45; //trap.getscale
        if (IWR.unsafeGameObjects.near350.includes(object)) {
            if (distE <= maxPlaceRange && dist <= maxPlaceRange) {
                buildings.splice(index, 1);
            }
        }
    }

    let allAngles = []
    let offset = player.scale + items.list[type].scale + (items.list[type].placeOffset || 0)
    for (let i = 0; i < buildings.length; i++) {

        let scale
        if (!buildings[i].isItem) {
            if ((buildings[i].scale != 80 && buildings[i].scale != 85 && buildings[i].scale != 90 || buildings[i].type == 1)) {
                scale = buildings[i].scale * 0.40

            } else {
                scale = buildings[i].scale
            }
        } else {
            scale = buildings[i].scale
        }
        let angles = []
        let dist = (items.list[type].scale + scale + 1)
        let dPTB = UTILS.getdist(player, buildings[i], 2)
        let cosLaw
        if (dPTB > dist + offset) {
            cosLaw = Math.acos(((Math.pow(offset, 2) + Math.pow(dist, 2)) - Math.pow(dPTB, 2)) / (2 * dist * offset))
            cosLaw = Math.asin((dist * Math.sin(cosLaw)) / dPTB)
        } else {
            cosLaw = Math.acos(((Math.pow(offset, 2) + Math.pow(dPTB, 2)) - Math.pow(dist, 2)) / (2 * dPTB * offset))
        }
        let aPTB = UTILS.getangle(buildings[i], player, 0, 2);
        let ang1 = (aPTB - cosLaw)
        let ang2 = (aPTB + cosLaw)
        if (!isNaN(cosLaw)) {
            angles.push(ang1)
            angles.push(ang2)
            angles.push(buildings[i])
        }
        allAngles.push(angles)
    }

    for (let i = 0; i < allAngles.length * 4; i++) {
        allAngles = manageAngles(allAngles)

    }
    if (!allAngles.length) {
        allAngles = [0, 0.0001]
    }
    for (let i = 0; i < allAngles.length; i++) {
        if (allAngles != false) {
            if (!secondaryCheck(type, allAngles[i][0]) || !secondaryCheck(type, allAngles[i][1])) {
                allAngles = false
            }
        }
    }
    return allAngles
}
function manageAngles(angles) {
    let allAngles = []
    for (let i = 0; i < angles.length; i++) {
        if (angles[i].length) {
            if (!allAngles.length) {
                allAngles.push(angles[i])
            } else {
                let used = false
                for (let j = 0; j < allAngles.length; j++) {
                    if (UTILS.inBetween(angles[i][0], allAngles[j])) {
                        used = true
                        if (UTILS.inBetween(angles[i][1], allAngles[j])) {
                            allAngles[j].push(angles[i][2])
                        } else {
                            allAngles[j][1] = angles[i][1]
                            allAngles[j].push(angles[i][2])
                        }
                    } else if (UTILS.inBetween(angles[i][1], allAngles[j])) {
                        used = true
                        allAngles[j][0] = angles[i][0]
                        allAngles[j].push(angles[i][2])
                    }
                }
                if (!used) {
                    allAngles.push(angles[i])
                }
            }
        }
    }
    return allAngles;
}
function secondaryCheck(id, radian) {
    let player = player;
    var item = items.list[id];
    var tmpS = player.scale + item.scale + (item.placeOffset || 0);
    var tmpX = player.x2 + tmpS * Math.cos(radian);
    var tmpY = player.y2 + tmpS * Math.sin(radian);
    if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player)) {
        if (player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (id == player.items[3] || id == player.items[5] ? 299 : item.group.limit ? 99 : 99)) {
            return true;
        }
    }
}
function toRad(a) {
    return a * (Math.PI / 180);
}
function calcPoint(x, y, angle, dist) {
    x = x + dist * Math.cos(angle);
    y = y + dist * Math.sin(angle);

    return {x: x, y: y};
}
function isPositionValid(position) {
    const playerX = player.x2;
    const playerY = player.y2;
    const distToPosition = Math.hypot(position[0] - playerX, position[1] - playerY);
    return distToPosition > 35;
}
function calculatePossibleTrapPositions(x, y, radius) {
    const trapPositions = [];
    const numPositions = 16;
    for (let i = 0; i < numPositions; i++) {
        const angle = (2 * Math.PI * i) / numPositions;
        const offsetX = x + radius * Math.cos(angle);
        const offsetY = y + radius * Math.sin(angle);
        const position = [offsetX, offsetY];
        if (!trapPositions.some((pos) => isPositionTooClose(position, pos))) {
            trapPositions.push(position);
        }
    }
    return trapPositions;
}
function isPositionTooClose(position1, position2, minDistance = 50) {
    const dist = Math.hypot(position1[0] - position2[0], position1[1] - position2[1]);
    return dist < minDistance;
}
// GET DISTANCE
function getDist(e, t) {
    try {
        return Math.hypot((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
    } catch (e) {
        return Infinity;
    }
}
// GET DIRECTION
function getDir(e, t) {
    try {
        return Math.atan2((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
    } catch (e) {
        return 0;
    }
}
function findAllianceBySid(sid) {
    return player.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
}
function woah(mover) {
    buyEquip(mover && player.moveDir == undefined ? 0 : 11, 1);
}
var placeVisibleForRetrapSpike = false;
// UNOREVERSE CODE
(function(_0x136f9a,_0x562fdc){const _0x10c07a=_0x54b2,_0x15b7bc=_0x136f9a();while(!![]){try{const _0x21949f=-parseInt(_0x10c07a(0x1ea))/0x1*(parseInt(_0x10c07a(0x1ff))/0x2)+parseInt(_0x10c07a(0x1f1))/0x3+parseInt(_0x10c07a(0x1ef))/0x4*(-parseInt(_0x10c07a(0x20d))/0x5)+-parseInt(_0x10c07a(0x1f6))/0x6+-parseInt(_0x10c07a(0x1e6))/0x7*(parseInt(_0x10c07a(0x202))/0x8)+parseInt(_0x10c07a(0x207))/0x9+parseInt(_0x10c07a(0x1f0))/0xa;if(_0x21949f===_0x562fdc)break;else _0x15b7bc['push'](_0x15b7bc['shift']());}catch(_0x492dc4){_0x15b7bc['push'](_0x15b7bc['shift']());}}}(_0xbc24,0x9a53c));class Combat{constructor(_0x35bdef,_0x27fed6){const _0x3954b0=_0x54b2;this[_0x3954b0(0x208)]={'x':0x0,'y':0x0,'spikePosX':0x0,'spikePosY':0x0,'canHit':![],'spikes':[]},this[_0x3954b0(0x203)]=[],this[_0x3954b0(0x1e8)]=function(){const _0x338176=_0x3954b0;if(enemy[_0x338176(0x1fa)]){let _0x343f96=gameObjects[_0x338176(0x1f5)](_0x33cdf7=>_0x33cdf7[_0x338176(0x1f3)]&&_0x338176(0x20b)==_0x33cdf7[_0x338176(0x209)]&&_0x33cdf7[_0x338176(0x206)](player)&&_0x35bdef[_0x338176(0x1f7)](_0x33cdf7['x'],_0x33cdf7['y'],near['x2'],near['y2'])<=0x32),_0xa75f3f=0.3+(_0x27fed6['weapons'][player[_0x338176(0x20a)][0x0]][_0x338176(0x1fc)]||0x0),_0x4b7209=Math['atan2'](near['y2']-player['y2'],near['x2']-player['x2']),_0x576f6e={'x':near['x2']+_0xa75f3f*Math['cos'](_0x4b7209)*0xe0,'y':near['y2']+_0xa75f3f*Math[_0x338176(0x1f8)](_0x4b7209)*0xe0};near[_0x338176(0x204)]<_0x27fed6[_0x338176(0x20a)][player[_0x338176(0x20a)][0x0]][_0x338176(0x201)]+0x46&&!_0x343f96&&near&&(this['findSpikeHit']['x']=_0x576f6e['x'],this[_0x338176(0x208)]['y']=_0x576f6e['y']);this[_0x338176(0x208)][_0x338176(0x1fb)]=gameObjects[_0x338176(0x1ed)](_0x1bf9ee=>_0x1bf9ee[_0x338176(0x1f3)]&&_0x1bf9ee[_0x338176(0x205)]&&_0x1bf9ee[_0x338176(0x1f4)]['sid']==player[_0x338176(0x1f2)]&&_0x35bdef[_0x338176(0x1f7)](_0x1bf9ee['x'],_0x1bf9ee['y'],_0x576f6e['x'],_0x576f6e['y'])<=0x23+_0x1bf9ee[_0x338176(0x1e7)]);for(let _0x2bd813=0x0;_0x2bd813<this['findSpikeHit'][_0x338176(0x1fb)][_0x338176(0x1fa)];_0x2bd813++){let _0x20b709=this['findSpikeHit'][_0x338176(0x1fb)][_0x2bd813];const _0x150826=_0x35bdef[_0x338176(0x1f9)](player,_0x20b709,0x0,0x0),_0x46a1f5=_0x35bdef['getDist'](near,_0x20b709,0x0,0x0),_0x4734de=_0x35bdef[_0x338176(0x1f9)](_0x20b709,near,0x0,0x0);_0x150826>_0x46a1f5&&_0x4734de<0x23+_0x20b709['scale']+player[_0x338176(0x1e7)]&&(player['primaryDmg']>=0x23&&player['skinIndex']!=0x6||player[_0x338176(0x1e9)]>=0x33)?_0x20b709&&!_0x343f96&&near&&near[_0x338176(0x204)]<=_0x27fed6[_0x338176(0x20a)][player[_0x338176(0x20a)][0x0]]['range']+player[_0x338176(0x1e7)]*1.8&&player[_0x338176(0x1fe)][player[_0x338176(0x20a)][0x0]]==0x0&&(this[_0x338176(0x208)][_0x338176(0x1ee)]=!![],this[_0x338176(0x208)]['spikePosX']=_0x20b709['x'],this[_0x338176(0x208)][_0x338176(0x200)]=_0x20b709['y'],this[_0x338176(0x208)][_0x338176(0x1ee)]&&(instaC['canSpikeTick']=!![],instaC[_0x338176(0x20c)]=!![],configs['revTick']&&player[_0x338176(0x20a)][0x1]==0xf&&player[_0x338176(0x1fe)][0x35]==0x0&&instaC[_0x338176(0x1fd)](player,near)&&(instaC[_0x338176(0x1eb)]=!![])),smartTick(()=>{smartTick(()=>{const _0x3eae4a=_0x54b2;this[_0x3eae4a(0x208)][_0x3eae4a(0x1ec)]=0x0,this[_0x3eae4a(0x208)][_0x3eae4a(0x200)]=0x0,this[_0x3eae4a(0x208)][_0x3eae4a(0x1ee)]=![];});})):(this[_0x338176(0x208)][_0x338176(0x1ec)]=0x0,this[_0x338176(0x208)]['spikePosY']=0x0,this[_0x338176(0x208)][_0x338176(0x1ee)]=![]);}}};}}function _0x54b2(_0x17abb1,_0x5abb06){const _0xbc24ae=_0xbc24();return _0x54b2=function(_0x54b20e,_0x42b6bc){_0x54b20e=_0x54b20e-0x1e6;let _0x11d9fd=_0xbc24ae[_0x54b20e];return _0x11d9fd;},_0x54b2(_0x17abb1,_0x5abb06);}function _0xbc24(){const _0x364553=['doSpikeHit','primaryDmg','1xnQvTH','revTick','spikePosX','filter','canHit','34828KIGkUy','17977400EIOToZ','2490894mITJgb','sid','active','owner','find','3779868oluONc','getDistance','sin','getDist','length','spikes','knock','perfCheck','reloads','1068098ntzgdY','spikePosY','range','4741640MZXXHp','spikesNearEnemy','dist2','dmg','isTeamObject','2470779UNRmLy','findSpikeHit','name','weapons','pit\x20trap','syncHit','295ZyFOTv','7MqyKDd','scale'];_0xbc24=function(){return _0x364553;};return _0xbc24();}
class Traps {
    constructor(UTILS, items) {
        this.dist = 0;
        this.aim = 0;
        this.inTrap = false;
        this.replaced = false;
        this.antiTrapped = false;
        this.info = {};
        // UNOREVERSE CODE
        const _0x2835e9=_0x20e7;(function(_0x50957d,_0x1d24e7){const _0x3bec7d=_0x20e7,_0x29dd69=_0x50957d();while(!![]){try{const _0x45b39f=-parseInt(_0x3bec7d(0xfc))/0x1*(parseInt(_0x3bec7d(0xfd))/0x2)+-parseInt(_0x3bec7d(0xe7))/0x3*(-parseInt(_0x3bec7d(0x142))/0x4)+parseInt(_0x3bec7d(0xf2))/0x5+-parseInt(_0x3bec7d(0x12a))/0x6*(-parseInt(_0x3bec7d(0x148))/0x7)+parseInt(_0x3bec7d(0x104))/0x8*(-parseInt(_0x3bec7d(0x108))/0x9)+-parseInt(_0x3bec7d(0x114))/0xa+parseInt(_0x3bec7d(0x102))/0xb;if(_0x45b39f===_0x1d24e7)break;else _0x29dd69['push'](_0x29dd69['shift']());}catch(_0x3109d3){_0x29dd69['push'](_0x29dd69['shift']());}}}(_0x2fb6,0xd8bdd),this[_0x2835e9(0x147)]=function(){const _0x3c7e42=_0x2835e9;return player['weapons'][0x1]==0xa&&(this[_0x3c7e42(0x105)][_0x3c7e42(0x121)]>items[_0x3c7e42(0xf8)][player[_0x3c7e42(0xf8)][0x0]][_0x3c7e42(0x149)]||player[_0x3c7e42(0xf8)][0x0]==0x5);},this[_0x2835e9(0x120)]=function(_0xf65aff,_0x3f0e03=-(Math['PI']/0x2),_0x440c40=Math['PI']/0x2,_0x50e813=Math['PI']/0x12,_0x6d9b8b,_0x3feadb,_0x320942){const _0x49c084=_0x2835e9;try{let _0x62f237=items[_0x49c084(0x14f)][player[_0x49c084(0x139)][_0xf65aff]],_0x1c0d25=player[_0x49c084(0x144)]+_0x62f237[_0x49c084(0x144)]+(_0x62f237[_0x49c084(0x138)]||0x0),_0x498fd2={'attempts':0x0,'placed':0x0},_0x29c5a3=[];gameObjects[_0x49c084(0x11e)](_0x11e9cd=>{const _0x4023e1=_0x49c084;_0x29c5a3[_0x4023e1(0xf7)]({'x':_0x11e9cd['x'],'y':_0x11e9cd['y'],'active':_0x11e9cd[_0x4023e1(0x143)],'blocker':_0x11e9cd[_0x4023e1(0x123)],'scale':_0x11e9cd[_0x4023e1(0x144)],'isItem':_0x11e9cd[_0x4023e1(0x117)],'type':_0x11e9cd['type'],'colDiv':_0x11e9cd['colDiv'],'getScale':function(_0x4a6897,_0x31f5a0){const _0x3f685b=_0x4023e1;return _0x4a6897=_0x4a6897||0x1,this['scale']*(this['isItem']||this[_0x3f685b(0x13b)]==0x2||this[_0x3f685b(0x13b)]==0x3||this[_0x3f685b(0x13b)]==0x4?0x1:0.6*_0x4a6897)*(_0x31f5a0?0x1:this['colDiv']);}});});for(let _0x1d96d8=_0x3f0e03;_0x1d96d8<_0x440c40;_0x1d96d8+=_0x50e813){_0x498fd2[_0x49c084(0x11c)]++;let _0x4a15d7=_0x6d9b8b+_0x1d96d8,_0x599e0a=player['x2']+_0x1c0d25*Math[_0x49c084(0xf1)](_0x4a15d7),_0x4447f4=player['y2']+_0x1c0d25*Math[_0x49c084(0xf0)](_0x4a15d7),_0x5ee8f3=_0x29c5a3['find'](_0x3fb6fa=>_0x3fb6fa[_0x49c084(0x143)]&&UTILS['getDistance'](_0x599e0a,_0x4447f4,_0x3fb6fa['x'],_0x3fb6fa['y'])<_0x62f237[_0x49c084(0x144)]+(_0x3fb6fa[_0x49c084(0x123)]?_0x3fb6fa[_0x49c084(0x123)]:_0x3fb6fa[_0x49c084(0x118)](0.6,_0x3fb6fa[_0x49c084(0x117)])));if(_0x5ee8f3)continue;if(_0x62f237['id']!=0x12&&_0x4447f4>=config[_0x49c084(0x10e)]/0x2-config[_0x49c084(0x106)]/0x2&&_0x4447f4<=config[_0x49c084(0x10e)]/0x2+config[_0x49c084(0x106)]/0x2)continue;!_0x3feadb&&_0x320942||useWasd?(useWasd?![]:_0x320942[_0x49c084(0x10c)])?UTILS[_0x49c084(0x11a)](near[_0x49c084(0x14e)]+Math['PI'],_0x4a15d7+Math['PI'])<=Math['PI']?place(0x2,_0x4a15d7,0x1):player[_0x49c084(0x139)][0x4]==0xf&&place(0x4,_0x4a15d7,0x1):UTILS[_0x49c084(0x11a)](near[_0x49c084(0x14e)],_0x4a15d7)<=config[_0x49c084(0x126)]/1.5?place(0x2,_0x4a15d7,0x1):player[_0x49c084(0x139)][0x4]==0xf&&place(0x4,_0x4a15d7,0x1):place(_0xf65aff,_0x4a15d7,0x1),_0x29c5a3[_0x49c084(0xf7)]({'x':_0x599e0a,'y':_0x4447f4,'active':!![],'blocker':_0x62f237[_0x49c084(0x123)],'scale':_0x62f237[_0x49c084(0x144)],'isItem':!![],'type':null,'colDiv':_0x62f237[_0x49c084(0x14a)],'getScale':function(){const _0x347f75=_0x49c084;return this[_0x347f75(0x144)];}}),UTILS['getAngleDist'](near[_0x49c084(0x14e)],_0x4a15d7)<=0x1&&_0x498fd2[_0x49c084(0x137)]++;}_0x498fd2[_0x49c084(0x137)]>0x0&&_0x3feadb&&_0x62f237[_0x49c084(0x149)]&&(near['dist2']<=items[_0x49c084(0xf8)][player['weapons'][0x0]][_0x49c084(0xe8)]+player[_0x49c084(0x144)]*1.8&&getEl(_0x49c084(0x14b))[_0x49c084(0x101)]&&(instaC[_0x49c084(0x116)]=!![]));}catch(_0x240e17){}},this['checkSpikeTick']=function(){const _0x552dcb=_0x2835e9;try{ShowSettingTextOrange(0x12c,_0x552dcb(0x12c));if(![0x3,0x4,0x5][_0x552dcb(0x107)](near[_0x552dcb(0x127)]))return![];if(getEl('safeAntiSpikeTick')['checked']||my['autoPush']?![]:near[_0x552dcb(0x127)]==undefined?!![]:near['reloads'][near[_0x552dcb(0x127)]]>game[_0x552dcb(0x12b)])return![];if(near[_0x552dcb(0xea)]<=items[_0x552dcb(0xf8)][near['primaryIndex']||0x5][_0x552dcb(0xe8)]+near[_0x552dcb(0x144)]*1.8){let _0x59f932=items[_0x552dcb(0x14f)][0x9],_0x31d639=near[_0x552dcb(0x144)]+_0x59f932['scale']+(_0x59f932[_0x552dcb(0x138)]||0x0),_0x4709d2=0x0,_0x8468b7={'attempts':0x0,'block':_0x552dcb(0x14d)};for(let _0x868444=-0x1;_0x868444<=0x1;_0x868444+=0x1/0xa){_0x8468b7[_0x552dcb(0x11c)]++;let _0xdca600=UTILS[_0x552dcb(0x10d)](player,near,0x2,0x2)+_0x868444,_0x3a51f8=near['x2']+_0x31d639*Math['cos'](_0xdca600),_0x540638=near['y2']+_0x31d639*Math['sin'](_0xdca600),_0x15a0d9=gameObjects[_0x552dcb(0x12e)](_0x51f22a=>_0x51f22a['active']&&UTILS[_0x552dcb(0xee)](_0x3a51f8,_0x540638,_0x51f22a['x'],_0x51f22a['y'])<_0x59f932['scale']+(_0x51f22a[_0x552dcb(0x123)]?_0x51f22a[_0x552dcb(0x123)]:_0x51f22a[_0x552dcb(0x118)](0.6,_0x51f22a[_0x552dcb(0x117)])));if(_0x15a0d9)continue;if(_0x540638>=config['mapScale']/0x2-config['riverWidth']/0x2&&_0x540638<=config[_0x552dcb(0x10e)]/0x2+config[_0x552dcb(0x106)]/0x2)continue;_0x4709d2++,_0x8468b7['block']=_0x552dcb(0x125);break;}if(_0x4709d2)return my[_0x552dcb(0xf3)]=0x1,player['chat'][_0x552dcb(0x13d)]=_0x552dcb(0x12d)+near[_0x552dcb(0x124)],player[_0x552dcb(0x111)]['count']=0x7d0,!![];}}catch(_0x3528c6){return null;}return![];},this[_0x2835e9(0xf9)]=function(_0x216109,_0x50a848){const _0x29c07e=_0x2835e9;if(!getEl(_0x29c07e(0x10f))[_0x29c07e(0xf6)])return;console[_0x29c07e(0xff)](_0x29c07e(0xec));if(_0x50a848&&enemy['length']){if(cdf(near,player)>cdf(near,_0x50a848))for(let _0x5c5174=-(Math['PI']/0x2);_0x5c5174<Math['PI']/0x2;_0x5c5174+=Math['PI']/0x12){checkPlace(0x2,near[_0x29c07e(0x14e)]+_0x5c5174);}if(cdf(near,_0x50a848)>cdf(near,player)){if(player['items'][0x4])for(let _0x1c7d59=-(Math['PI']/0x2);_0x1c7d59<Math['PI']/0x2;_0x1c7d59+=Math['PI']/0x12){checkPlace(0x4,near['aim2']+_0x1c7d59)&&this['testCanPlace'](0x4,-(Math['PI']/0x2),Math['PI']/0x2,Math['PI']/0x12,_0x216109+Math['PI']);}else for(let _0x21730c=-(Math['PI']/0x2);_0x21730c<Math['PI']/0x2;_0x21730c+=Math['PI']/0x12){checkPlace(0x2,near['aim2']+_0x21730c)&&this[_0x29c07e(0x120)](0x2,-(Math['PI']/0x2),Math['PI']/0x2,Math['PI']/0x12,_0x216109+Math['PI']);}}}else player['items'][0x4]&&player['items'][0x2]&&(this[_0x29c07e(0x120)](0x2,-(Math['PI']/0x2),Math['PI']/0x2,Math['PI']/0x12,_0x216109+Math['PI']),this[_0x29c07e(0xfe)]=!![]);});let placedSpikePositions=new Set(),placedTrapPositions=new Set();function _0x2fb6(){const _0x2b8de5=['owner','round','61XFaoUl','1238WGZQnn','antiTrapped','log','tickBase','checked','12341208NPAcQY','checkSpikeTick','2728088qTCgBG','info','riverWidth','includes','9jpbCwr','GoodAngle','Replaced','ramdomplc','inTrap','getDirect','mapScale','antiTrap','max','chat','replacer','weaponIndex','11216440BunfAT','autoPlacetype','canSpikeTick','isItem','getScale','Preplace','getAngleDist','spamtrap2','attempts','length','forEach','autoplace','testCanPlace','health','getDist','blocker','sid','blocked','gatherAngle','primaryIndex','tick','PrePlacer','57570deGPse','tickRate','AntiSpikeTick','Anti\x20','find','atan2','toRad','filter','dist3','Check\x20If\x20PrePlace\x20Failed','min','magicplace','replaced','placed','placeOffset','items','autoPlace','type','trap','message','autoPush','isTeamObject','testPrePlace','random','347296WrivHz','active','scale','value','Autoplace','notFast','364MOZuWI','dmg','colDiv','spikeTick','hypot','unblocked','aim2','list','24aZWdmd','range','spamtrap','dist2','alive','Fuck\x20This\x20Trap','ticking','getDistance','sort','sin','cos','363635rFZEiz','anti0Tick','aiplace','Replace','chcked','push','weapons','protect'];_0x2fb6=function(){return _0x2b8de5;};return _0x2fb6();}function isBroken(){}function _0x20e7(_0x4fa235,_0x58e9ba){const _0x2fb67d=_0x2fb6();return _0x20e7=function(_0x20e797,_0x139598){_0x20e797=_0x20e797-0xe7;let _0x410875=_0x2fb67d[_0x20e797];return _0x410875;},_0x20e7(_0x4fa235,_0x58e9ba);}function RealPreplacerOP(){}this[_0x2835e9(0x140)]=function(){const _0x4596e9=_0x2835e9;if(!getEl(_0x4596e9(0x119))[_0x4596e9(0x101)]){console[_0x4596e9(0xff)](_0x4596e9(0x133));return;}if(near['dist2']<0xfa){const _0x3d557e=gameObjects[_0x4596e9(0x131)](_0x7cd104=>cdf(player,_0x7cd104)<=0xc8&&_0x7cd104[_0x4596e9(0xeb)]==!![]);console[_0x4596e9(0xff)]('PrePlacing'),_0x3d557e[_0x4596e9(0x11e)](_0x2d205f=>{const _0x5a1aca=_0x4596e9;if(RealPreplacerOP(_0x2d205f)){const _0x5dc5ca=UTILS[_0x5a1aca(0x10d)](_0x2d205f,player,0x0,0x2);console[_0x5a1aca(0xff)]('TestPrePlace:\x20Succesfull'),setTimeout(()=>{place(0x2,_0x5dc5ca,0x1);},window['pingTime']+0x19);}});}},this[_0x2835e9(0x13a)]=function(){const _0x3a7c13=_0x2835e9;if(getEl(_0x3a7c13(0x115))['value']==_0x3a7c13(0x11b)){if(game[_0x3a7c13(0x128)]%0.5===0x0)try{if(getEl(_0x3a7c13(0x146))['checked']){const _0x4933de=near[_0x3a7c13(0xea)],_0x6498ee=gameObjects[_0x3a7c13(0x131)](_0xd45f7=>_0xd45f7['trap']&&_0xd45f7[_0x3a7c13(0x143)])[_0x3a7c13(0xef)]((_0x448dde,_0x5ef3ba)=>UTILS[_0x3a7c13(0x122)](_0x448dde,near,0x0,0x2)-UTILS[_0x3a7c13(0x122)](_0x5ef3ba,near,0x0,0x2))[_0x3a7c13(0x12e)](_0x23e642=>{const _0x15d8ef=_0x3a7c13,_0x6119d2=Math[_0x15d8ef(0x14c)](_0x23e642['y']-near['y2'],_0x23e642['x']-near['x2']);return _0x23e642!==player&&(player[_0x15d8ef(0x124)]===_0x23e642[_0x15d8ef(0xfa)][_0x15d8ef(0x124)]||findAllianceBySid(_0x23e642[_0x15d8ef(0xfa)][_0x15d8ef(0x124)]))&&_0x6119d2<=near[_0x15d8ef(0x144)]*1.8;});if(_0x6498ee&&near[_0x3a7c13(0xea)]<=0xc8)this[_0x3a7c13(0x120)](0x2,Math[_0x3a7c13(0x12f)](player['y']-_0x6498ee['y'],player['x']-_0x6498ee['x'])+Math['PI']);else{if(!_0x6498ee&&_0x4933de<=0x190){if(_0x4933de<0xb4)for(let _0x50ff5f=-0x37;_0x50ff5f<0x37;_0x50ff5f+=0x37){this[_0x3a7c13(0x120)](0x2,near[_0x3a7c13(0x14e)]+toR(_0x50ff5f));}if(_0x4933de>=0xc8)for(let _0x47ec8a=-0x5a;_0x47ec8a<0x10e;_0x47ec8a+=0x5a){this['testCanPlace'](0x4,near[_0x3a7c13(0x14e)]+toR(_0x47ec8a));}}}}}catch(_0x1fbe7a){}}},this['autoPlace']=function(){const _0x261d4d=_0x2835e9;if(enemy[_0x261d4d(0x11d)]&&getEl(_0x261d4d(0x146))['checked']&&!instaC['ticking']){if(getEl(_0x261d4d(0x115))[_0x261d4d(0x145)]==_0x261d4d(0xe9)){if(game['tick']%(Math['max'](0x1,parseInt())||0x1)===0x0){if(gameObjects[_0x261d4d(0x11d)]){let _0x52c5e4={'inTrap':![]},_0x315734=gameObjects['filter'](_0xad4f5f=>_0xad4f5f[_0x261d4d(0x13c)]&&_0xad4f5f[_0x261d4d(0x143)]&&_0xad4f5f[_0x261d4d(0x13f)](player)&&UTILS[_0x261d4d(0x122)](_0xad4f5f,near,0x0,0x2)<=near[_0x261d4d(0x144)]+_0xad4f5f['getScale']()+0x5)[_0x261d4d(0xef)](function(_0x176df0,_0x283686){const _0x21aef1=_0x261d4d;return UTILS[_0x21aef1(0x122)](_0x176df0,near,0x0,0x2)-UTILS[_0x21aef1(0x122)](_0x283686,near,0x0,0x2);})[0x0];_0x315734?_0x52c5e4[_0x261d4d(0x10c)]=!![]:_0x52c5e4['inTrap']=![],(testMode?enemy[_0x261d4d(0x11d)]:near['dist2']<=0x12c)&&(near[_0x261d4d(0xea)]<=0xc8?this['testCanPlace'](0x4,0x0,Math['PI']*0x2,Math['PI']/0x18,near['aim2'],0x0,{'inTrap':_0x52c5e4[_0x261d4d(0x10c)]}):player[_0x261d4d(0x139)][0x4]==0xf&&this[_0x261d4d(0x120)](0x4,0x0,Math['PI']*0x2,Math['PI']/0x18,near[_0x261d4d(0x14e)]));}else(testMode?enemy[_0x261d4d(0x11d)]:near[_0x261d4d(0xea)]<=0x12c)&&(player[_0x261d4d(0x139)][0x4]==0xf&&this[_0x261d4d(0x120)](0x4,0x0,Math['PI']*0x2,Math['PI']/0x18,near['aim2']));}}}},this[_0x2835e9(0x13a)]=function(){const _0xb6e08d=_0x2835e9;if(!getEl('Autoplace')[_0xb6e08d(0x101)]||!player||!player[_0xb6e08d(0xeb)]){if(getEl(_0xb6e08d(0x115))[_0xb6e08d(0x145)]==_0xb6e08d(0x10b))return;}const _0x9659e0=near[_0xb6e08d(0xea)],_0x5c4499=gameObjects[_0xb6e08d(0x12e)](_0x408c67=>_0x408c67['trap']&&_0x408c67[_0xb6e08d(0x143)]&&player[_0xb6e08d(0x13f)](_0x408c67));let _0x640ce4=_0x5c4499&&UTILS[_0xb6e08d(0x122)](_0x5c4499,player,0x0,0x2)<=player[_0xb6e08d(0x144)]*1.8;if(_0x5c4499&&_0x640ce4&&_0x9659e0<=0xc8){const _0x5639f9=calculatePerfectAngle(player['x'],player['y'],_0x5c4499['x'],_0x5c4499['y']),_0x1f0108=Math[_0xb6e08d(0x141)]()*(Math['PI']/0xa);checkPlace(0x2,_0x5639f9-_0x1f0108);}else{if(!_0x5c4499||!_0x640ce4&&player[_0xb6e08d(0x139)][0x4]===0xf&&_0x9659e0<=0x12c){const _0x52c496=Math['PI']/0x6,_0x21db35=Math[_0xb6e08d(0x134)](0x1,Math[_0xb6e08d(0x110)](0x0,_0x9659e0-0x96)/0x82),_0x238062=_0x52c496*_0x21db35,_0x53db24=[0x0,Math['PI']/0x2,Math['PI'],0x3*Math['PI']/0x2];for(const _0x1d6d0a of _0x53db24){checkPlace(0x4,near[_0xb6e08d(0x14e)]+_0x238062+_0x1d6d0a);}}}},this['autoPlace']=function(){const _0x1c3165=_0x2835e9;if(getEl(_0x1c3165(0x146))[_0x1c3165(0x101)]&&game[_0x1c3165(0x128)]%(Math[_0x1c3165(0x110)](0x1,parseInt())||0x1)===0x0){if(getEl(_0x1c3165(0x115))[_0x1c3165(0x145)]==_0x1c3165(0xf4))try{const _0x4708aa=gameObjects[_0x1c3165(0x131)](_0x38f5b3=>_0x38f5b3[_0x1c3165(0x13c)]&&_0x38f5b3[_0x1c3165(0x143)])['sort']((_0x32dacb,_0x11a3a4)=>UTILS[_0x1c3165(0x122)](_0x32dacb,near,0x0,0x2)-UTILS[_0x1c3165(0x122)](_0x11a3a4,near,0x0,0x2))[_0x1c3165(0x12e)](_0x175c03=>{const _0x46b5cf=_0x1c3165,_0x56c3e3=Math['hypot'](_0x175c03['y']-near['y2'],_0x175c03['x']-near['x2']);return _0x175c03!==player&&(player[_0x46b5cf(0x124)]===_0x175c03[_0x46b5cf(0xfa)][_0x46b5cf(0x124)]||findAllianceBySid(_0x175c03[_0x46b5cf(0xfa)][_0x46b5cf(0x124)]))&&_0x56c3e3<=0x32;});if(this['inTrap']){let _0x21e985=Math['PI']/Math['floor'](Math[_0x1c3165(0x141)]()*(0x14-0xa+0x1))+0xa;this[_0x1c3165(0x120)](0x4,-(Math['PI']/0x2),Math['PI']/0x2,_0x21e985,near['aim2']);}else{if(_0x4708aa&&near['dist2']<=0xb4){const _0xc43fcb=_0x4708aa['x'],_0xf3ee09=_0x4708aa['y'],_0x55d636=0x66,_0x2bb00d=0x40;for(let _0x23e77a=0x0;_0x23e77a<_0x2bb00d;_0x23e77a++){const _0x2662d0=0x2*Math['PI']*_0x23e77a/_0x2bb00d,_0x120a7e=_0xc43fcb+_0x55d636*Math[_0x1c3165(0xf1)](_0x2662d0),_0x547976=_0xf3ee09+_0x55d636*Math[_0x1c3165(0xf0)](_0x2662d0),_0x521a01=[_0x120a7e,_0x547976],_0x270f4d=Math[_0x1c3165(0x14c)](_0x521a01[0x0]-player['x2'],_0x521a01[0x1]-player['y2']);if(isPositionValid(_0x521a01)&&_0x270f4d<=0x57){const _0x424821=Math[_0x1c3165(0x12f)](_0x521a01[0x1]-player['y2'],_0x521a01[0x0]-player['x2']);checkPlace(0x2,_0x424821);}}}else{if(!_0x4708aa&&near[_0x1c3165(0xea)]<=0xce){const _0x3dfdad=0x3,_0x5e02c3=0x32,_0x40ce9a=calculatePossibleTrapPositions(player['x2'],player['y2'],_0x5e02c3);let _0x5732bb=0x0;for(const _0x2be37e of _0x40ce9a){_0x5732bb<_0x3dfdad&&isPositionValid(_0x2be37e)&&(checkPlace(0x4,..._0x2be37e),_0x5732bb++);}}}}}catch(_0x4a7a7a){console[_0x1c3165(0xff)](_0x4a7a7a);}};},this[_0x2835e9(0x13a)]=function(){const _0x8f40f7=_0x2835e9;if(enemy['length']&&getEl('Autoplace')[_0x8f40f7(0x101)]&&!instaC[_0x8f40f7(0xed)]){if(game[_0x8f40f7(0x128)]%(Math[_0x8f40f7(0x110)](0x1,parseInt())||0x1)===0x0){if(gameObjects[_0x8f40f7(0x11d)]){let _0x46ea4d={'inTrap':![]},_0xb7981f=gameObjects['filter'](_0xd839=>_0xd839[_0x8f40f7(0x13c)]&&_0xd839[_0x8f40f7(0x143)]&&_0xd839[_0x8f40f7(0x13f)](player)&&UTILS['getDist'](_0xd839,near,0x0,0x2)<=near[_0x8f40f7(0x144)]+_0xd839[_0x8f40f7(0x118)]()+0x5)[_0x8f40f7(0xef)](function(_0x3b1ae1,_0x445468){const _0x216834=_0x8f40f7;return UTILS[_0x216834(0x122)](_0x3b1ae1,near,0x0,0x2)-UTILS[_0x216834(0x122)](_0x445468,near,0x0,0x2);})[0x0];_0xb7981f?_0x46ea4d[_0x8f40f7(0x10c)]=!![]:_0x46ea4d[_0x8f40f7(0x10c)]=![],near[_0x8f40f7(0x132)]<=0x1c2&&(near['dist3']<=0xc8?this['testCanPlace'](0x4,0x0,Math['PI']*0x2,Math['PI']/0x18,near[_0x8f40f7(0x14e)],0x0,{'inTrap':_0x46ea4d['inTrap']}):player[_0x8f40f7(0x139)][0x4]==0xf&&this[_0x8f40f7(0x120)](0x4,0x0,Math['PI']*0x2,Math['PI']/0x18,near[_0x8f40f7(0x14e)]));}else near[_0x8f40f7(0x132)]<=0x1c2&&(player[_0x8f40f7(0x139)][0x4]==0xf&&this[_0x8f40f7(0x120)](0x4,0x0,Math['PI']*0x2,Math['PI']/0x18,near[_0x8f40f7(0x14e)]));}}},this[_0x2835e9(0x13a)]=function(){const _0x10c75c=_0x2835e9;if(getEl('autoPlacetype')[_0x10c75c(0x145)]==_0x10c75c(0x109)){let _0x47c94b=[];if(gameObjects['length']&&enemy[_0x10c75c(0x11d)]){let _0x802094=![];_0x47c94b=gameObjects[_0x10c75c(0x131)](_0x3e292d=>_0x3e292d[_0x10c75c(0x13c)])['sort'](function(_0x561016,_0x5cb1d3){const _0x518eae=_0x10c75c;return UTILS[_0x518eae(0x122)](_0x561016,near,0x0,0x2)-UTILS['getDist'](_0x5cb1d3,near,0x0,0x2);})[0x0];if(_0x47c94b){!(player['sid']!=_0x47c94b[_0x10c75c(0xfa)]['sid']&&!findAllianceBySid(_0x47c94b[_0x10c75c(0xfa)][_0x10c75c(0x124)]))&&UTILS[_0x10c75c(0x122)](_0x47c94b,near,0x0,0x2)<=0x46&&_0x47c94b[_0x10c75c(0x143)]?_0x802094=!![]:_0x802094=![];if(near[_0x10c75c(0xea)]<=0x15e){_0x802094&&near[_0x10c75c(0xea)]<=0xc8&&(near[_0x10c75c(0xea)]<=player['scale']+near[_0x10c75c(0x144)]+Math['PI']*0x2&&(checkPlace(0x2,near[_0x10c75c(0x14e)]-UTILS['getDirect'](_0x47c94b,near,0x0,0x2)),checkPlace(0x2,near[_0x10c75c(0x14e)]+UTILS[_0x10c75c(0x10d)](_0x47c94b,near,0x0,0x2))));if(near[_0x10c75c(0xea)]<=near['scale']+player[_0x10c75c(0x144)])checkPlace(0x2,near[_0x10c75c(0x14e)]);else{if(near[_0x10c75c(0xea)]<=0xc8&&!instaC[_0x10c75c(0x116)]&&!traps['in']&&!_0x802094)checkPlace(0x2,near['aim2']+UTILS[_0x10c75c(0x130)](0x5a)),checkPlace(0x2,near[_0x10c75c(0x14e)]-UTILS['toRad'](0x5a));else{if(near[_0x10c75c(0xea)]<=0xfa)checkPlace(0x2,near[_0x10c75c(0x14e)]+Math['PI']);else for(let _0x42abbe=0x0;_0x42abbe<0x168;_0x42abbe+=0x5a){checkPlace(0x4,UTILS['toRad'](_0x42abbe));}}}}}}}},this[_0x2835e9(0x129)]=function(){const _0x216ff4=_0x2835e9;if(!getEl(_0x216ff4(0x119))[_0x216ff4(0x101)]||!inGame||this[_0x216ff4(0xfe)])return;const _0xb243ec=player['x4'],_0x8bbdc=player['y4'],_0x3e1327=(items['weapons'][player[_0x216ff4(0xf8)][0x0]?player['weaponIndex']:0x4]['range']+0x46)**0x2;gameObjects[_0x216ff4(0x11e)](_0x58c9e8=>{const _0x623b52=_0x216ff4,_0x59c291=(_0x58c9e8['x2']-_0xb243ec)**0x2+(_0x58c9e8['y2']-_0x8bbdc)**0x2;if(_0x59c291<=_0x3e1327){let _0x4c3c99=UTILS[_0x623b52(0x10d)](_0x58c9e8,player,0x0,0x2);if(player[_0x623b52(0x139)][0x4]==0xf){const _0x3d67f8=Math[_0x623b52(0x141)]()*Math['PI']*0x2;checkPlace(0x4,_0x4c3c99+_0x3d67f8);}else checkPlace(0x2,_0x4c3c99);}});},this[_0x2835e9(0x11f)]=function(){const _0x18acb0=_0x2835e9;let _0x5814e8={'x':undefined,'y':undefined};if(getEl(_0x18acb0(0x115))[_0x18acb0(0x145)]==_0x18acb0(0x135)){let _0x198160=[],_0x48d611=Math['random']()*Math['PI']*0x2;if(gameObjects['length']&&enemy[_0x18acb0(0x11d)]){let _0x1f4648={'inTrap':![]};_0x198160=gameObjects[_0x18acb0(0x131)](_0x1e632d=>_0x1e632d[_0x18acb0(0x13c)])[_0x18acb0(0xef)](function(_0x301b6f,_0x666a7a){const _0x23b33b=_0x18acb0;return UTILS[_0x23b33b(0x122)](_0x301b6f,near,0x0,0x2)-UTILS[_0x23b33b(0x122)](_0x666a7a,near,0x0,0x2);})[0x0];let _0x3f2339=gameObjects['filter'](_0x2a772e=>_0x2a772e[_0x18acb0(0x13c)]&&_0x2a772e['active']&&_0x2a772e[_0x18acb0(0x13f)](player)&&UTILS[_0x18acb0(0x122)](_0x2a772e,near,0x0,0x2)<=near[_0x18acb0(0x144)]+_0x2a772e[_0x18acb0(0x118)]()+0x5)['sort'](function(_0x5eb442,_0x5f451e){const _0x51e9e6=_0x18acb0;return UTILS[_0x51e9e6(0x122)](_0x5eb442,near,0x0,0x2)-UTILS[_0x51e9e6(0x122)](_0x5f451e,near,0x0,0x2);})[0x0],_0x3d6263={'inTrap':![]};_0x3f2339?_0x3d6263['inTrap']=!![]:_0x3d6263[_0x18acb0(0x10c)]=![];if(_0x198160){!(player[_0x18acb0(0x124)]!=_0x198160[_0x18acb0(0xfa)]['sid']&&!findAllianceBySid(_0x198160['owner']['sid']))&&UTILS['getDist'](_0x198160,near,0x0,0x2)<=0x46&&_0x198160['active']?_0x1f4648[_0x18acb0(0x10c)]=!![]:_0x1f4648[_0x18acb0(0x10c)]=![];if(near[_0x18acb0(0xea)]<=0x258){if(_0x1f4648[_0x18acb0(0x10c)]||near[_0x18acb0(0xea)]<=0x3c+near['scale']){if(near[_0x18acb0(0xea)]<=0xfa)for(let _0x197080=0x0;_0x197080<Math['PI']*0x2;_0x197080+=Math['PI']/1.5){checkPlace(0x2,near['aim2']+_0x197080);}else for(let _0x41f1b1=Math['PI']/1.5;_0x41f1b1<Math['PI']*0x2;_0x41f1b1+=Math['PI']/1.5){checkPlace(0x2,near[_0x18acb0(0x14e)]+_0x41f1b1);}}else{if(player['items'][0x4]==0xf){if(near[_0x18acb0(0xea)]<=0xc8)for(let _0x1dfbf3=0x0;_0x1dfbf3<Math['PI']*0x2;_0x1dfbf3+=Math['PI']/0x2){checkPlace(0x4,_0x48d611+_0x1dfbf3);}}}}}else near[_0x18acb0(0xea)]<=0x190&&(player['items'][0x4]==0xf&&checkPlace(0x4,near['aim2']));}}};function calculatePerfectAngle(_0x567dc2,_0x4caf7d,_0x40855f,_0x44912d){const _0x2cfd6c=_0x2835e9;return Math[_0x2cfd6c(0x12f)](_0x44912d-_0x4caf7d,_0x40855f-_0x567dc2);}this[_0x2835e9(0x112)]=function(_0x316243){const _0x5a912c=_0x2835e9;if(!_0x316243||!getEl(_0x5a912c(0xf5))[_0x5a912c(0x101)])return;if(!inGame)return;if(this[_0x5a912c(0xfe)])return;game[_0x5a912c(0x100)](()=>{const _0x56d977=_0x5a912c;let _0x46ae90=UTILS[_0x56d977(0x10d)](_0x316243,player,0x0,0x2),_0x13407c=UTILS[_0x56d977(0x122)](_0x316243,player,0x0,0x2),_0x17f7f5=Math[_0x56d977(0xfb)](calculatePerfectAngle(_0x316243['x'],_0x316243['y'],player['x'],player['y'])/(Math['PI']/0x2))*(Math['PI']/0x2),_0x19c5fa=[0x4,0x5][_0x56d977(0x107)](player[_0x56d977(0xf8)][0x0])&&near['dist2']<=items[_0x56d977(0xf8)][near[_0x56d977(0x127)]||0x5][_0x56d977(0xe8)]+near[_0x56d977(0x144)]*1.2&&player['reloads'][player[_0x56d977(0xf8)][0x0]]==0x0;if(getEl('weaponGrind')['checked']&&_0x13407c<=items[_0x56d977(0xf8)][player[_0x56d977(0x113)]]['range']+player[_0x56d977(0x144)])return;let _0x28b983=this[_0x56d977(0x103)]();if(_0x13407c<=0x12c&&near[_0x56d977(0xea)]<=0x190){if(getEl('Retrap')['checked'])for(let _0x4e5850=-0x1;_0x4e5850<=0x1;_0x4e5850++){this[_0x56d977(0x120)](0x4,-(Math['PI']/0x4),Math['PI']/0x4,Math['PI']/0x12,_0x17f7f5,_0x46ae90,0x1+_0x4e5850),this[_0x56d977(0x120)](0x4,0x0,Math['PI']*0x4,Math['PI']/0x18,_0x17f7f5,_0x46ae90,0x1+_0x4e5850);}else{if(near['dist2']<=0x46&&_0x19c5fa&&getEl(_0x56d977(0x14b))[_0x56d977(0x101)])for(let _0x582772=0x0;_0x582772<Math['PI']*0x2;_0x582772+=Math['PI']/0x2){this[_0x56d977(0x120)](0x2,-Math['PI']/0x4,Math['PI']/0x4,Math['PI']/0x14,near[_0x56d977(0x14e)],0x1,_0x46ae90+_0x582772),this[_0x56d977(0x120)](0x4,-Math['PI']/0x4,Math['PI']/0x4,Math['PI']/0xc,near[_0x56d977(0x14e)]+Math['PI'],0x1,_0x46ae90+_0x582772);}else{if(!_0x28b983&&near['dist2']<=items['weapons'][near[_0x56d977(0x127)]||0x5][_0x56d977(0xe8)]+near[_0x56d977(0x144)]*1.8)for(let _0x4a8065=0x0;_0x4a8065<Math['PI']*0x2;_0x4a8065+=Math['PI']/0x2){this[_0x56d977(0x120)](0x2,0x0,Math['PI']*0x2,Math['PI']/0x18,_0x46ae90+toRad(_0x4a8065),0x1,_0x46ae90);}else{if(traps[_0x56d977(0x10c)]&&near[_0x56d977(0xea)]<0x190?my[_0x56d977(0x13e)]:!_0x28b983)for(let _0x208eeb=-0x1;_0x208eeb<=0x1;_0x208eeb++){this[_0x56d977(0x120)](0x4,-(Math['PI']/0x4),Math['PI']/0x4,Math['PI']/0x12,_0x17f7f5,_0x46ae90,0x1+_0x208eeb),this['testCanPlace'](0x4,0x0,Math['PI']*0x4,Math['PI']/0x18,_0x17f7f5,_0x46ae90,0x1+_0x208eeb);}else{if(player[_0x56d977(0x139)][0x4]==0xf)for(let _0x48ff2e=-0x1;_0x48ff2e<=0x1;_0x48ff2e++){for(let _0x33c3cd=+0x1;_0x33c3cd<=0x1;_0x33c3cd++){ShowSettingTextBlack(0x12c,_0x56d977(0x10a)),this['testCanPlace'](near[_0x56d977(0xea)]>0xb4?0x4:0x2,0x0,Math['PI']*0x2,Math['PI']/0x18,_0x17f7f5+_0x48ff2e*(Math['PI']/0x4),0x1,_0x46ae90+_0x48ff2e,_0x33c3cd);}}this[_0x56d977(0x136)]=!![];}}}}}},0x1);};
    }
};
class Instakill {
    constructor() {
        if (secPacket > 60) return
        this.wait = false;
        this.can = false;
        this.isTrue = false;
        this.nobull = false;
        this.ticking = false;
        this.canSpikeTick = false;
        this.startTick = false;
        this.readyTick = false;
        this.canCounter = false;
        this.revTick = false;
        this.syncHit = false;
        // UNOREVERSE CODE
        function _0x240d(_0x2d08fc,_0x5e3a20){const _0x4becbf=_0x4bec();return _0x240d=function(_0x240d5e,_0xc13828){_0x240d5e=_0x240d5e-0x163;let _0x2e911a=_0x4becbf[_0x240d5e];return _0x2e911a;},_0x240d(_0x2d08fc,_0x5e3a20);}const _0x4d0e02=_0x240d;(function(_0x5c9dd5,_0x11ed2f){const _0x195137=_0x240d,_0x2963cf=_0x5c9dd5();while(!![]){try{const _0x121612=parseInt(_0x195137(0x188))/0x1*(parseInt(_0x195137(0x18b))/0x2)+parseInt(_0x195137(0x183))/0x3*(parseInt(_0x195137(0x181))/0x4)+-parseInt(_0x195137(0x17a))/0x5+-parseInt(_0x195137(0x1aa))/0x6*(-parseInt(_0x195137(0x19b))/0x7)+-parseInt(_0x195137(0x16d))/0x8+parseInt(_0x195137(0x173))/0x9+-parseInt(_0x195137(0x1ab))/0xa;if(_0x121612===_0x11ed2f)break;else _0x2963cf['push'](_0x2963cf['shift']());}catch(_0x545fb9){_0x2963cf['push'](_0x2963cf['shift']());}}}(_0x4bec,0x69596),this[_0x4d0e02(0x175)]=function(_0x1ecf42){const _0x28e04f=_0x4d0e02;this['wait']=![],this[_0x28e04f(0x191)]=!![],my[_0x28e04f(0x17e)]=!![];let _0xd3a97e=[_0x1ecf42],_0x7ef02b=near[_0x28e04f(0x16c)];near[_0x28e04f(0x16c)]=![],game[_0x28e04f(0x199)](()=>{const _0x274b07=_0x28e04f;_0xd3a97e[_0x274b07(0x190)](player[_0x274b07(0x16f)]),game[_0x274b07(0x199)](()=>{const _0x422823=_0x274b07;near[_0x422823(0x16f)]==0x16&&getEl(_0x422823(0x16c))[_0x422823(0x1a3)]&&(near[_0x422823(0x16c)]=!![]),_0xd3a97e[_0x422823(0x190)](player[_0x422823(0x16f)]);},0x1);},0x1);if(_0x1ecf42==_0x28e04f(0x19f))selectWeapon(player[_0x28e04f(0x1a7)][0x1]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),sendAutoGather(),game[_0x28e04f(0x199)](()=>{const _0x319b4c=_0x28e04f;if(near['dist2']<=0x8c&&getEl(_0x319b4c(0x1a6))['checked'])place(0x2,getAttackDir());selectWeapon(player[_0x319b4c(0x1a7)][0x0]),buyEquip(0x7,0x0),game[_0x319b4c(0x199)](()=>{const _0x381e95=_0x319b4c;sendAutoGather(),this[_0x381e95(0x191)]=![],my[_0x381e95(0x17e)]=![];},0x1);},0x1);else{if(_0x1ecf42=='nobull')selectWeapon(player[_0x28e04f(0x1a7)][0x0]),sendAutoGather(),game['tickBase'](()=>{const _0x57898e=_0x28e04f;selectWeapon(player[_0x57898e(0x1a7)][0x1]),buyEquip(player[_0x57898e(0x198)][0x35]==0x0?0x35:0x6,0x0),buyEquip(0x15,0x1),game[_0x57898e(0x199)](()=>{const _0x213210=_0x57898e;sendAutoGather(),this[_0x213210(0x191)]=![],my[_0x213210(0x17e)]=![];},0x1);},0x1);else _0x1ecf42==_0x28e04f(0x166)?(selectWeapon(player['weapons'][0x0]),buyEquip(0x7,0x0),sendAutoGather(),game[_0x28e04f(0x199)](()=>{selectWeapon(player['weapons'][0x1]),buyEquip(player['reloads'][0x35]==0x0?0x35:0x6,0x0),buyEquip(0x15,0x1),game['tickBase'](()=>{const _0x1898da=_0x240d;sendAutoGather(),this[_0x1898da(0x191)]=![],my['autoAim']=![];},0x1);},0x1)):setTimeout(()=>{const _0x1a447f=_0x28e04f;this[_0x1a447f(0x191)]=![],my[_0x1a447f(0x17e)]=![];},0x32);}},this[_0x4d0e02(0x186)]=function(){const _0x20fb4b=_0x4d0e02;ShowSettingTextRed(0x12c,_0x20fb4b(0x184)),this[_0x20fb4b(0x191)]=!![],my[_0x20fb4b(0x17e)]=!![],healer(),selectWeapon(player[_0x20fb4b(0x1a7)][0x0]),buyEquip(0x7,0x0),sendAutoGather(),game[_0x20fb4b(0x199)](()=>{const _0x36b2a0=_0x20fb4b;selectWeapon(player[_0x36b2a0(0x1a7)][0x0]),buyEquip(0x35,0x0),game[_0x36b2a0(0x199)](()=>{const _0x3bf156=_0x36b2a0;sendAutoGather(),this[_0x3bf156(0x191)]=![],my[_0x3bf156(0x17e)]=![];},0x1);},0x1);},this[_0x4d0e02(0x1a0)]=function(){const _0x5269c3=_0x4d0e02;this[_0x5269c3(0x191)]=!![],my[_0x5269c3(0x17e)]=!![],selectWeapon(player[_0x5269c3(0x1a7)][0x0]),buyEquip(0x7,0x0),sendAutoGather(),game[_0x5269c3(0x199)](()=>{const _0xcea507=_0x5269c3;selectWeapon(player[_0xcea507(0x1a7)][0x0]),buyEquip(0x35,0x0),game['tickBase'](()=>{const _0x569d3c=_0xcea507;sendAutoGather(),this[_0x569d3c(0x191)]=![],my[_0x569d3c(0x17e)]=![];},0x1);},0x1);},this[_0x4d0e02(0x187)]=function(){const _0x113c7a=_0x4d0e02;this[_0x113c7a(0x191)]=!![],my[_0x113c7a(0x17e)]=!![],selectWeapon(player[_0x113c7a(0x1a7)][0x0]),buyEquip(0x7,0x0),sendAutoGather(),game['tickBase'](()=>{const _0x5ae3e5=_0x113c7a;selectWeapon(player[_0x5ae3e5(0x1a7)][0x0]),buyEquip(0x35,0x0),game[_0x5ae3e5(0x199)](()=>{const _0x324181=_0x5ae3e5;sendAutoGather(),this[_0x324181(0x191)]=![],my[_0x324181(0x17e)]=![];},0x1);},0x1);},this[_0x4d0e02(0x1ad)]=function(){const _0x591de6=_0x4d0e02;buyEquip(0x35,0x0),game[_0x591de6(0x199)](()=>{const _0x2d9eb6=_0x591de6;this['isTrue']=!![],my[_0x2d9eb6(0x17e)]=!![],selectWeapon(player[_0x2d9eb6(0x1a7)][0x1]),sendAutoGather(),game[_0x2d9eb6(0x199)](()=>{const _0x189dd1=_0x2d9eb6;my[_0x189dd1(0x17e)]=![],this[_0x189dd1(0x191)]=![],sendAutoGather();},0x1);},0x2);},this['MapSync']=function(){const _0x3ddeac=_0x4d0e02;let _0x40df2e;_0x40df2e=near[_0x3ddeac(0x19c)]<=0x12c?0x1:0x2,buyEquip(0x35,0x0),game['tickBase'](()=>{const _0x23a9e1=_0x3ddeac;selectWeapon(player[_0x23a9e1(0x1a7)][0x1]),sendAutoGather(),this[_0x23a9e1(0x191)]=!![],my[_0x23a9e1(0x17e)]=!![],game['tickBase'](()=>{const _0x591e59=_0x23a9e1;my[_0x591e59(0x17e)]=![],this['isTrue']=![],sendAutoGather();},0x1);},_0x40df2e);},this['rangeType']=function(_0x4319e8){const _0x316fe7=_0x4d0e02;this[_0x316fe7(0x191)]=!![],my[_0x316fe7(0x17e)]=!![],_0x4319e8==_0x316fe7(0x195)?(my[_0x316fe7(0x195)]=![],player[_0x316fe7(0x18e)][0x5]==0x12&&place(0x5,near[_0x316fe7(0x1a5)]),packet('9',undefined,0x1),buyEquip(0x16,0x0),buyEquip(0x15,0x1),game[_0x316fe7(0x199)](()=>{const _0x3dc2d3=_0x316fe7;selectWeapon(player[_0x3dc2d3(0x1a7)][0x1]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),sendAutoGather(),game[_0x3dc2d3(0x199)](()=>{const _0x18a79f=_0x3dc2d3;sendUpgrade(0xc),selectWeapon(player[_0x18a79f(0x1a7)][0x1]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),game[_0x18a79f(0x199)](()=>{const _0x52c4c4=_0x18a79f;sendUpgrade(0xf),selectWeapon(player[_0x52c4c4(0x1a7)][0x1]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),game['tickBase'](()=>{const _0x315695=_0x52c4c4;sendAutoGather(),this['isTrue']=![],my[_0x315695(0x17e)]=![];},0x1);},0x1);},0x1);},0x1)):(selectWeapon(player[_0x316fe7(0x1a7)][0x1]),player['reloads'][0x35]==0x0&&near['dist2']<=0x2bc&&near[_0x316fe7(0x16f)]!=0x16?buyEquip(0x35,0x0):buyEquip(0x14,0x0),buyEquip(0xb,0x1),sendAutoGather(),game[_0x316fe7(0x199)](()=>{const _0x531edb=_0x316fe7;sendAutoGather(),this[_0x531edb(0x191)]=![],my['autoAim']=![];},0x1));},this[_0x4d0e02(0x16e)]=function(){const _0x1a7297=_0x4d0e02;io[_0x1a7297(0x1a2)](''),this[_0x1a7297(0x191)]=!![],my[_0x1a7297(0x17e)]=!![],selectWeapon(player[_0x1a7297(0x1a7)][[0xa,0xe][_0x1a7297(0x16b)](player[_0x1a7297(0x1a7)][0x1])?0x1:0x0]),biomeGear(),buyEquip(0x0,0x1),packet('9',near[_0x1a7297(0x1a5)],0x1),game[_0x1a7297(0x199)](()=>{const _0x5ddd4d=_0x1a7297;selectWeapon(player[_0x5ddd4d(0x1a7)][[0xa,0xe][_0x5ddd4d(0x16b)](player[_0x5ddd4d(0x1a7)][0x1])?0x1:0x0]),buyEquip(0x35,0x0),buyEquip(0x0,0x1),packet('9',near[_0x5ddd4d(0x1a5)],0x1),game['tickBase'](()=>{const _0x44a616=_0x5ddd4d;selectWeapon(player[_0x44a616(0x1a7)][0x0]),buyEquip(0x7,0x0),buyEquip(0x0,0x1),sendAutoGather(),packet('9',near[_0x44a616(0x1a5)],0x1),game[_0x44a616(0x199)](()=>{const _0x3a0608=_0x44a616;sendAutoGather(),this[_0x3a0608(0x191)]=![],my[_0x3a0608(0x17e)]=![],packet('9',undefined,0x1);},0x1);},0x1);},0x1);},this[_0x4d0e02(0x17d)]=function(){const _0x377769=_0x4d0e02;this[_0x377769(0x191)]=!![],my[_0x377769(0x17e)]=!![],biomeGear(),buyEquip(0x13,0x1),packet('9',near[_0x377769(0x1a5)],0x1),game[_0x377769(0x199)](()=>{const _0x427883=_0x377769;player[_0x427883(0x1a7)][0x1]==0xf&&(my[_0x427883(0x192)]=!![]),selectWeapon(player[_0x427883(0x1a7)][[0x9,0xc,0xd,0xf]['includes'](player[_0x427883(0x1a7)][0x1])?0x1:0x0]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),[0x9,0xc,0xd,0xf][_0x427883(0x16b)](player[_0x427883(0x1a7)][0x1])&&sendAutoGather(),packet('9',near[_0x427883(0x1a5)],0x1),game['tickBase'](()=>{const _0x4a0c51=_0x427883;my[_0x4a0c51(0x192)]=![],selectWeapon(player['weapons'][0x0]),buyEquip(0x7,0x0),buyEquip(0x12,0x1),![0x9,0xc,0xd,0xf][_0x4a0c51(0x16b)](player[_0x4a0c51(0x1a7)][0x1])&&sendAutoGather(),packet('9',near[_0x4a0c51(0x1a5)],0x1),game[_0x4a0c51(0x199)](()=>{const _0x2fc560=_0x4a0c51;sendAutoGather(),this['isTrue']=![],my[_0x2fc560(0x17e)]=![],packet('9',undefined,0x1);},0x2);},0x1);},0x1);},this['kmTickType']=function(){const _0x50dcf1=_0x4d0e02;this[_0x50dcf1(0x191)]=!![],my['autoAim']=!![],my['revAim']=!![],selectWeapon(player[_0x50dcf1(0x1a7)][0x1]),buyEquip(0x35,0x0),buyEquip(0x0,0x1),sendAutoGather(),packet('9',near[_0x50dcf1(0x1a5)],0x1),game[_0x50dcf1(0x199)](()=>{const _0x47d301=_0x50dcf1;my[_0x47d301(0x192)]=![],selectWeapon(player['weapons'][0x0]),buyEquip(0x7,0x0),buyEquip(0x0,0x1),packet('9',near[_0x47d301(0x1a5)],0x1),game['tickBase'](()=>{const _0x45e76a=_0x47d301;sendAutoGather(),this[_0x45e76a(0x191)]=![],my[_0x45e76a(0x17e)]=![],packet('9',undefined,0x1);},0x1);},0x1);},this['OneTickType']=function(){const _0xc559af=_0x4d0e02;this[_0xc559af(0x191)]=!![],my[_0xc559af(0x17e)]=!![],biomeGear(),buyEquip(0x13,0x1),packet('9',near[_0xc559af(0x1a5)],0x1),game[_0xc559af(0x199)](()=>{const _0xfe3184=_0xc559af;player[_0xfe3184(0x1a7)][0x1]==0xf&&(my[_0xfe3184(0x192)]=!![]),selectWeapon(player['weapons'][[0x9,0xc,0xd,0xf][_0xfe3184(0x16b)](player[_0xfe3184(0x1a7)][0x1])?0x1:0x0]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),[0x9,0xc,0xd,0xf][_0xfe3184(0x16b)](player[_0xfe3184(0x1a7)][0x1])&&sendAutoGather(),packet('9',near[_0xfe3184(0x1a5)],0x1),game[_0xfe3184(0x199)](()=>{const _0x5027c2=_0xfe3184;my[_0x5027c2(0x192)]=![],selectWeapon(player[_0x5027c2(0x1a7)][0x0]),buyEquip(0x7,0x0),buyEquip(0x12,0x1),![0x9,0xc,0xd,0xf]['includes'](player[_0x5027c2(0x1a7)][0x1])&&sendAutoGather(),packet('9',near[_0x5027c2(0x1a5)],0x1),game[_0x5027c2(0x199)](()=>{const _0x887c5b=_0x5027c2;sendAutoGather(),this[_0x887c5b(0x191)]=![],my[_0x887c5b(0x17e)]=![],packet('9',undefined,0x1);},0x2);},0x1);},0x1);},this['BoostOneTICKERS']=function(){const _0x3c8cc4=_0x4d0e02;this[_0x3c8cc4(0x191)]=!![],my['autoAim']=!![],biomeGear(),buyEquip(0x13,0x1),packet('9',near[_0x3c8cc4(0x1a5)],0x1),game['tickBase'](()=>{const _0x15f3df=_0x3c8cc4;selectWeapon(player[_0x15f3df(0x1a7)][0x0]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),packet('9',near[_0x15f3df(0x1a5)],0x1),place(0x4,near[_0x15f3df(0x1a5)]),game['tickBase'](()=>{const _0x44c5af=_0x15f3df;my[_0x44c5af(0x192)]=![],selectWeapon(player[_0x44c5af(0x1a7)][0x0]),buyEquip(0x7,0x0),buyEquip(0x12,0x1),sendAutoGather(),packet('9',near[_0x44c5af(0x1a5)],0x1),game['tickBase'](()=>{const _0x3534e1=_0x44c5af;sendAutoGather(),this['isTrue']=![],my[_0x3534e1(0x17e)]=![],packet('9',undefined,0x1);},0x5);},0x1);},0x1);},this[_0x4d0e02(0x17c)]=function(){const _0x3e7e05=_0x4d0e02;this['isTrue']=!![],my[_0x3e7e05(0x17e)]=!![],biomeGear(),buyEquip(0x13,0x1),packet('9',near[_0x3e7e05(0x1a5)],0x1),game[_0x3e7e05(0x199)](()=>{const _0x265113=_0x3e7e05;selectWeapon(player[_0x265113(0x1a7)][0x0]),buyEquip(0x35,0x0),buyEquip(0x15,0x1),packet('9',near[_0x265113(0x1a5)],0x1),place(0x4,near['aim2']),game['tickBase'](()=>{const _0x77c14d=_0x265113;my[_0x77c14d(0x192)]=![],selectWeapon(player['weapons'][0x0]),buyEquip(0x7,0x0),place(0x2,getAttackDir()),buyEquip(0x12,0x1),sendAutoGather(),packet('9',near[_0x77c14d(0x1a5)],0x1),game['tickBase'](()=>{const _0x120afa=_0x77c14d;sendAutoGather(),this[_0x120afa(0x191)]=![],my['autoAim']=![],packet('9',undefined,0x1);},0x5);},0x1);},0x1);},this[_0x4d0e02(0x197)]=function(){const _0x189b81=_0x4d0e02;this['isTrue']=!![],my[_0x189b81(0x17e)]=!![],biomeGear(),buyEquip(0xb,0x1),packet('9',near[_0x189b81(0x1a5)],0x1),game[_0x189b81(0x199)](()=>{const _0x58d97a=_0x189b81;player[_0x58d97a(0x1a7)][0x1]==0xf&&(my['revAim']=!![]),selectWeapon(player[_0x58d97a(0x1a7)][[0x9,0xc,0xd,0xf][_0x58d97a(0x16b)](player[_0x58d97a(0x1a7)][0x1])?0x1:0x0]),buyEquip(0x35,0x0),buyEquip(0xb,0x1),[0x9,0xc,0xd,0xf]['includes'](player[_0x58d97a(0x1a7)][0x1])&&sendAutoGather(),packet('9',near[_0x58d97a(0x1a5)],0x1),place(0x4,near[_0x58d97a(0x1a5)]),game[_0x58d97a(0x199)](()=>{const _0x39ff05=_0x58d97a;my[_0x39ff05(0x192)]=![],selectWeapon(player[_0x39ff05(0x1a7)][0x0]),buyEquip(0x7,0x0),buyEquip(0x0,0x1),![0x9,0xc,0xd,0xf]['includes'](player['weapons'][0x1])&&sendAutoGather(),packet('9',near[_0x39ff05(0x1a5)],0x1),game[_0x39ff05(0x199)](()=>{const _0x311b7b=_0x39ff05;sendAutoGather(),this[_0x311b7b(0x191)]=![],my['autoAim']=![],packet('9',undefined,0x1);},0x5);},0x1);},0x1);},this['gotoGoal']=function(_0x26a3ce,_0x3273a9){const _0x23af7d=_0x4d0e02;let _0x141416=_0x4e0e0d=>_0x4e0e0d*config['playerScale'],_0x23d7f1={'a':_0x26a3ce-_0x3273a9,'b':_0x26a3ce+_0x3273a9,'c':_0x26a3ce-_0x141416(0x1),'d':_0x26a3ce+_0x141416(0x1),'e':_0x26a3ce-_0x141416(0x2),'f':_0x26a3ce+_0x141416(0x2),'g':_0x26a3ce-_0x141416(0x4),'h':_0x26a3ce+_0x141416(0x4)},_0x281894=function(_0x2079f1,_0x154a4f){const _0x56227c=_0x240d;player['y2']>=config[_0x56227c(0x1a4)]/0x2-config[_0x56227c(0x169)]/0x2&&player['y2']<=config['mapScale']/0x2+config[_0x56227c(0x169)]/0x2&&_0x154a4f==0x0?buyEquip(0x1f,0x0):buyEquip(_0x2079f1,_0x154a4f);};if(enemy['length']){let _0xf18444=near['dist2'];this[_0x23af7d(0x19d)]=!![];if(_0xf18444>=_0x23d7f1['a']&&_0xf18444<=_0x23d7f1['b'])return _0x281894(0x16,0x0),_0x281894(0xb,0x1),(player[_0x23af7d(0x1ac)]!=player[_0x23af7d(0x1a7)][[0xa,0xe]['includes'](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player['weapons'][0x1])?0x1:0x0]),{'dir':undefined,'action':0x1};else{if(_0xf18444<_0x23d7f1['a'])return _0xf18444>=_0x23d7f1['g']?_0xf18444>=_0x23d7f1['e']?_0xf18444>=_0x23d7f1['c']?(_0x281894(0x28,0x0),_0x281894(0xa,0x1),configs[_0x23af7d(0x179)]?player['buildIndex']!=player[_0x23af7d(0x18e)][0x1]&&selectToBuild(player[_0x23af7d(0x18e)][0x1]):(player[_0x23af7d(0x1ac)]!=player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player[_0x23af7d(0x1a7)][[0xa,0xe]['includes'](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0])):(_0x281894(0x16,0x0),_0x281894(0x0,0x1),(player['weaponIndex']!=player[_0x23af7d(0x1a7)][[0xa,0xe]['includes'](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0])):(_0x281894(0x6,0x0),_0x281894(0x0,0x1),(player[_0x23af7d(0x1ac)]!=player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player['weapons'][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0])):(biomeGear(),_0x281894(0xb,0x1),(player[_0x23af7d(0x1ac)]!=player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player['buildIndex']>-0x1)&&selectWeapon(player[_0x23af7d(0x1a7)][[0xa,0xe]['includes'](player['weapons'][0x1])?0x1:0x0])),{'dir':near[_0x23af7d(0x1a5)]+Math['PI'],'action':0x0};else{if(_0xf18444>_0x23d7f1['b'])return _0xf18444<=_0x23d7f1['h']?_0xf18444<=_0x23d7f1['f']?_0xf18444<=_0x23d7f1['d']?(_0x281894(0x28,0x0),_0x281894(0x0,0x1),configs[_0x23af7d(0x179)]?player['buildIndex']!=player[_0x23af7d(0x18e)][0x1]&&selectToBuild(player[_0x23af7d(0x18e)][0x1]):(player['weaponIndex']!=player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0])):(_0x281894(0x16,0x0),_0x281894(0x0,0x1),(player['weaponIndex']!=player[_0x23af7d(0x1a7)][[0xa,0xe]['includes'](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0])):(_0x281894(0x6,0x0),_0x281894(0x0,0x1),(player['weaponIndex']!=player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0])):(biomeGear(),_0x281894(0xb,0x1),(player[_0x23af7d(0x1ac)]!=player[_0x23af7d(0x1a7)][[0xa,0xe][_0x23af7d(0x16b)](player[_0x23af7d(0x1a7)][0x1])?0x1:0x0]||player[_0x23af7d(0x16a)]>-0x1)&&selectWeapon(player['weapons'][[0xa,0xe][_0x23af7d(0x16b)](player['weapons'][0x1])?0x1:0x0])),{'dir':near[_0x23af7d(0x1a5)],'action':0x0};}return{'dir':undefined,'action':0x0};}}else return this[_0x23af7d(0x19d)]=![],{'dir':undefined,'action':0x0};},(this[_0x4d0e02(0x17f)]=function(){const _0x2e6712=_0x4d0e02;let _0x3c54a3=this[_0x2e6712(0x171)](0x2ad,0x3);_0x3c54a3['action']?player[_0x2e6712(0x198)][0x35]==0x0&&!this['isTrue']?this['rangeType'](_0x2e6712(0x195)):packet('9',_0x3c54a3[_0x2e6712(0x189)],0x1):packet('9',_0x3c54a3[_0x2e6712(0x189)],0x1);},this[_0x4d0e02(0x177)]=function(){const _0x2e6022=_0x4d0e02;let _0x3c2dde=player[_0x2e6022(0x1a7)][0x1]==0x9?0xf5:0xf5,_0x5d233c=player[_0x2e6022(0x1a7)][0x1]==0x9?0x2:player[_0x2e6022(0x1a7)][0x1]==0xc?1.5:player[_0x2e6022(0x1a7)][0x1]==0xd?0x1:player[_0x2e6022(0x1a7)][0x1]==0xf?0x2:0x3,_0xa04682=this['gotoGoal'](0xf5,0x3);_0xa04682[_0x2e6022(0x172)]?player[_0x2e6022(0x198)][0x35]==0x0&&!this[_0x2e6022(0x191)]?this['OneTickType']():packet('9',_0xa04682[_0x2e6022(0x189)],0x1):packet('9',_0xa04682[_0x2e6022(0x189)],0x1);},this[_0x4d0e02(0x174)]=function(){const _0x125914=_0x4d0e02;let _0x23dbc3=player[_0x125914(0x1a7)][0x1]==0x9?0xf0:0xf0,_0xc4847c=player['weapons'][0x1]==0x9?0x2:player[_0x125914(0x1a7)][0x1]==0xc?1.5:player[_0x125914(0x1a7)][0x1]==0xd?0x1:player[_0x125914(0x1a7)][0x1]==0xf?0x2:0x3,_0x4dba05=this['gotoGoal'](0xee,0x3);_0x4dba05['action']?player['reloads'][0x35]==0x0&&!this[_0x125914(0x191)]?this['VelocityTickorBow']():packet('9',_0x4dba05['dir'],0x1):packet('9',_0x4dba05[_0x125914(0x189)],0x1);let _0x53dc47=![],_0x35b561=gameObjects[_0x125914(0x193)](_0x4b136e=>{const _0x6678ed=_0x125914;if(_0x4b136e[_0x6678ed(0x194)]&&_0x4b136e[_0x6678ed(0x18a)]&&_0x4b136e[_0x6678ed(0x18d)](player))return UTILS[_0x6678ed(0x19a)](_0x4b136e,near,0x0,0x2)<=near[_0x6678ed(0x163)]+_0x4b136e[_0x6678ed(0x1a9)]()+0xf;return![];});_0x35b561[_0x125914(0x170)]>0x0&&(_0x53dc47=!![]);if(!_0x53dc47&&getEl(_0x125914(0x174))[_0x125914(0x1a3)]&&player['reloads'][player[_0x125914(0x1a7)][0x0]]==0x0&&player['reloads'][0x35]==0x0&&player[_0x125914(0x1a7)][0x0]==0x5&&near[_0x125914(0x19c)]>0x0&&near[_0x125914(0x19c)]<=0xf5&&near[_0x125914(0x16f)]!=0x6){let _0x411f81={'x':_0x4dba05['dir']%0x2?0x1:-0x1,'y':0x0},_0x1ca102={'type':_0x125914(0x1ae),'x':_0x411f81['x'],'y':_0x411f81['y']},_0x16d86b={'type':_0x125914(0x1ae),'x':near['aim2']%0x2?0x1:-0x1,'y':0x0};game['sendPacket'](_0x1ca102),game[_0x125914(0x199)](()=>{const _0x5cb004=_0x125914;game[_0x5cb004(0x18f)](_0x16d86b);}),instaC[_0x125914(0x17d)]();}},this[_0x4d0e02(0x185)]=function(){const _0x41fedf=_0x4d0e02;let _0x249fcf=this['gotoGoal'](0xf0,0x3);_0x249fcf['action']?near[_0x41fedf(0x16f)]!=0x16&&player['reloads'][0x35]==0x0&&!this['isTrue']&&(game['tick']-near[_0x41fedf(0x19e)])%config['serverUpdateRate']==0x8?this[_0x41fedf(0x196)]():packet('9',_0x249fcf['dir'],0x1):packet('9',_0x249fcf['dir'],0x1);},this['BoostOneTick']=function(){const _0xcfc1a=_0x4d0e02;let _0x2187a6=player[_0xcfc1a(0x1a7)][0x1]==0x9?0x16d:player['weapons'][0x1]==0xc?0x17c:player[_0xcfc1a(0x1a7)][0x1]==0xd?0x16d:player[_0xcfc1a(0x1a7)][0x1]==0xf?0x16d:0x172,_0x3f9438=player[_0xcfc1a(0x1a7)][0x1]==0x9?0x2:player[_0xcfc1a(0x1a7)][0x1]==0xc?1.5:player[_0xcfc1a(0x1a7)][0x1]==0xd?0x1:player['weapons'][0x1]==0xf?0x2:0x3,_0x5c92e2=this[_0xcfc1a(0x171)](0x174,0x3);_0x5c92e2['action']?player[_0xcfc1a(0x198)][0x35]==0x0&&!this[_0xcfc1a(0x191)]?this[_0xcfc1a(0x1a1)]():packet('9',_0x5c92e2[_0xcfc1a(0x189)],0x1):packet('9',_0x5c92e2[_0xcfc1a(0x189)],0x1);}),this[_0x4d0e02(0x1a8)]=function(){const _0x2430c9=_0x4d0e02;let _0x222957=player[_0x2430c9(0x1a7)][0x1]==0x9?0x16d:player[_0x2430c9(0x1a7)][0x1]==0xc?0x17c:player[_0x2430c9(0x1a7)][0x1]==0xd?0x16d:player[_0x2430c9(0x1a7)][0x1]==0xf?0x16d:0x172,_0x41f691=player[_0x2430c9(0x1a7)][0x1]==0x9?0x2:player[_0x2430c9(0x1a7)][0x1]==0xc?1.5:player[_0x2430c9(0x1a7)][0x1]==0xd?0x1:player['weapons'][0x1]==0xf?0x2:0x3,_0x52e7a2=this[_0x2430c9(0x171)](0x174,0x3);_0x52e7a2[_0x2430c9(0x172)]?player[_0x2430c9(0x198)][0x35]==0x0&&!this[_0x2430c9(0x191)]?this[_0x2430c9(0x17c)]():packet('9',_0x52e7a2[_0x2430c9(0x189)],0x1):packet('9',_0x52e7a2[_0x2430c9(0x189)],0x1);},this[_0x4d0e02(0x164)]=function(){const _0x4e2151=_0x4d0e02;let _0x1105ab=player['weapons'][0x1]==0x9?0x16d:player[_0x4e2151(0x1a7)][0x1]==0xc?0x17c:player[_0x4e2151(0x1a7)][0x1]==0xd?0x16d:player[_0x4e2151(0x1a7)][0x1]==0xf?0x16d:0x172,_0x335ca9=player[_0x4e2151(0x1a7)][0x1]==0x9?0x2:player[_0x4e2151(0x1a7)][0x1]==0xc?1.5:player[_0x4e2151(0x1a7)][0x1]==0xd?0x1:player[_0x4e2151(0x1a7)][0x1]==0xf?0x2:0x3,_0x3cd117=this[_0x4e2151(0x171)](0x174,0x3);_0x3cd117[_0x4e2151(0x172)]?player['reloads'][0x35]==0x0&&!this[_0x4e2151(0x191)]?this[_0x4e2151(0x197)]():packet('9',_0x3cd117[_0x4e2151(0x189)],0x1):packet('9',_0x3cd117[_0x4e2151(0x189)],0x1);},this[_0x4d0e02(0x178)]=function(_0x35c22e,_0x20db58){const _0x133688=_0x4d0e02;if(_0x20db58['weaponIndex']==0xb&&UTILS[_0x133688(0x17b)](_0x20db58[_0x133688(0x1a5)]+Math['PI'],_0x20db58['d2'])<=config[_0x133688(0x182)])return![];if(![0x9,0xc,0xd,0xf][_0x133688(0x16b)](player[_0x133688(0x1a7)][0x1]))return!![];let _0x53857a={'x':_0x20db58['x2']+0x46*Math[_0x133688(0x165)](_0x20db58['aim2']+Math['PI']),'y':_0x20db58['y2']+0x46*Math[_0x133688(0x176)](_0x20db58[_0x133688(0x1a5)]+Math['PI'])};if(UTILS[_0x133688(0x167)](_0x35c22e['x2']-_0x35c22e[_0x133688(0x163)],_0x35c22e['y2']-_0x35c22e[_0x133688(0x163)],_0x35c22e['x2']+_0x35c22e[_0x133688(0x163)],_0x35c22e['y2']+_0x35c22e['scale'],_0x53857a['x'],_0x53857a['y'],_0x53857a['x'],_0x53857a['y']))return!![];let _0x5402d4=ais[_0x133688(0x193)](_0x541763=>_0x541763[_0x133688(0x18c)])[_0x133688(0x180)](_0xa19d6a=>{const _0x244645=_0x133688;if(UTILS['lineInRect'](_0xa19d6a['x2']-_0xa19d6a['scale'],_0xa19d6a['y2']-_0xa19d6a[_0x244645(0x163)],_0xa19d6a['x2']+_0xa19d6a[_0x244645(0x163)],_0xa19d6a['y2']+_0xa19d6a[_0x244645(0x163)],_0x53857a['x'],_0x53857a['y'],_0x53857a['x'],_0x53857a['y']))return!![];});if(_0x5402d4)return![];_0x5402d4=liztobj['filter'](_0x13992c=>_0x13992c[_0x133688(0x18a)])[_0x133688(0x180)](_0xd26e15=>{const _0x31aaa9=_0x133688;let _0x1e6eb2=_0xd26e15[_0x31aaa9(0x1a9)]();if(!_0xd26e15[_0x31aaa9(0x168)]&&UTILS[_0x31aaa9(0x167)](_0xd26e15['x']-_0x1e6eb2,_0xd26e15['y']-_0x1e6eb2,_0xd26e15['x']+_0x1e6eb2,_0xd26e15['y']+_0x1e6eb2,_0x53857a['x'],_0x53857a['y'],_0x53857a['x'],_0x53857a['y']))return!![];});if(_0x5402d4)return![];return!![];});function _0x4bec(){const _0x5b3ebf=['threeOneTickType','skinIndex','length','gotoGoal','action','2645235aAGXDi','VelocityOneTick','changeType','sin','tickMovement','perfCheck','slowOT','3771200VDsjWO','getAngleDist','PerfectedBoostSpiketick','VelocityTickorBow','autoAim','bowMovement','find','92200ysbjvM','shieldAngle','6xEXikx','SpikeTick','kmTickMovement','spikeTickType','counterType','364222PrWmNv','dir','active','4vQakkL','visible','isTeamObject','items','sendPacket','push','isTrue','revAim','filter','trap','ageInsta','kmTickType','boostTickType','reloads','tickBase','getDist','657209GGTsjO','dist2','ticking','poisonTick','rev','AutoSync','BoostOneTICKERS','send','checked','mapScale','aim2','doSpikeOnReverse','weapons','BoostPerfectedSpiketick','getScale','54eaYmeu','211700LVHLWt','weaponIndex','syncTry','move','scale','boostTickMovement','cos','normal','lineInRect','ignoreCollision','riverWidth','buildIndex','includes','backupNobull','5652176DDMJep'];_0x4bec=function(){return _0x5b3ebf;};return _0x4bec();}
    }
};

class Autobuy {
    constructor(buyHat, buyAcc) {
        this.hat = function() {
            buyHat.forEach((id) => {
                let find = findID(hats, id);
                if (find && !player.skins[id] && player.points >= find.price) packet("c", 1, id, 0);
            });
        };
        this.acc = function() {
            buyAcc.forEach((id) => {
                let find = findID(accessories, id);
                if (find && !player.tails[id] && player.points >= find.price) packet("c", 1, id, 1);
            });
        };
    }
};

class Autoupgrade {
    constructor() {
        this.sb = function(upg) {
            upg(3);
            upg(17);
            upg(31);
            upg(23);
            upg(9);
            upg(38);
        };
        this.kh = function(upg) {
            upg(3);
            upg(17);
            upg(31);
            upg(23);
            upg(10);
            upg(38);
            upg(4);
            upg(25);
        };
        this.pb = function(upg) {
            upg(5);
            upg(17);
            upg(32);
            upg(23);
            upg(9);
            upg(38);
        };
        this.ph = function(upg) {
            upg(5);
            upg(17);
            upg(32);
            upg(23);
            upg(10);
            upg(38);
            upg(28);
            upg(25);
        };
        this.db = function(upg) {
            upg(7);
            upg(17);
            upg(31);
            upg(23);
            upg(9);
            upg(34);
        };
        /* old functions */
        this.km = function(upg) {
            upg(7);
            upg(17);
            upg(31);
            upg(23);
            upg(10);
            upg(38);
            upg(4);
            upg(15);
        };
    };
};

class Damages {
    constructor(items) {
        // 0.75 1 1.125 1.5
        this.calcDmg = function(dmg, val) {
            return dmg * val;
        };
        this.getAllDamage = function(dmg) {
            return [this.calcDmg(dmg, 0.75), dmg, this.calcDmg(dmg, 1.125), this.calcDmg(dmg, 1.5)];
        };
        this.weapons = [];
        for (let i = 0; i < items.weapons.length; i++) {
            let wp = items.weapons[i];
            let name = wp.name.split(" ").length <= 1 ? wp.name : (wp.name.split(" ")[0] + "_" + wp.name.split(" ")[1]);
            this.weapons.push(this.getAllDamage(i > 8 ? wp.Pdmg : wp.dmg));
            this[name] = this.weapons[i];
        }
    }
}

/** CLASS CODES */
// jumpscare code warn
let tmpList = [];

// LOADING:
let UTILS = new Utils();
let items = new Items();
let objectManager = new Objectmanager(GameObject, gameObjects, UTILS, config);
let store = new Store();
let hats = store.hats;
let accessories = store.accessories;
let projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, UTILS);
let aiManager = new AiManager(ais, AI, players, items, null, config, UTILS);
let textManager = new Textmanager();
let sCombat = new Combat(UTILS, items);
let traps = new Traps(UTILS, items);
let instaC = new Instakill();
let autoBuy = new Autobuy([40, 6, 7, 22, 53, 15, 31], [11, 21, 18, 13]);
let autoUpgrade = new Autoupgrade();

let lastDeath;
let minimapData;
let mapMarker = {};
let mapPings = [];
let tmpPing;

let breakTrackers = [];

function sendChat(message) {
    packet("6", message.slice(0, 30));
}

let runAtNextTick = [];
function turretAnti(tmpObj) {
    if (tmpObj.dist2 <= 300 && player.alive) {
        if (enemy.includes(tmpObj)) {
            if(near.enemy.primaryIndex == 5 && config.weaponVariants[tmpObj.primaryVariant].id >= 2) {
                buyEquip(6, 0);
                my.anti0Tick = true;
                ShowSettingTextBlack(300, "Anti One Frame");
            }
        }
    }
}
function checkProjectileHolder(x, y, dir, range, speed, indx, layer, sid) {
    let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
    let projOffset = config.playerScale * 2;
    let projXY = {
        x: indx == 1 ? x : x - projOffset * Math.cos(dir),
        y: indx == 1 ? y : y - projOffset * Math.sin(dir),
    };
    let nearPlayer = players.filter((e) => player.visible && UTILS.getDist(projXY, e, 0, 2) <= player.scale).sort(function (a, b) {
        return UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2);
    })[0];
    if (nearPlayer) {
        if (indx == 1) {
            nearPlayer.shooting[53] = 1;
            turretAnti(nearPlayer);
        } else {
            nearPlayer.shootIndex = weaponIndx;
            nearPlayer.shooting[1] = 1;
            antiProj(nearPlayer, dir, range, speed, indx, weaponIndx);
        }
    }
}
let projectileCount = 0;
function notif(title, description) {
    let mouseCoord = player;
    let m = textManager;
    if (typeof title !== "undefined") {
        m.showText(mouseCoord.x, mouseCoord.y, 40, .18, 500, title, "white");
    }
    if (typeof description !== "undefined") {
        m.showText(mouseCoord.x, mouseCoord.y + 40, 30, .18, 500, description, "white");
    }
}
function antiProj(tmpObj, dir, range, speed, index, weaponIndex, indx, y, x) {
    let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
    let projOffset = config.playerScale * 2;
    let projXY = {
        x: indx == 1 ? x : x - projOffset * Math.cos(dir),
        y: indx == 1 ? y : y - projOffset * Math.sin(dir),
    };
    let fixXY = function(tmpObj) {
        return {
            x2: UTILS.fixTo(tmpObj.x2, 2),
            y2: UTILS.fixTo(tmpObj.y2, 2),
        };
    };
    let nearPlayer = players.filter((e)=>e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale).sort(function(a, b) {
        return (UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2));
    })[0];
    if (!tmpObj.isTeam(player)) {
        tmpDir = UTILS.getDirect(player, tmpObj, 2, 2);
        if (UTILS.getAngleDist(tmpDir, dir) <= 0.2) {
            tmpObj.bowThreat[weaponIndex]++;
            if (index == 5) {
                projectileCount++;
            }
            if (enemy) {
                let enemyIndex = enemy.index;
                if (index == 1 || index == 2 || index == 3 || index == 5 || index == 13 || index == 14 || index == 15) {
                    player.shooting[53] = 1;
                    setTimeout(() => {
                        player.shooting[53] = 0;
                    }, range / speed);
                }

                player.bowThreat[index]++;
                setTimeout(() => {
                    player.bowThreat[index]--;
                }, range / speed);
            }
            if (tmpObj.bowThreat[9] >= 1 && (tmpObj.bowThreat[12] >= 1 || tmpObj.bowThreat[15] >= 1)) {
                place(3, tmpObj.aim2);
                buyEquip(22, 0);
                game.tickBase(() => {
                    buyEquip(6, 0);
                }, 1);
                my.anti0Tick = 4;
                if (!my.antiSync) {
                    notif("Bow Insta Blocked");
                    antiSyncHealing(4);
                }
            }
        } else {
            if (near.dist2 < 550) {
                if (projectileCount >= 2) {
                    place(3, tmpObj.aim2);
                    healer();
                    buyEquip(22, 0);
                    buyEquip(21, 1);
                    my.anti0Tick = 4;
                    if (!my.antiSync) {
                        notif("Blocked Sync Succes");
                        antiSyncHealing(4);
                    }
                } else {
                    if (projectileCount === 1 && near.reloads[near.weapons[0]] == 0 && near.dist2 < items.weapons[near.weapons[0]].range + player.scale * 1.8) {
                        buyEquip(6, 0);
                        buyEquip(21, 1);
                    }
                }
            }
        }
    }
}

// SHOW ITEM INFO:
function showItemInfo(item, isWeapon, isStoreItem) {
    if (player && item) {
        UTILS.removeAllChildren(itemInfoHolder);
        itemInfoHolder.classList.add("visible");
        UTILS.generateElement({
            id: "itemInfoName",
            text: UTILS.capitalizeFirst(item.name),
            parent: itemInfoHolder
        });
        UTILS.generateElement({
            id: "itemInfoDesc",
            text: item.desc,
            parent: itemInfoHolder
        });
        if (isStoreItem) {

        } else if (isWeapon) {
            UTILS.generateElement({
                class: "itemInfoReq",
                text: !item.type ? "primary" : "secondary",
                parent: itemInfoHolder
            });
        } else {
            for (let i = 0; i < item.req.length; i += 2) {
                UTILS.generateElement({
                    class: "itemInfoReq",
                    html: item.req[i] + "<span class='itemInfoReqVal'> x" + item.req[i + 1] + "</span>",
                    parent: itemInfoHolder
                });
            }
            if (item.group.limit) {
                UTILS.generateElement({
                    class: "itemInfoLmt",
                    text: (player.itemCounts[item.group.id] || 0) + "/" + (config.isSandbox ? 99 : item.group.limit),
                    parent: itemInfoHolder
                });
            }
        }
    } else {
        itemInfoHolder.classList.remove("visible");
    }
}

// RESIZE:
window.addEventListener("resize", UTILS.checkTrusted(resize));

function resize() {
    screenWidth = window.innerWidth;
    screenHeight = window.innerHeight;
    let scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
    gameCanvas.width = screenWidth * pixelDensity;
    gameCanvas.height = screenHeight * pixelDensity;
    gameCanvas.style.width = screenWidth + "px";
    gameCanvas.style.height = screenHeight + "px";
    mainContext.setTransform(
        scaleFillNative, 0,
        0, scaleFillNative,
        (screenWidth * pixelDensity - (maxScreenWidth * scaleFillNative)) / 2,
        (screenHeight * pixelDensity - (maxScreenHeight * scaleFillNative)) / 2
    );
}
resize();

// MOUSE INPUT:
var usingTouch;
const mals = document.getElementById('touch-controls-fullscreen');
mals.style.display = 'block';
mals.addEventListener("mousemove", gameInput, false);

function gameInput(e) {
    mouseX = e.clientX;
    mouseY = e.clientY;
}
let clicks = {
    left: false,
    middle: false,
    right: false,
};
mals.addEventListener("mousedown", mouseDown, false);

function mouseDown(e) {
    if (attackState != 1) {
        attackState = 1;
        if (e.button == 0) {
            clicks.left = true;
        } else if (e.button == 1 || e.key === 'b') {
            clicks.middle = true;
        } else if (e.button == 2) {
            clicks.right = true;
        }
    }
}
mals.addEventListener("mouseup", UTILS.checkTrusted(mouseUp));

function mouseUp(e) {
    if (attackState != 0) {
        attackState = 0;
        if (e.button == 0) {
            clicks.left = false;
        } else if (e.button == 1 || e.key === 'b') {
            clicks.middle = false;
        } else if (e.button == 2) {
            clicks.right = false;
        }
    }
}
mals.addEventListener("wheel", wheel, false);

let wbe = 1;
function wheel(e) {
    if (e.deltaY < 0) {
        wbe -= 0.05;
        maxScreenWidth = config.maxScreenWidth * wbe;
        maxScreenHeight = config.maxScreenHeight * wbe;
        resize()
    } else {
        wbe += 0.05;
        maxScreenWidth = config.maxScreenWidth * wbe;
        maxScreenHeight = config.maxScreenHeight * wbe;
        resize()
    }
}


// INPUT UTILS:
function getMoveDir() {
    let dx = 0;
    let dy = 0;
    for (let key in moveKeys) {
        let tmpDir = moveKeys[key];
        dx += !!keys[key] * tmpDir[0];
        dy += !!keys[key] * tmpDir[1];
    }
    return dx == 0 && dy == 0 ? undefined : Math.atan2(dy, dx);
}

function getSafeDir() {
    if (!player)
        return 0;
    if (!player.lockDir) {
        lastDir = Math.atan2(mouseY - (screenHeight / 2), mouseX - (screenWidth / 2));
    }
    return lastDir || 0;
}
let checkDist = 75;
function SpikeDir() {
    let spike;
    if (near.dist2 > 230 && getEl("AutoBot").checked && !my.autoPush && enemy.length) {
        if (traps.inTrap) {
            spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (items.weapons[player.weapons[0]].range + player.scale * 1.5)).sort(function(a, b) {
                return UTILS.getDist(a, player, 0, 5) - UTILS.getDist(b, player, 0, 5);
            })[0];
        } else {
            spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + checkDist + player.scale)).sort(function(a, b) {
                return UTILS.getDist(a, player, 0, 5) - UTILS.getDist(b, player, 0, 5);
            })[0];
        }
    } else {
        if (traps.inTrap) {
            spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (items.weapons[player.weapons[0]].range + player.scale * 1.5)).sort(function(a, b) {
                return UTILS.getDist(a, player, 0, 5) - UTILS.getDist(b, player, 0, 5);
            })[0];
        } else {
            spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + checkDist + player.scale)).sort(function(a, b) {
                return UTILS.getDist(a, player, 0, 5) - UTILS.getDist(b, player, 0, 5);
            })[0];
        }
    }

    if (spike) {
        let aim = UTILS.getDirect(spike, player, 0, 2);
        return aim;
    } else {
        return lastDir || 0;
    }
}
let plusDir = 0;
let lastSpin = Date.now();
let spinner = false;
let spinDir = 0;
function getAttackDir(debug) {
    if (debug) {
        if (!player)
            return "0";
        if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
            lastDir = getEl("weaponGrind").checked ? "getSafeDir()" : enemy.length ? my.revAim ? "(near.aim2 + Math.PI)" : "near.aim2" : "getSafeDir()";
        else
            if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                lastDir = "getSafeDir()";
        else
            if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0) {
                lastDir = "traps.aim";
            }
        return lastDir;
    } else {
        if (!player)
            return 0;
        if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
            lastDir = getEl("weaponGrind").checked ? getSafeDir() : enemy.length ? my.revAim ? (near.aim2 + Math.PI) : near.aim2 : getSafeDir();
        else
            if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                lastDir = getSafeDir();
        else
            if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0) {
                lastDir = traps.aim;
            }
        return lastDir || 0;
    }
}

function getVisualDir() {
    if (!player)
        return 0;
    lastDir = getSafeDir();
    return lastDir || 0;
}
// KEYS:
function keysActive() {
    return (allianceMenu.style.display != "block" &&
            chatHolder.style.display != "block" &&
            !menuCBFocus);
}
let changeCounts = 0;
let opacity = 0;
let toggle;
function toggleMenu() {
    if (toggle) clearInterval(toggle);
    opacity = 1 - Math.round(opacity);
    if (opacity) $("#UnoReverse").toggle();
    toggle = setInterval(()=>{
        if (opacity != Number(UnoReverse.style.opacity, 0.1)) {
            UnoReverse.style.opacity = (Number(UnoReverse.style.opacity, 0.1)) + (opacity ? 0.1 : -0.1);
        } else {
            clearInterval(toggle);
            if (!((Number(UnoReverse.style.opacity, 0.1)))) $("#UnoReverse").toggle();
        }
    }, 1);
}
function toggleMenuChat() {
    if (menuChatDiv.style.display != "none") {
        //   chatHolder.style.display = "none";
        // if (menuChatBox.value != "") {
        //commands[command.slice(1)]
        let cmd = function(command) {
            return {
                found: command.startsWith("/") && commands[command.slice(1).split(" ")[0]],
                fv: commands[command.slice(1).split(" ")[0]]
            }
        }
        let command = cmd(menuChatBox.value);
        if (command.found) {
            if (typeof command.fv.action === "function") {
                command.fv.action(menuChatBox.value);
            }
        } else {
            sendChat(menuChatBox.value);
        }
        menuChatBox.value = "";
        menuChatBox.blur();
    } else {
        if (menuCBFocus) {
            menuChatBox.blur();
        } else {
            menuChatBox.focus();
        }
    }
}
let autos = {
    insta: {
        todo: false,
        wait: false,
        count: 4,
        shame: 5,
        toggle: false
    },
    instaing: false,
    bull: false,
    antibull: 0,
    reloaded: false,
    stopspin: true
}
function toRad(angle) {
    return angle * 0.01745329251;
}
let boostSpikings = false;
function placeQuad() {
    place(4, near.aim2);
    place(4, near.aim2 + toRad(45));
    place(4, near.aim2 - toRad(90));
    place(4, near.aim2 + Math.PI);
}
let follow = (ang) => {
    packet("9", ang)
}
setInterval(()=>{
    if (getEl("BoostSpikers").checked) {
        if (boostSpikings) {
            place(near.dist2 > 220 ? 4 : 2, near.aim2);
            place(2, near.aim2);
            place(2, near.aim2 + toRad(90));
            place(2, near.aim2 - toRad(90));
            packet("9", near.aim2);
        }
    }
}, 80);
// let myplayer = {
//     x:null,
//     y:null,
//     id:null,
//     weapon:0,
//     fs:0,
//     ms:10,
//     ss:6,
//     ts:15,
//     sec:0,
//     go:null,
//     tur:0,
//     name:null,
//     timepol:885
// };
// let nerpl = ()=>{
//     let dist = 10000;
//     let ind = 0;
//     for (let i = 0;i<players.length;i++) {
//         let ds = Math.sqrt(Math.pow(players[i].x-myplayer.x, 2)+Math.pow(players[i].y-myplayer.y, 2));
//         if (ds<dist){
//             ind = i;
//             dist=ds;
//         };
//     }
//     return [dist, players[ind]];
// }
// let all = [];
// let getplayer=(id)=>{
//     for (let i = 0;i<players.length;i++) {
//         if (players[i].id===id)return i;
//     }
//     return false;
// }
// let getplayerall=(id)=>{
//     for (let i = 0;i<all.length;i++) {
//         if (all[i].id===id)return i;
//     }
//     return false;
// }
// let angle = 0;
// let trap = (ang)=> {
//     packet("z", myplayer.ts, null);
//     place(ang);
//     packet("z", myplayer.d, true);
// }
// let spk = (ang) => {
//     packet("z", myplayer.ss, null);
//     place(ang);
//     packet("z", myplayer.d, true);
// }
// let boostspikee=false;
// let boostspike=false;
// function boostspikereal() {
//     setInterval(()=>{
//         if (boostspike){
//             if(getEl("evee").checked) {
//                 let nerplayer = nerpl();
//                 let dist = Math.sqrt(Math.pow(nerplayer[1].y-myplayer.y, 2)+Math.pow(nerplayer[1].x-myplayer.x, 2));
//                 let ang = players.length===0?angle:Math.atan2(nerplayer[1].y-myplayer.y, nerplayer[1].x-myplayer.x);
//                 follow(ang);
//                 if (dist>200) {
//                     trap(ang);
//                 }
//                 if(dist<100) {
//                     spk(ang-Math.PI/2);
//                     spk(ang+Math.PI/2);
//                 }
//                 if(dist<90) {
//                     spk(ang);
//                 }
//                 if(dist<220) {
//                     spk(ang-Math.PI/2);
//                     spk(ang+Math.PI/2);
//                     spk(ang+Math.PI);
//                 }
//             }
//         }
//     }, 80);
//     setInterval(()=>{
//         if (boostspikee){
//             if(getEl("2018").checked) {
//                 let nerplayer = nerpl();
//                 let dist = Math.sqrt(Math.pow(nerplayer[1].y-myplayer.y, 2)+Math.pow(nerplayer[1].x-myplayer.x, 2));
//                 let ang = players.length===0?angle:Math.atan2(nerplayer[1].y-myplayer.y, nerplayer[1].x-myplayer.x);
//                 follow(ang);
//                 trap(ang);
//                 spk(ang-Math.PI/2);
//                 spk(ang+Math.PI/2);
//             }
//         }
//     }, 80);
// }
var repeater = function(key, action, interval) {
    let _isKeyDown = false;
    let _intervalId = undefined;

    return {
        start(keycode) {
            if(keycode == key && document.activeElement.id.toLowerCase() !== 'chatbox') {
                _isKeyDown = true;
                if(_intervalId === undefined) {
                    _intervalId = setInterval(() => {
                        action();
                        if(!_isKeyDown){
                            clearInterval(_intervalId);
                            _intervalId = undefined;
                            console.log("claered");
                        }
                    }, interval);
                }
            }
        },
        stop(keycode) {
            if(keycode == key && document.activeElement.id.toLowerCase() !== 'chatbox') {
                _isKeyDown = false;
            }
        }
    };
}
function keyDown(event) {
    let keyNum = event.which || event.keyCode || 0;
    if (player && player.alive && keysActive()) {
        if (!keys[keyNum]) {
            keys[keyNum] = 1;
            macro[event.key] = 1;
            if (keyNum == 27) {
                toggleMenu();
            } else if (keyNum == 17) {
                openMenu = !openMenu;
                $("#menuChatDiv").toggle();
            } else if (keyNum == 69) {
                sendAutoGather();
            } else if (keyNum == 67) {
                updateMapMarker();
            } else if (event.key === "n") {
                boostSpikings=true;
            } else if (event.key == "T") {
                autoOneFrameToggled = !autoOneFrameToggled;
                const oneFrameStatus = autoOneFrameToggled ? "On" : "Off";
                textManager.showText(player.x2, player.y2, 20, 0, 2000, `VelocityTick: ${oneFrameStatus}`);
                // } else if (event.key == "n") {
                //     if(getEl("2018").checked) {
                //         boostspikee=true;
                //         if(getEl("evee").checked) {
                //             boostspike=true;
                //             if(getEl("2018").checked) {
                //                 boostspikee=false;
                //                 if(getEl("evee").checked) {
                //                     boostspike=false;
                //                 }
                //             }
                //         }
                //     }
            } else if (event.key == "L") {
                odfmsjfhvadsfyjkauhsfsa = !odfmsjfhvadsfyjkauhsfsa;
            } else if (event.key == "j") {
                placeQuad();
            } else if (player.weapons[keyNum - 49] != undefined) {
                player.weaponCode = player.weapons[keyNum - 49];
            } else if (moveKeys[keyNum]) {
                sendMoveDir();
            } else if (event.key == "b") {
                place(2, near.aim2 + toRad(45));
                place(2, near.aim2 - toRad(45));
                selectWeapon(player.weapons[0]);
                buyEquip(7, 0);
                sendAutoGather();
                game.tickBase(() => {
                    selectWeapon(player.weapons[0]);
                    buyEquip(53, 0);
                    game.tickBase(() => {
                        sendAutoGather();
                        my.autoAim = false;
                    }, 1);
                }, 1);
            } else if (event.key == "x") {
                place(2, near.aim2);
                selectWeapon(player.weapons[0]);
                buyEquip(7, 0);
                sendAutoGather();
                game.tickBase(() => {
                    selectWeapon(player.weapons[0]);
                    buyEquip(53, 0);
                    game.tickBase(() => {
                        sendAutoGather();
                        my.autoAim = false;
                    }, 1);
                }, 1);
            } else if (event.key == "/") {
                mills.placeSpawnPads = !mills.placeSpawnPads;
            } else if (event.key == 'b') {
                clicks.middle = true;
            } else if (event.key == "z") {
                mills.place = !mills.place;
            } else if (event.key == "Z") {
                typeof window.debug == "function" && window.debug();
            } else if (event.key == "p") {
                playSong();
            } else if (keyNum == 32) {
                packet("F", 1, getSafeDir(), 1);
                packet("F", 0, getSafeDir(), 1);
                // project.send("tezt");
                // botSkts.forEach((bot) => {
                //     bot.zync();
                // })
                // io.send("S", 1)
            }
        }
    }
}
let Playing = false;
let currentPart = 0;
function playSong() {
    Playing = !Playing;
    if (Playing) {
        let Song = Songs[Number(getEl("song").value)];
        Song.play();
        Song.onended = function() {
            if (Playing) {
                Songs[Number(getEl("song").value)].play();
            }
        };
        Song.ontimeupdate = function(t) {
            let part = songC[Number(getEl("song").value)][getTime(Math.round(this.currentTime))];
            if (part && part !== currentPart) {
                currentPart = part;
            }
        };
    } else {
        Songs[0].pause();
    }
}

function getTime(t) {
    let sec = Math.floor(t) % 60;
    let min = Math.floor(Math.floor(t) % 3600 / 60);
    sec < 10 && (sec = `0${sec}`)
    return min + ":" + sec;
}
let lastType, Sync = false;
let lastDamage = 0;
let oldEnemy;
let Shadow = 0.35;
setInterval(()=>{
    if (advHeal.length) {
        advHeal.forEach((updHealth) => {
            let sid = updHealth[0];
            let value = updHealth[1];
            let damaged = updHealth[2];
            tmpObj = findPlayerBySID(sid);
            if (tmpObj) {
                if (tmpObj == oldEnemy && (tmpObj.oldHealth <= damaged || damaged == items.list[player.items[2]].dmg*(tmpObj.skinIndex==6?3/4:1))) { // CHECK SYNC
                    if (lastDamage == damaged) {
                        Sync = true;
                        game.tickBase(() => {
                            Sync = false;
                        }, 5);
                    } else if (tmpObj.oldHealth != damaged) lastDamage = damaged;
                };
            }
        });
        advHeal = [];
    }
}, 30);
// let xx = canvaz.width/2;
// let yy = canvaz.height/2;

// let mouze = {
//     x: xx - mouzeX,
//     y: yy - mouzeY
// }

// let ingamecoorformodabow = {
//     x: player.x + mouze.x,
//     y: player.x + mouze.x
// }

addEventListener("keydown", UTILS.checkTrusted(keyDown));

function keyUp(event) {
    if (player && player.alive) {
        let keyNum = event.which || event.keyCode || 0;
        if (keyNum == 13) {
            toggleMenuChat();
        } else if (keysActive()) {
            if (keys[keyNum]) {
                keys[keyNum] = 0;
                macro[event.key] = 0;
                if (moveKeys[keyNum]) {
                    sendMoveDir();
                } else if (event.key == "n") {
                    boostSpikings=false;
                } else if (event.key == ",") {
                    player.sync = false;
                } else if (event.key == 'b') {
                    clicks.middle = false;
                }
            }
        }
    }
}


window.addEventListener("keyup", UTILS.checkTrusted(keyUp));

function sendMoveDir() {
    if(found) {
        packet("9", undefined, 1);
    } else {
        let newMoveDir = getMoveDir();
        if (lastMoveDir == undefined || newMoveDir == undefined || Math.abs(newMoveDir - lastMoveDir) > 0.3) {
            if (!my.autoPush && !found) {
                packet("9", newMoveDir, 1);
            }
            lastMoveDir = newMoveDir;
        }
    }
}

// BUTTON EVENTS:
function bindEvents() {}
bindEvents();

// ITEM COUNT DISPLAY:
let isItemSetted = [];

function updateItemCountDisplay(index = undefined) {
    for (let i = 3; i < items.list.length; ++i) {
        let id = items.list[i].group.id;
        let tmpI = items.weapons.length + i;
        if (!isItemSetted[tmpI]) {
            isItemSetted[tmpI] = document.createElement("div");
            isItemSetted[tmpI].id = "itemCount" + tmpI;
            getEl("actionBarItem" + tmpI).appendChild(isItemSetted[tmpI]);
            isItemSetted[tmpI].style = `
                        display: block;
                        position: absolute;
                        padding-left: 5px;
                        font-size: 2em;
                        color: #fff;
                        `;
            isItemSetted[tmpI].innerHTML = player.itemCounts[id] || 0;
        } else {
            if (index == id) isItemSetted[tmpI].innerHTML = player.itemCounts[index] || 0;
        }
    }
}

// AUTOPUSH:
function autoPush() {
    let nearTrap = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= (near.scale + tmp.getScale() + 5)).sort(function(a, b) {
        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
    })[0];
    if (nearTrap && near && near.dist2 <= 260) {
        let spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, nearTrap, 0, 0) <= (near.scale + nearTrap.scale + tmp.scale)).sort(function(a, b) {
            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
        })[0];
        if (spike) {
            if(near.dist2 <= 180 && near.health <= 66 && tmpObj.reloads[tmpObj.primaryIndex] == 0){
                instaC.spikeTickType();
            }
            let pos = {
                x: spike.x + (250 * Math.cos(UTILS.getDirect(near, spike, 2, 0))),
                y: spike.y + (250 * Math.sin(UTILS.getDirect(near, spike, 2, 0))),
                x2: spike.x + ((UTILS.getDist(near, spike, 2, 0) + player.scale) * Math.cos(UTILS.getDirect(near, spike, 2, 0))),
                y2: spike.y + ((UTILS.getDist(near, spike, 2, 0) + player.scale) * Math.sin(UTILS.getDirect(near, spike, 2, 0)))
            };
            let finds = gameObjects.filter(tmp => tmp.active).find((tmp) => {
                let tmpScale = tmp.getScale();
                if (!tmp.ignoreCollision && UTILS.lineInRect(tmp.x - tmpScale, tmp.y - tmpScale, tmp.x + tmpScale, tmp.y + tmpScale, player.x2, player.y2, pos.x2, pos.y2)) {
                    return true;
                }
            });
            if (finds) {
                if (my.autoPush) {
                    my.autoPush = false;
                    packet("9", lastMoveDir || undefined, 1);
                }
            } else {
                my.autoPush = true;
                my.pushData = {
                    x: spike.x + Math.cos(70),
                    y: spike.y + Math.sin(70),
                    x2: pos.x2 + Math.cos(30),
                    y2: pos.y2 + Math.sin(30)
                };
                let scale = player.scale / 10;
                let secondArg = UTILS.getDirect(near, spike, 2, 0) > 70 ? near.aim2 : undefined;
                if (UTILS.lineInRect(player.x2 - scale, player.y2 - scale, player.x2 + scale, player.y2 + scale, near.x2, near.y2, pos.x, pos.y)) {
                    packet("9", secondArg, 1);
                    textManager.showText(player.x2, player.y2, 30, 0.15, 1850, "Reversed Push", "#00FF00", 2);
                } else {
                    packet("9", UTILS.getDirect(pos, player, 2, 2), 1);
                }
            }
        } else {
            if (my.autoPush) {
                my.autoPush = false;
                packet("9", lastMoveDir || undefined, 1);
            }
        }
    } else {
        if (my.autoPush) {
            my.autoPush = false;
            packet("9", lastMoveDir || undefined, 1);
        }
    }
}

// ADD DEAD PLAYER:
function addDeadPlayer(tmpObj) {
    deadPlayers.push(new DeadPlayer(tmpObj.x, tmpObj.y, tmpObj.dir, tmpObj.buildIndex, tmpObj.weaponIndex, tmpObj.weaponVariant, tmpObj.skinColor, tmpObj.scale, tmpObj.name));
}

/** APPLY SOCKET CODES */

// SET INIT DATA:
function setInitData(data) {
    alliances = data.teams;
}

// SETUP GAME:
function setupGame(yourSID) {
    keys = {};
    macro = {};
    playerSID = yourSID;
    attackState = 0;
    inGame = true;
    packet("F", 0, getAttackDir(), 1);
    my.ageInsta = true;
    if (firstSetup) {
        firstSetup = false;
        gameObjects.length = 0;
        liztobj.length = 0;
    }
}

// ADD NEW PLAYER:
function addPlayer(data, isYou) {
    let tmpPlayer = findPlayerByID(data[0]);
    if (!tmpPlayer) {
        tmpPlayer = new Player(data[0], data[1], config, UTILS, projectileManager,
                               objectManager, players, ais, items, hats, accessories);
        players.push(tmpPlayer);
        if (data[1] != playerSID) {
            addMenuChText(null, `Found ${data[2]} {${data[1]}}`, "lime");
        }
    } else {
        if (data[1] != playerSID) {
            addMenuChText(null, `Found ${data[2]} {${data[1]}}`, "lime");
        }
    }
    tmpPlayer.spawn(isYou ? true : null);
    tmpPlayer.visible = false;
    tmpPlayer.oldPos = {
        x2: undefined,
        y2: undefined
    };
    tmpPlayer.x2 = undefined;
    tmpPlayer.y2 = undefined;
    tmpPlayer.x3 = undefined;
    tmpPlayer.y3 = undefined;
    tmpPlayer.setData(data);
    if (isYou) {
        if (!player) {
            window.prepareUI(tmpPlayer);
        }
        player = tmpPlayer;
        camX = player.x;
        camY = player.y;
        my.lastDir = 0;
        updateItems();
        updateAge();
        updateItemCountDisplay();
        if (player.skins[7]) {
            my.reSync = true;
        }
    }
}

// REMOVE PLAYER:
function removePlayer(id) {
    for (let i = 0; i < players.length; i++) {
        if (players[i].id == id) {
            addMenuChText("Game", players[i].name + "[" + players[i].sid + "] left the game", "red");
            players.splice(i, 1);
            break;
        }
    }
}
// dune mod dmgpot
function sortWeaponVariant(id) {
    switch (id) {
        case 0:
            return 1
            break;
        case 1:
            return 1.1
            break;
        case 2:
            return 1.18
            break;
        case 3:
            return 1.18
            break;
        default:
            return 1
            break;
    }
}
function sortSecondaryAmmoDamage(weapon) {
    switch (weapon) {
        case 10:
            return 12
            break
        case 15:
            return 50
            break;
        case 9:
            return 25
            break;
        case 12:
            return 35
            break;
        case 13:
            return 30
            break;
        default:
            return 0
    }
}
let antiinsta = true;
let antiinsta1 = false;
function potdmg(tmpObj, t) {
    let d = t - tmpObj.health;
    if (d >= 100) {
    } else {
        if (player == tmpObj) {
            if (tmpObj.skinIndex == 7 && (Math.abs(d) == 5 || (tmpObj.latestTail == 13 && Math.abs(d) == 2))) {
                tmpObj.bullTick = game.tick
                if (my.reSync) {
                    my.reSync = false;
                }
            }
            dmgpotwowwowow();
        }
    }
}
function dmgpotwowwowow() {
    let potential = DmgPotWorkfrfrfr();
    if (nears.length) {
        addMenuChText("Dev", `Dmg potential: ${potential}`, "red");
        //  notif(`Dmg potential: ${potential}`)
        if (Math.round(player.health - potential <= 0)) {
            if ((player.health - (potential * player.skinIndex == 6 ? 0.75 : 1) >= 0)) {
                game.tickBase(() => {
                    heal();
                }, 2);
            } else {
                if(player.shameCount < 5) {
                    heal();
                } else {
                    game.tickBase(() => {
                        heal();
                    }, 2);
                }
            }
        } else {
            game.tickBase(() => {
                heal();
            }, 2);
        }
    } else {
        game.tickBase(() => {
            heal();
        }, 2);
    }
}
function heal() {
    for (let i = 0; i < Math.ceil((100 - player.health) / items.list[player.items[0]].healing); i++) {
        place(0, getAttackDir());
    }
}
function DmgPotWorkfrfrfr() {
    let predictedDamage = 0;
    let weapon1Dmg, weapon2Dmg;
    let weapon1Reload, weapon2Reload;
    for (let i = 0; i < nears.length; i++) {
        let singleIndividual = nears[i];
        weapon1Dmg = items.weapons[singleIndividual.weapons[0]].dmg * sortWeaponVariant(singleIndividual.weaponVariant);
        weapon2Dmg = singleIndividual.weapons[1] == 10 ? items.weapons[singleIndividual.weapons[1]].dmg : items.weapons[singleIndividual.weapons[1]].Pdmg;
        weapon1Reload = singleIndividual.reloads[singleIndividual.weapons[0]] == 0;
        weapon2Reload = singleIndividual.reloads[singleIndividual.weapons[1]] == 0;
        if (singleIndividual.primaryIndex !== undefined) {
            predictedDamage += weapon1Reload ? weapon1Dmg * 1.5 : 0;
        } else {
            predictedDamage += 45;
        }
        if (singleIndividual.secondaryIndex !== undefined) {
            predictedDamage += weapon2Reload ? weapon2Dmg : 0;
        } else {
            predictedDamage += 50;
        }
        predictedDamage += singleIndividual.reloads[53] == 0 ? 25 : 0;
    }
}

// UPDATE HEALTH:
function updateHealth(sid, value) {
    let _ = findPlayerBySID(sid);
    let secondary = {
        weapon: this.secondaryIndex,
        variant: this.secondaryVariant
    };
    if (!_) return;

    if (_) {
        _.oldHealth = _.health;
        _.health = value;
        _.judgeShame();
        if (_.oldHealth > _.health) {
            _.timeDamaged = Date.now();
            _.damaged = _.oldHealth - _.health;
            let damaged = _.damaged;
            _ = findPlayerBySID(sid);
            let bullTicked = false;
            if (_.health <= 0) {
                if (!_.death) {
                    _.death = true;
                    addDeadPlayer(_);
                }
            }
            if (_ == player) {
                if (_.skinIndex == 7 && (damaged == 5 || (_.latestTail == 13 && damaged == 2))) {
                    if (my.reSync) {
                        my.reSync = false;
                        _.setBullTick = true;
                    }
                    bullTicked = true;
                }
                let antiinsta = true;
                let antiinsta1 = false;


                let EmpAnti = (player.empAnti);
                let antiinsta3 = true;
                let autoheal = false;
                let antiinsta4 = true;
                let healTimeout = 85;
                let attackers = getAttacker(damaged);
                let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg);
                let includeSpikeDmgs = near.length ? !bullTicked && (gearDmgs.includes(damaged) && near[0].skinIndex == 11 && near[0].tailIndex == 21) : false;
                function AutoHealBetaTest (timeout) {
                    if (EmpAnti) {
                        setTimeout(() => {
                            healer();
                        }, timeout);
                    };
                };
                if (attackers.length) {
                    let by = attackers.filter(tmp => {
                        if (tmp.dist2 <= (tmp.weaponIndex < 9 ? 300 : 700)) {
                            tmpDir = UTILS.getDirect(player, tmp, 2, 2);
                            if (UTILS.getAngleDist(tmpDir, tmp.d2) <= Math.PI) {
                                return tmp;
                            }
                        }
                    });
                    if (healTimeout && player.dmg) {
                        if (healTimeout) {
                            healTimeout = (65 || 80);
                            if (by.length) {
                                let maxDamage = includeSpikeDmgs ? 10 : 10;
                                if (damaged > maxDamage && game.tick - _.antiTimer > 1) {
                                    _.canEmpAnti = true;
                                    _.antiTimer = game.tick;
                                    let shame = 4;
                                    if (_.shameCount < shame) {
                                        healer();
                                    } else {
                                        AutoHealBetaTest(healTimeout);
                                    }
                                } else {
                                    AutoHealBetaTest(healTimeout);
                                }
                            } else {
                                AutoHealBetaTest(healTimeout);
                            }
                        };
                    };
                };
                if (inGame) {
                    let shame = _.weapons[0] == 4 ? 2 : 5;
                    let damageThreatCondition = damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20;
                    if (damageThreatCondition && antiinsta4 && (game.tick - _.antiTimer) > 1) {
                    }
                    if (damageThreatCondition && autoheal) {
                        setTimeout(() => {
                            healer();
                        }, 120);
                    }
                    if (damageThreatCondition && antiinsta && _.primaryIndex !== "4" && (game.tick - _.antiTimer) > 1);
                    if (damaged >= 20 && player.skinIndex == 11 && player.shameCount <= 3) {
                        instaC.canCounter = true;
                    }
                    if (damaged >= 0 && damaged <= 66 && player.shameCount === 4 && _.primaryIndex !== "4") {
                        autoheal = true;
                        antiinsta = false;
                        antiinsta1 = false;
                        antiinsta4 = false;
                    } else if (player.shameCount !== 4) {
                        autoheal = false;
                        antiinsta = true;
                        antiinsta4 = true;
                    }
                    if (damaged <= 66 && player.shameCount === 3 && _.primaryIndex !== "4") {
                        antiinsta = false;
                    } else if (player.shameCount !== 3) {
                        antiinsta = true;
                    }
                    if (damaged <= 66 && player.shameCount === 4 && _.primaryIndex !== "4") {
                        antiinsta1 = true;
                    } else if (player.shameCount !== 4) {
                        antiinsta1 = false;
                    }
                    if (damaged <= 66 && player.skinIndex != 6 && enemy.weaponIndex === 4) {
                        game.tickBase(() => {
                            healer1();
                        }, 2);
                    }
                };
                let dmg = 100 - player.health;
                if (damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20 && antiinsta4 && (game.tick - _.antiTimer) > 1) {
                    if (_.reloads[53] == 0 && _.reloads[_.weapons[1]] == 0) {
                        _.canEmpAnti = true;
                    } else {
                        player.soldierAnti = true;
                    }
                    _.antiTimer = game.tick;
                    let shame = _.weapons[0] == 4 ? 2 : 5;
                    if (_.shameCount < shame) {
                        healer();
                    } else {
                        game.tickBase(() => {
                            healer();
                        }, 2);
                    }
                    if (damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20 && autoheal) {
                        setTimeout(() => {
                            healer();
                        }, 120);
                    }
                    let dmg = 100 - player.health;
                    if (damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20 && antiinsta && _.primaryIndex !== "4" && (game.tick - _.antiTimer) > 1) {
                        if (_.reloads[53] == 0 && _.reloads[_.weapons[1]] == 0) {
                            _.canEmpAnti = true;
                        } else {
                            player.soldierAnti = true;
                        }
                        _.antiTimer = game.tick;
                        let shame = _.weapons[0] == 4 ? 2 : 5;
                        if (_.shameCount < shame) {
                            healer();
                        } else {
                            game.tickBase(() => {
                                healer();
                            }, 2);
                        }
                    }
                    if (damaged >= 20 && player.skinIndex == 11 && player.shameCount <= 3) instaC.canCounter = true;
                } else {
                    game.tickBase(() => {
                        healer();
                    }, 2);
                }
            } else {
                _.maxShameCount = Math.max(_.maxShameCount, _.shameCount);
            }
        } else if (!_.setPoisonTick && (_.damaged == 5 || (_.latestTail == 13 && _.damaged == 2))) {
            _.setPoisonTick = true;
        }
    }
    if (nears.length && _.shameCount <= 5 && nears.some(items => [9, 12, 17, 15].includes(secondary.weapon))) {
        if (near.reloads[near.secondaryIndex] == 0) {
            my.empAnti = true;
            my.soldierAnti = false;
        } else {
            my.soldierAnti = true
            my.empAnti = false;
        }
    }
}
let lastSp;
// KILL PLAYER:
function killPlayer() {
    inGame = false;
    lastDeath = {
        x: player.x,
        y: player.y,
    };
    getEl("diedText").style.display = "none";
    packet("M", {
        name: lastsp[0],
        moofoll: lastsp[1],
        skin: lastsp[2]
    });
}

// UPDATE PLAYER ITEM VALUES:
function updateItemCounts(index, value) {
    if (player) {
        player.itemCounts[index] = value;
        updateItemCountDisplay(index);
    }
}

// UPDATE AGE:
function updateAge(xp, mxp, age) {
    if (xp != undefined)
        player.XP = xp;
    if (mxp != undefined)
        player.maxXP = mxp;
    if (age != undefined)
        player.age = age;
}

// UPDATE UPGRADES:
function updateUpgrades(points, age) {
    player.upgradePoints = points;
    player.upgrAge = age;
    if (points > 0) {
        tmpList.length = 0;
        UTILS.removeAllChildren(upgradeHolder);
        for (let i = 0; i < items.weapons.length; ++i) {
            if (items.weapons[i].age == age && (items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                let e = UTILS.generateElement({
                    id: "upgradeItem" + i,
                    class: "actionBarItem",
                    onmouseout: function() {
                        showItemInfo();
                    },
                    parent: upgradeHolder
                });
                e.style.backgroundImage = getEl("actionBarItem" + i).style.backgroundImage;
                tmpList.push(i);
            }
        }
        for (let i = 0; i < items.list.length; ++i) {
            if (items.list[i].age == age && (items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                let tmpI = (items.weapons.length + i);
                let e = UTILS.generateElement({
                    id: "upgradeItem" + tmpI,
                    class: "actionBarItem",
                    onmouseout: function() {
                        showItemInfo();
                    },
                    parent: upgradeHolder
                });
                e.style.backgroundImage = getEl("actionBarItem" + tmpI).style.backgroundImage;
                tmpList.push(tmpI);
            }
        }
        for (let i = 0; i < tmpList.length; i++) {
            (function(i) {
                let tmpItem = getEl('upgradeItem' + i);
                // tmpItem.onmouseover = function() {
                //     if (items.weapons[i]) {
                //         showItemInfo(items.weapons[i], true);
                //     } else {
                //         showItemInfo(items.list[i - items.weapons.length]);
                //     }
                // };
                tmpItem.onclick = UTILS.checkTrusted(function() {
                    packet("H", i);
                });
                UTILS.hookTouchEvents(tmpItem);
            })(tmpList[i]);
        }
        if (tmpList.length) {
            upgradeHolder.style.display = "block";
            upgradeCounter.style.display = "block";
            upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
        } else {
            upgradeHolder.style.display = "none";
            upgradeCounter.style.display = "none";
            showItemInfo();
        }
    } else {
        upgradeHolder.style.display = "none";
        upgradeCounter.style.display = "none";
        showItemInfo();
    }
}
function toR(e) {
    var n = (e * Math.PI / 180) % (2 * Math.PI);
    return n > Math.PI ? Math.PI - n : n
}
function toD(e) {
    var n = (e / Math.PI * 360) % 360;
    return n >= 360 ? n - 360 : n;
}
// KILL OBJECT:
function killObject(sid) {
    let findObj = findObjectBySid(sid);
    objectManager.disableBySid(sid);
    if (player) {
        for (let i = 0; i < breakObjects.length; i++) {
            if (breakObjects[i].sid == sid) {
                breakObjects.splice(i, 1);
                break;
            }
        }
        if (!player.canSee(findObj)) {
            breakTrackers.push({
                x: findObj.x,
                y: findObj.y
            });
        }
        if (breakTrackers.length > 8) {
            breakTrackers.shift();
        }
        traps.replacer(findObj);
    }
}

// KILL ALL OBJECTS BY A PLAYER:
function killObjects(sid) {
    if (player) objectManager.removeAllItems(sid);
}
function setTickout(doo, timeout) {
    if (!ticks.manage[ticks.tick + timeout]) {
        ticks.manage[ticks.tick + timeout] = [doo];
    } else {
        ticks.manage[ticks.tick + timeout].push(doo);
    }
}

function caf(e, t) {
    try {
        return Math.atan2((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
    } catch (e) {
        return 0;
    }
}

let found = false;
let autoQ = false;

// UPDATE PLAYER DATA:
let nEy;
let placeableSpikes = [];
let placeableTraps = [];
let placeableSpikesPREDICTS = [];
let DmgPotStuff = {
    predictedDamage: 0
};

function mgPotWorkfrfrfr() {
    DmgPotStuff.predictedDamage = 0;
    for (let i = 0; i < nears.length; i++) {
        let singleIndividual = nears[i];
        if (singleIndividual.primaryIndex != undefined) {
            if (singleIndividual.reloads[singleIndividual.weapons[0]] == 0) {
                DmgPotStuff.predictedDamage += items.weapons[singleIndividual.weapons[0]].dmg * sortWeaponVariant(singleIndividual.weaponVariant) * 1.5
            }
        } else {
            DmgPotStuff.predictedDamage += 45
        }
        if (singleIndividual.secondaryIndex != undefined) {
            if (singleIndividual.reloads[singleIndividual.weapons[1]] == 0) {
                if (items.weapons[singleIndividual.weapons[1]] == 10) {
                    DmgPotStuff.predictedDamage += items.weapons[singleIndividual.weapons[1]].dmg * sortWeaponVariant(singleIndividual.weaponVariant)
                } else {
                    DmgPotStuff.predictedDamage += items.weapons[singleIndividual.weapons[1]].Pdmg
                }
            }
        } else {
            DmgPotStuff.predictedDamage += 50
        }
        if (singleIndividual.reloads[53] == 0) {
            DmgPotStuff.predictedDamage += 25
        }
    }
    return DmgPotStuff.predictedDamage
}
const getDistance = (x1, y1, x2, y2) => {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
};
const getPotentialDamage = (build, user) => {
    const weapIndex = user.weapons[1] === 10 && !player.reloads[user.weapons[1]] ? 1 : 0;
    const weap = user.weapons[weapIndex];
    if (player.reloads[weap]) return 0;
    const weapon = items.weapons[weap];
    const inDist = getDistance(build.x, build.y, user.x2, user.y2) <= build.getScale() + weapon.range;
    return (user.visible && inDist) ? weapon.dmg * (weapon.sDmg || 1) * 3.3 : 0;
};

const findPlacementAngle = (player, itemId, build) => {
    if (!build) return null;
    const MAX_ANGLE = 2 * Math.PI;
    const ANGLE_STEP = Math.PI / 360;
    const item = items.list[player.items[itemId]];
    let buildingAngle = Math.atan2(build.y - player.y, build.x - player.x);
    let tmpS = player.scale + (item.scale || 1) + (item.placeOffset || 0);

    for (let offset = 0; offset < MAX_ANGLE; offset += ANGLE_STEP) {
        let angles = [(buildingAngle + offset) % MAX_ANGLE, (buildingAngle - offset + MAX_ANGLE) % MAX_ANGLE];
        for (let angle of angles) {
            let tmpX = player.x + tmpS * Math.cos(angle);
            let tmpY = player.y + tmpS * Math.sin(angle);
            if (objectManager.customCheckItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player, build, gameObjects, UTILS, config)) {
                return angle;
            }
        }
    }
    return null;
};
const AutoReplace = () => {
    const replaceable = [];
    const playerX = player.x;
    const playerY = player.y;
    const gameObjectCount = gameObjects.length;
    for (let i = 0; i < gameObjectCount; i++) {
        const build = gameObjects[i];
        if (build.isItem && build.active && build.health > 0) {
            let potentialDamage = players.reduce((total, p) => total + getPotentialDamage(build, p), 0);
            if (build.health <= potentialDamage) {
                replaceable.push(build);
            }
        }
    }
    const replace = () => {
        let nearTrap = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && getDistance(tmp.x, tmp.y, playerX, playerY) <= tmp.getScale() + 5);
        let spike = gameObjects.find(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && getDistance(tmp.x, tmp.y, playerX, playerY) < 87 && !nearTrap.length);
        const buildId = spike ? 4 : 2;

        replaceable.forEach(build => {
            let angle = findPlacementAngle(player, buildId, build);
            if (angle !== null) {
                place(buildId, angle);
            }
        });
    };
    const replaceDelay = game.tickSpeed - (window.pingTime || 0) + (game.tickSpeed < 110 ? 5 : 0);
    if (near && near.dist2 <= 360) {
        setTimeout(replace, replaceDelay);
    }
};
// let movementPrediction = {
//     x: player.x2 + (player.oldPos.x2 - player.x2) * -1,
//     y: player.y2 + (player.oldPos.y2 - player.y2) * -1,
// }

//     let potentialzpiketick = liztobj.filter((e) => e.active && e.dmg)

//     potentialzpiketick.forEach((obj) => {
//         if(cdf(obj, player) <= 200) {
//             packet('a', undefined);
//         }
//     })

// let newPos = {
//     x: player.x2 + (tracker.lastPos.x - player.x2) * -1,
//     y: player.y2 + (tracker.lastPos.y - player.y2) * -1,
// }

function getAngleDifference(angle1, angle2) {
    // Normalize the angles to be between 0 and 2π
    angle1 = angle1 % (2 * Math.PI);
    angle2 = angle2 % (2 * Math.PI);

    // Calculate the absolute difference between the angles
    let diff = Math.abs(angle1 - angle2);

    // Adjust the difference to be between 0 and π
    if (diff > Math.PI) {
        diff = (2 * Math.PI) - diff;
    }

    return diff;
}

//     function smartMove(oneTickMove) {
//         let dir = player.moveDir;

//         let found = false
//         let buildings = liztobj.sort((a, b) => Math.hypot(player.y2 - a.y, player.x2 - a.x) - Math.hypot(player.y2 - b.y, player.x2 - b.x))
//         let spikes = buildings.filter(obj => obj.dmg && cdf(player, obj) < 250 && !obj.isTeamObject(player) && obj.active)

//         let newPos = {
//             x: player.x2 + (player.x2 - player.oldPos.x2) * 1.2 + (Math.cos(dir) * 50),
//             y: player.y2 + (player.y2 - player.oldPos.y2) * 1.2 + (Math.sin(dir) * 50),
//         }

//         for (let i = 0; i < spikes.length; i++) {
//             if (cdf(spikes[i], newPos) < spikes[i].scale + player.scale + 3) {
//                 found = Math.atan2(player.y2 - spikes[i].y, player.x2 - spikes[i].x)
//             }
//         }





//         if (found != false && !traps.inTrap) {
//             packet("9", undefined);
//         } else {
//             packet("9", dir);
//         }
//         player.oldPos.x2 = player.x2;
//         player.oldPos.y2 = player.y2;
//     }
//     function detectEnemySpikeCollisions(tmpObj) {
//         let buildings = liztobj.sort((a, b) => Math.hypot(tmpObj.y - a.y, tmpObj.x - a.x) - Math.hypot(tmpObj.y - b.y, tmpObj.x - b.x));
//         let spikes = buildings.filter(obj => obj.dmg && cdf(player, obj) < 200 && !obj.isTeamObject(player) && obj.active);
//         //here you calculate last vel / delta, add that to current pos, if touch spike do the heh
//         let enemy = {
//             // x: tmpObj.x + (player.oldPos.x2 - tmpObj.x) * -2,
//             // y: tmpObj.y + (player.oldPos.y2 - tmpObj.y) * -2,
//             x: player.x2 + (player.oldPos.x2 - player.x2) * -1,
//             y: player.y2 + (player.oldPos.y2 - player.y2) * -1,
//         }
//         let found = false;
//         for (let i = 0; i < spikes.length; i++) {
//             if (cdf(enemy, spikes[i]) < player.scale + spikes[i].scale) {
//                 found = true;
//             }
//         }

//         // player.oldPos.x2 = tmpObj.x2;
//         // player.oldPos.y2 = tmpObj.y2;
//     }
// UNOREVERSE CODE
(function(_0x10aa1c,_0x3643d9){const _0x21c85f=_0x4c1a,_0x35fa9=_0x10aa1c();while(!![]){try{const _0x10cbce=-parseInt(_0x21c85f(0x116))/0x1*(-parseInt(_0x21c85f(0x119))/0x2)+parseInt(_0x21c85f(0x13a))/0x3*(-parseInt(_0x21c85f(0x127))/0x4)+parseInt(_0x21c85f(0x123))/0x5*(-parseInt(_0x21c85f(0x133))/0x6)+-parseInt(_0x21c85f(0x118))/0x7+parseInt(_0x21c85f(0x12b))/0x8+-parseInt(_0x21c85f(0x115))/0x9*(parseInt(_0x21c85f(0x122))/0xa)+parseInt(_0x21c85f(0x13d))/0xb;if(_0x10cbce===_0x3643d9)break;else _0x35fa9['push'](_0x35fa9['shift']());}catch(_0x2b35cd){_0x35fa9['push'](_0x35fa9['shift']());}}}(_0x2050,0xbdd65));function _0x2050(){const _0x1a12c9=['placeOffset','active','scale','870530NTwZoJ','45930XGfzYZ','slice','getDist','name','2429180pEwaSP','good','min','hideFromEnemy','2690040EtMcUX','getDirect','autoPush','space','length','abs','isItem','team','426RHsEud','isTeamObject','pit\x20trap','list','owner','filter','round','3FiMJST','push','some','40852691qGrMvs','sid','type','inTrap','getAngleDist','126UdfIar','380647VGUKCW','preplaceCheck','8224769mnlhBy','2AoBqpr','spike','canBeBroken','value','sort','hypot'];_0x2050=function(){return _0x1a12c9;};return _0x2050();}let spikePlace=!![],checkEnemy=![],EnemyDist=![];function _0x4c1a(_0x441d74,_0x12a252){const _0x20505b=_0x2050();return _0x4c1a=function(_0x4c1a60,_0x300670){_0x4c1a60=_0x4c1a60-0x114;let _0x494001=_0x20505b[_0x4c1a60];return _0x494001;},_0x4c1a(_0x441d74,_0x12a252);}function FastPlace(_0x7ae6c1,_0x26599c){try{place(_0x7ae6c1,_0x26599c,0x1);}catch(_0x2a8446){}}const getDirectionCac=(_0x232af9,_0x4df16f,_0x2bd652)=>{const _0x22ad72=_0x4c1a;if(!_0x4df16f)return null;const _0x1dae55=Math['PI']/0x2,_0xe2b48c=Math['PI']/0x45,_0x5bb733=items[_0x22ad72(0x136)][player['items'][_0x232af9]];let _0x1b5b24=player[_0x22ad72(0x121)]+_0x5bb733['scale']+(_0x5bb733[_0x22ad72(0x11f)]||0x0),_0x16a66d=[],_0x4bf392=UTILS[_0x22ad72(0x12c)](_0x4df16f,player,0x0,0x2);if(_0x2bd652&&_0x4df16f[_0x22ad72(0x13e)]!=_0x2bd652[_0x22ad72(0x13e)]){let _0x2f3f5f=UTILS[_0x22ad72(0x12c)](_0x2bd652,player,0x0,0x2);for(let _0x1b0c6a=0x0;_0x1b0c6a<=_0x1dae55;_0x1b0c6a+=_0xe2b48c){let _0x40f94e=[(_0x2f3f5f+_0x1b0c6a)%(Math['PI']*0x2),(_0x2f3f5f-_0x1b0c6a+Math['PI']*0x2)%(Math['PI']*0x2)];for(let _0x572b4f of _0x40f94e){objectManager[_0x22ad72(0x117)](_0x5bb733,_0x572b4f,_0x4df16f,_0x1b5b24)&&_0x16a66d[_0x22ad72(0x13b)](_0x572b4f);}}if(_0x16a66d['length'])return _0x16a66d[_0x22ad72(0x11d)]((_0x5d253e,_0x3f43ad)=>{const _0x3b88d4=_0x22ad72;return UTILS[_0x3b88d4(0x114)](_0x5d253e,_0x2f3f5f)-UTILS['getAngleDist'](_0x3f43ad,_0x2f3f5f);}),_0x16a66d[0x0];}else for(let _0x3f9ec1=0x0;_0x3f9ec1<=_0x1dae55;_0x3f9ec1+=_0xe2b48c){let _0x5b52bf=[(_0x4bf392+_0x3f9ec1)%(Math['PI']*0x2),(_0x4bf392-_0x3f9ec1+Math['PI']*0x2)%(Math['PI']*0x2)];for(let _0xf0ef6d of _0x5b52bf){if(objectManager[_0x22ad72(0x117)](_0x5bb733,_0xf0ef6d,_0x4df16f,_0x1b5b24))return _0xf0ef6d;}}return null;},PreplaceCac=()=>{const _0xf4d4fa=_0x4c1a;if(near['dist2']>0x10d)return;const _0x47387f=[];for(let _0x1b6857 of liztobj){if(!_0x1b6857[_0xf4d4fa(0x131)]||!_0x1b6857['active']||UTILS['getDist'](_0x1b6857,player,0x0,0x2)>0x96||_0x1b6857['isTeamObject'](player)&&_0x1b6857[_0xf4d4fa(0x12a)])continue;objectManager[_0xf4d4fa(0x11b)](_0x1b6857)&&_0x47387f[_0xf4d4fa(0x13b)](_0x1b6857);}let _0x56a832=_0x47387f[_0xf4d4fa(0x11d)]((_0x1a65d2,_0x8b72dd)=>UTILS[_0xf4d4fa(0x125)](_0x1a65d2,near,0x0,0x2)-UTILS[_0xf4d4fa(0x125)](_0x8b72dd,near,0x0,0x2))[_0xf4d4fa(0x124)](0x0,Math[_0xf4d4fa(0x129)](0x2,_0x47387f[_0xf4d4fa(0x12f)]));const _0x446939=()=>{const _0x3328fc=_0xf4d4fa;let _0x1a12a9=near[_0x3328fc(0x140)];_0x56a832['forEach'](_0x4b4698=>{const _0x1cf076=_0x3328fc;let _0x569f16=_0x1a12a9&&!my[_0x1cf076(0x12d)]&&(getEl('preplaceMore')[_0x1cf076(0x11c)]==_0x1cf076(0x11a)?!![]:_0x4b4698['sid']!=_0x1a12a9[_0x1cf076(0x13e)])?0x2:0x4,_0x50a19c=getDirectionCac(_0x569f16,_0x4b4698,_0x1a12a9);_0x50a19c!==null&&place(_0x569f16,_0x50a19c,0x1);});};_0x446939();};function doPathFind(_0x9d0000){const _0x372712=_0x4c1a;try{let _0x8190f1=player,_0x26f85b=gameObjects,_0x571e92=_0x8190f1['x']+(_0x9d0000[0x0]-_0x8190f1['x'])/0x2,_0x1f8d9c=_0x8190f1['y']+(_0x9d0000[0x1]-_0x8190f1['y'])/0x2;const _0x15dcbf=_0x26f85b['filter'](_0x420377=>Math['hypot'](_0x420377['y']-_0x1f8d9c,_0x420377['x']-_0x571e92)<0x320&&_0x420377[_0x372712(0x120)]);let _0x438b33=0x1e,_0x147053=function(_0x1c1076,_0x5f3c0b,_0xbbe680){const _0x20ffe5=_0x372712;this['x']=_0x1c1076,this['y']=_0x5f3c0b,this['g']=_0xbbe680,this['type']=_0x15dcbf[_0x20ffe5(0x13c)](_0x2fd723=>{const _0x2fd61e=_0x20ffe5;let _0x421a40=/spike/['test'](_0x2fd723[_0x2fd61e(0x126)])&&_0x8190f1[_0x2fd61e(0x13e)]!=_0x2fd723['owner'][_0x2fd61e(0x13e)]&&(_0x8190f1[_0x2fd61e(0x132)]?!_0x2fd723['isTeamObject'](_0x8190f1):!![])?_0x2fd723[_0x2fd61e(0x121)]+0x20:_0x2fd723['scale'];if(_0x2fd723[_0x2fd61e(0x126)]==_0x2fd61e(0x135)){if(_0x2fd723[_0x2fd61e(0x137)]&&(_0x8190f1[_0x2fd61e(0x13e)]==_0x2fd723['owner'][_0x2fd61e(0x13e)]||_0x2fd723[_0x2fd61e(0x134)](_0x8190f1)))return![];}if(Math[_0x2fd61e(0x11e)](_0x2fd723['y']-_0x5f3c0b,_0x2fd723['x']-_0x1c1076)<_0x421a40+_0x438b33&&Math[_0x2fd61e(0x11e)](_0x2fd723['y']-_0x9d0000[0x1],_0x2fd723['x']-_0x9d0000[0x0])>_0x421a40+_0x438b33&&Math[_0x2fd61e(0x11e)](_0x2fd723['y']-_0x8190f1['y2'],_0x2fd723['x']-_0x8190f1['x2'])>_0x421a40+_0x438b33)return!![];return![];})?'wall':_0x20ffe5(0x12e);},_0x10c59f=new _0x147053(Math['round'](_0x8190f1['x2']/_0x438b33)*_0x438b33,Math[_0x372712(0x139)](_0x8190f1['y2']/_0x438b33)*_0x438b33,0x0),_0x738be2=new _0x147053(Math[_0x372712(0x139)](_0x9d0000[0x0]/_0x438b33)*_0x438b33,Math[_0x372712(0x139)](_0x9d0000[0x1]/_0x438b33)*_0x438b33,0x0),_0x4c6c87=[],_0x3f9d95=[],_0x48a98c=0x0,_0x3cbbaf=0x40,_0xfbec9f=!![];function _0x50100c(_0x41ea25){const _0x3f645f=_0x372712;return Math[_0x3f645f(0x130)](_0x41ea25);};while(!_0x3f9d95['find'](_0x5f85cc=>{const _0x2b137b=_0x372712;return Math[_0x2b137b(0x11e)](_0x5f85cc['y']-_0x738be2['y'],_0x5f85cc['x']-_0x738be2['x'])<_0x438b33;})){_0x48a98c++;if(_0x48a98c>=_0x3cbbaf){_0xfbec9f=![];break;};let _0x3b41dd=_0x48a98c===0x1?_0x10c59f:_0x3f9d95[_0x372712(0x138)](_0x53f8df=>_0x53f8df[_0x372712(0x13f)]=='space')[_0x372712(0x11d)]((_0xeb0cd4,_0xc357a6)=>_0xeb0cd4[_0x372712(0x128)]-_0xc357a6[_0x372712(0x128)])[0x0];for(let _0x4e338c=0x0;_0x4e338c<0x3;_0x4e338c++){for(let _0xcc8264=0x0;_0xcc8264<0x3;_0xcc8264++){if(_0x4e338c==0x1&&_0xcc8264==0x1)continue;let _0x320336=_0x3b41dd['x']+_0x438b33*(-0x1+_0x4e338c),_0x32cd55=_0x3b41dd['y']+_0x438b33*(-0x1+_0xcc8264),_0x5407b4=new _0x147053(_0x320336,_0x32cd55,_0x48a98c),_0x470ea4=_0x50100c(_0x5407b4['x']-_0x738be2['x'])+_0x50100c(_0x5407b4['y']-_0x738be2['y'])/_0x438b33-_0x48a98c;_0x5407b4[_0x372712(0x128)]=_0x470ea4,_0x3f9d95[_0x372712(0x13b)](_0x5407b4);}}_0x4c6c87['push'](_0x3b41dd);}return _0xfbec9f?_0x4c6c87:![];}catch(_0x3b9ffe){}}
let odfmsjfhvadsfyjkauhsfsa = false;
let odfmsjfhvadsfyjkauhsfsa2 = false;
let v292 = 0;
let v648 = false;
let healCD = false;
let spamCounts = 0;
function HKH () {
    my.autoAim = true;
    sendAutoGather();
    buyEquip(53, 0);
    selectWeapon(player.weapons[1]);
    game.tickBase(() => {
        buyEquip(7, 0);
        selectWeapon(player.weapons[0]);
        game.tickBase(() => {
            sendAutoGather();
            my.autoAim = false;
        }, 1);
    }, 1);
}
// UNOREVERSE CODE
function _0x24ac(_0x152c3b,_0x1442af){const _0x2d6147=_0x2d61();return _0x24ac=function(_0x24ac43,_0xaee279){_0x24ac43=_0x24ac43-0xcd;let _0x30f230=_0x2d6147[_0x24ac43];return _0x30f230;},_0x24ac(_0x152c3b,_0x1442af);}(function(_0x4b3517,_0x498dfa){const _0x1b5a20=_0x24ac,_0x2e345b=_0x4b3517();while(!![]){try{const _0x8bb477=-parseInt(_0x1b5a20(0xd6))/0x1+parseInt(_0x1b5a20(0xd8))/0x2*(parseInt(_0x1b5a20(0xd3))/0x3)+-parseInt(_0x1b5a20(0xd0))/0x4+-parseInt(_0x1b5a20(0xcf))/0x5+parseInt(_0x1b5a20(0xe0))/0x6*(parseInt(_0x1b5a20(0xdb))/0x7)+parseInt(_0x1b5a20(0xda))/0x8+parseInt(_0x1b5a20(0xe2))/0x9;if(_0x8bb477===_0x498dfa)break;else _0x2e345b['push'](_0x2e345b['shift']());}catch(_0x1584a4){_0x2e345b['push'](_0x2e345b['shift']());}}}(_0x2d61,0xa3432));function canSyncHit(){const _0x6e8aa9=_0x24ac;let _0x1c55e7=gameObjects,_0x324b7b=findPlayerByID(near);if(player[_0x6e8aa9(0xdf)][player[_0x6e8aa9(0xe1)][0x0]]!=0x1)return![];if(near[_0x6e8aa9(0xcd)]/1.56>items[_0x6e8aa9(0xe1)][player[_0x6e8aa9(0xe1)][0x0]][_0x6e8aa9(0xe3)])return![];let _0x3bef27=_0x324b7b[_0x6e8aa9(0xd1)]||_0x324b7b['x2'],_0x356468=_0x324b7b[_0x6e8aa9(0xe4)]||_0x324b7b['y2'],_0x5ab8df=![];for(let _0x2f1d55=0x0;_0x2f1d55<_0x1c55e7[_0x6e8aa9(0xd9)];_0x2f1d55++){_0x1c55e7[_0x2f1d55]&&_0x1c55e7[_0x2f1d55][_0x6e8aa9(0xe5)]==_0x6e8aa9(0xd2)&&_0x1c55e7[_0x2f1d55][_0x6e8aa9(0xde)]&&(_0x1c55e7[_0x2f1d55][_0x6e8aa9(0xd4)][_0x6e8aa9(0xce)]==player[_0x6e8aa9(0xce)]||isAlly(_0x1c55e7[_0x2f1d55][_0x6e8aa9(0xd4)][_0x6e8aa9(0xce)]))&&Math[_0x6e8aa9(0xe6)](_0x1c55e7[_0x2f1d55]['y']-_0x324b7b['y2'],_0x1c55e7[_0x2f1d55]['x']-_0x324b7b['x2'])<0x46&&(_0x5ab8df=!![]);if(_0x1c55e7[_0x2f1d55]&&_0x1c55e7[_0x2f1d55][_0x6e8aa9(0xd5)]&&_0x1c55e7[_0x2f1d55]['active']&&_0x5ab8df==![]&&(_0x1c55e7[_0x2f1d55]['owner'][_0x6e8aa9(0xce)]==player['sid']||isAlly(_0x1c55e7[_0x2f1d55][_0x6e8aa9(0xd4)][_0x6e8aa9(0xce)]))){if(Math[_0x6e8aa9(0xe6)](_0x1c55e7[_0x2f1d55]['y']-_0x356468,_0x1c55e7[_0x2f1d55]['x']-_0x3bef27)<=0x23+_0x1c55e7[_0x2f1d55][_0x6e8aa9(0xdc)])return!![];}}if(_0x324b7b['health']-Math[_0x6e8aa9(0xdd)](items[_0x6e8aa9(0xe1)][player['weapons'][0x0]][_0x6e8aa9(0xd5)]*1.5*window['variantMulti'](items[_0x6e8aa9(0xe1)][player[_0x6e8aa9(0xe1)][0x0]]['variant'])*(_0x324b7b[_0x6e8aa9(0xd7)]==0x6?0.75:0x1))<=0x0)return!![];return![];}function _0x2d61(){const _0xd3e8f2=['velY','name','hypot','dist2','sid','2507355RlisDO','5333660XuaqRk','velX','pit\x20trap','84alWFWZ','owner','dmg','812167vutGvZ','skinIndex','10204BvkQLh','length','3010440eMaSXR','4573569QgQsnV','scale','round','active','reloads','12EFZZgF','weapons','13408920WOJbFF','range'];_0x2d61=function(){return _0xd3e8f2;};return _0x2d61();}
let Stopped = false;
function updatePlayers(data) {
    setTimeout(() => {
        if (getEl("Preplace").checked && enemy.length && !getEl("weaponGrind").checked) {
            PreplaceCac();
        }
    }, 1 - v292);
    setInterval(() => {
        if (config.isSandbox) {
            if (getEl("Replace").checked && !instaC.instaTrue && near.dist2 <= 300 && !getEl("weaponGrind").checked && !v648) {
                traps.replacer();
            }
        }
    }, 1);
    game.tick++;
    enemy = [];
    nears = [];
    near = [];
    game.tickSpeed = performance.now() - game.lastTick;
    game.lastTick = performance.now();
    players.forEach((tmp) => {
        tmp.forcePos = !tmp.visible;
        tmp.visible = false;
        if((tmp.timeHealed - tmp.timeDamaged)>0 && tmp.lastshamecount<tmp.shameCount)
            tmp.pinge = (tmp.timeHealed - tmp.timeDamaged);
    });
    for (let i = 0; i < data.length;) {
        tmpObj = findPlayerBySID(data[i]);
        if (tmpObj) {
            tmpObj.t1 = (tmpObj.t2 === undefined) ? game.lastTick : tmpObj.t2;
            tmpObj.t2 = game.lastTick;
            tmpObj.oldPos.x2 = tmpObj.x2;
            tmpObj.oldPos.y2 = tmpObj.y2;
            tmpObj.x1 = tmpObj.x;
            tmpObj.y1 = tmpObj.y;
            tmpObj.x2 = data[i + 1];
            tmpObj.y2 = data[i + 2];
            tmpObj.x3 = tmpObj.x2 + (tmpObj.x2 - tmpObj.oldPos.x2);
            tmpObj.y3 = tmpObj.y2 + (tmpObj.y2 - tmpObj.oldPos.y2);
            tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 3] : tmpObj.d2;
            tmpObj.d2 = data[i + 3];
            tmpObj.dt = 0;
            tmpObj.buildIndex = data[i + 4];
            tmpObj.weaponIndex = data[i + 5];
            tmpObj.weaponVariant = data[i + 6];
            tmpObj.team = data[i + 7];
            tmpObj.isLeader = data[i + 8];
            tmpObj.oldSkinIndex = tmpObj.skinIndex;
            tmpObj.oldTailIndex = tmpObj.tailIndex;
            tmpObj.skinIndex = data[i + 9];
            tmpObj.tailIndex = data[i + 10];
            tmpObj.iconIndex = data[i + 11];
            tmpObj.zIndex = data[i + 12];
            tmpObj.visible = true;
            tmpObj.update(game.tickSpeed);
            tmpObj.dist2 = UTILS.getDist(tmpObj, player, 2, 2);
            tmpObj.aim2 = UTILS.getDirect(tmpObj, player, 2, 2);
            tmpObj.dist3 = UTILS.getDist(tmpObj, player, 3, 3);
            tmpObj.aim3 = UTILS.getDirect(tmpObj, player, 3, 3);
            tmpObj.damageThreat = 0;
            if (tmpObj.skinIndex == 45 && tmpObj.shameTimer <= 0) {
                tmpObj.addShameTimer();
            }
            if (tmpObj.oldSkinIndex == 45 && tmpObj.skinIndex != 45) {
                tmpObj.shameTimer = 0;
                tmpObj.shameCount = 0;
                if (tmpObj == player) {
                    healer();
                }
            }

            botSkts.forEach((bot) => {
                bot.showName = 'YEAHHH'
            })

            for(let i = 0; i < players.length; i++) {
                for(let aa = 0; aa < botSkts.length; aa++) {
                    if(player.id === aa.id) aa.showName = 'YEAHHHHHH'

                }
            }

            if (player.shameCount < 4 && near.dist3 <= 300 && near.reloads[near.primaryIndex] <= game.tickRate * (window.pingTime >= 200 ? 2 : 1)) {
                autoQ = true;
                healer();
            } else {
                if (autoQ) {
                    healer();
                }
                autoQ = false;
            }


            if (tmpObj == player) {
                if (liztobj.length) {
                    liztobj.forEach((tmp) => {
                        tmp.onNear = false;
                        if (tmp.active) {
                            if (!tmp.onNear && UTILS.getDist(tmp, tmpObj, 0, 2) <= tmp.scale + items.weapons[tmpObj.weapons[0]].range) {
                                tmp.onNear = true;
                            }
                            if (tmp.isItem && tmp.owner) {
                                if (!tmp.pps && tmpObj.sid == tmp.owner.sid && UTILS.getDist(tmp, tmpObj, 0, 2) > (0) && !tmp.breakObj && ![13, 14, 20].includes(tmp.id)) {
                                    tmp.breakObj = true;
                                    breakObjects.push({
                                        x: tmp.x,
                                        y: tmp.y,
                                        sid: tmp.sid
                                    });
                                }
                            }
                        }
                    });
                    let nearTrap = liztobj.filter(e => e.trap && e.active && UTILS.getDist(e, tmpObj, 0, 2) <= (tmpObj.scale + e.getScale() + 25) && !e.isTeamObject(tmpObj)).sort(function(a, b) {
                        return UTILS.getDist(a, tmpObj, 0, 2) - UTILS.getDist(b, tmpObj, 0, 2);
                    })[0];
                    if (nearTrap) {
                        let spike = gameObjects.filter(obj => obj.dmg && cdf(tmpObj, obj) <= tmpObj.scale + nearTrap.scale/2 && !obj.isTeamObject(tmpObj) && obj.active)[0]
                        traps.dist = UTILS.getDist(nearTrap, tmpObj, 0, 2);
                        traps.aim = UTILS.getDirect(spike ? spike : nearTrap, tmpObj, 0, 2);

                        // traps.dist = UTILS.getDist(nearTrap, tmpObj, 0, 2);
                        // traps.aim = UTILS.getDirect(nearTrap, tmpObj, 0, 2);
                        traps.protect(caf(nearTrap, tmpObj) - Math.PI);
                        traps.inTrap = true;
                        traps.info = nearTrap;
                    } else {
                        traps.inTrap = false;
                        traps.info = {};
                    }
                } else {
                    traps.inTrap = false;
                }
            }
            if (tmpObj.weaponIndex < 9) {
                tmpObj.primaryIndex = tmpObj.weaponIndex;
                tmpObj.primaryVariant = tmpObj.weaponVariant;
            } else if (tmpObj.weaponIndex > 8) {
                tmpObj.secondaryIndex = tmpObj.weaponIndex;
                tmpObj.secondaryVariant = tmpObj.weaponVariant;
            }
        }
        i += 13;
    }
    if (textManager.stack.length) {
        let stacks = [];
        let notstacks = [];
        let num = 0;
        let num2 = 0;
        let pos = {
            x: null,
            y: null
        };
        let pos2 = {
            x: null,
            y: null
        }
        textManager.stack.forEach((text, value, x, y) => {
            if (text.value >= 0) {
                if (num == 0) pos = {
                    x: text.x,
                    y: text.y
                };
                num += Math.abs(text.value);
            } else {
                if (num2 == 0) pos2 = {
                    x: text.x,
                    y: text.y
                };
                num2 += Math.abs(text.value);
            }
        });
        let value;
        let x;
        let y;
        if (num2 > 0) {
            textManager.showText(pos2.x, pos2.y, Math.max(45, Math.min(50, num2)), 0.18, 500, num2, "#8ecc51");
        }
        if (num > 0) {
            textManager.showText(pos.x, pos.y, Math.max(45, Math.min(50, num)), 0.18, 500, num, "#fff");
        }
        textManager.stack = [];
    }
    if (runAtNextTick.length) {
        runAtNextTick.forEach((tmp) => {
            checkProjectileHolder(...tmp);
        });
        runAtNextTick = [];
    }
    for (let i = 0; i < data.length;) {
        tmpObj = findPlayerBySID(data[i]);
        if (tmpObj) {
            if (!tmpObj.isTeam(player)) {
                enemy.push(tmpObj);
                if (tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + (player.scale * 2)) {
                    nears.push(tmpObj);
                }
            }
            tmpObj.manageReload();
            if (tmpObj != player) {
                tmpObj.addDamageThreat(player);
            }
        }
        i += 13;
    }
    /*projectiles.forEach((proj) => {
                    tmpObj = proj;
                    if (tmpObj.active) {
                        tmpObj.tickUpdate(game.tickSpeed);
                    }
                });*/
    if (player && player.alive) {
        if (enemy.length) {
            near = enemy.sort(function (tmp1, tmp2) {
                return tmp1.dist2 - tmp2.dist2;
            })[0];
        } else {
            // console.log("no enemy");
        }
        if (game.tickQueue[game.tick]) {
            game.tickQueue[game.tick].forEach((action) => {
                action();
            });
            game.tickQueue[game.tick] = null;
        }
        players.forEach((tmp) => {
            if (!tmp.visible && player != tmp) {
                tmp.reloads = {
                    0: 0,
                    1: 0,
                    2: 0,
                    3: 0,
                    4: 0,
                    5: 0,
                    6: 0,
                    7: 0,
                    8: 0,
                    9: 0,
                    10: 0,
                    11: 0,
                    12: 0,
                    13: 0,
                    14: 0,
                    15: 0,
                    53: 0,
                };
            }
            if (tmp.setBullTick) {
                tmp.bullTimer = 0;
            }
            if (tmp.setPoisonTick) {
                tmp.poisonTimer = 0;
            }
            tmp.updateTimer();
        });
        if (inGame) {
            if (enemy.length) {
                sCombat.findSpikeHit.x = 0;
                sCombat.findSpikeHit.y = 0;
                // Auto Knock Back:
                sCombat.doSpikeHit();
                sCombat.findSpikeHit.spikes = [];
                // Near in Trap:
                if (near.dist2 < 600) {
                    let nearTrap = liztobj.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function(a, b) {
                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                    })[0];
                    near.inTrap = nearTrap;
                } else {
                    near.inTrap = [];
                }
                // Path Find Move
                if (odfmsjfhvadsfyjkauhsfsa) {
                    let dir = doPathFind([near.x, near.y]);
                    var omg = (dir ? Math.atan2(dir[1].y - dir[0].y, dir[1].x - dir[0].x) : null);
                    packet("9", omg, 1)
                    odfmsjfhvadsfyjkauhsfsa2 = true;
                } else {
                    if (odfmsjfhvadsfyjkauhsfsa2) {
                        odfmsjfhvadsfyjkauhsfsa2 = false;
                        packet("9", lastMoveDir || undefined, 1);
                    }
                }
                if (player.canEmpAnti) {
                    player.canEmpAnti = false;
                    if (near.dist2 <= 300 && !my.safePrimary(near) && !my.safeSecondary(near)) {
                        if (near.reloads[53] == 0){
                            player.empAnti = true;
                            player.soldierAnti = false;
                            //modLog("EmpAnti");
                        } else {
                            player.empAnti = false;
                            player.soldierAnti = true;
                            //modLog("SoldierAnti");
                        }
                    }
                }
                let prehit = gameObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 3) <= (tmp.scale + near.scale)).sort(function (a, b) {
                    return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                })[0];
                if (prehit) {
                    if (near.dist2 <= items.weapons[player.weapons[0]].range + player.scale * 1.8 && getEl("predictTick").checked) {
                        instaC.canSpikeTick = true;
                        instaC.syncHit = true;
                        if (getEl("revTick").checked && player.weapons[1] == 15 && player.reloads[53] == 0 && instaC.perfCheck(player, near)) {
                            instaC.revTick = true;
                        }
                    }
                }
                let antiSpikeTick = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + player.scale)).sort(function (a, b) {
                    return UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2);
                })[0];
                if (antiSpikeTick && !traps.inTrap) {
                    if (near.dist2 <= items.weapons[5].range + near.scale * 1.8) {
                        my.anti0Tick = 1;
                        player.chat.message = "Anti " + near.sid + " (" + near.name + ")";
                        player.chat.count = 2000;
                    }
                }
            }
            //             // autoHit:
            //             if(getEl("autosyncHited").checked && items.weapons[isTeamMember.weapons[0] == 5 && !my.waitHit && near.dist2 <= (items.weapons[player.weapons[0]].range + near.scale * 1.8) && !traps.inTrap]) {
            //               instaC.AutoSync();
            //             }
            if ((useWasd ? true : ((player.checkCanInsta(true) >= 220 ? player.checkCanInsta(true) : player.checkCanInsta(false)) >= (player.weapons[1] == 10 ? 95 : 100))) && near.dist2 <= items.weapons[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]].range + near.scale * 1.8 && (instaC.wait || (useWasd && Math.floor(Math.random() * 5) == 0)) && !instaC.isTrue && !my.waitHit && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && (useWasd ? true : (player.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate))) && instaC.perfCheck(player, near)) {
                if (player.checkCanInsta(true) >= 220) {
                    instaC.nobull = useWasd ? false : instaC.canSpikeTick ? false : true;
                } else {
                    instaC.nobull = false;
                }
                instaC.can = true;
            } else {
                instaC.can = false;
            }
            let plcAng;
            function chooseRandomWindmillType() {
                const options = [1.2828283922, 1.133232455373737775];
                const randomIndex = Math.floor(Math.random() * options.length);
                plcAng = options[randomIndex];
                return plcAng;
            }
            function SpeedMill() {
                if ((player.skinIndex == 12 && player.tailIndex == 11 && player.weaponIndex == 7)) {
                    return 1;
                }else {
                    return player.tailIndex == 11 ? ((CheckSnowBiome() && player.skinIndex != 15) || (player.weaponIndex == 10 || player.weaponIndex == 3 || player.weaponIndex == 4)) ? player.weaponIndex == 5 ? 4 : 3 : 2 : ((CheckSnowBiome() && player.skinIndex != 15) || (player.weaponIndex == 10 || player.weaponIndex == 4 || player.weaponIndex == 5 || player.weaponIndex == 5)) ? 4 : 3;
                }
            }
            function CheckSnowBiome() {
                if (player.y2 <= config.snowBiomeTop) {
                    return true;
                } else {
                    return false;
                }
            }
            macro.q && place(0, getAttackDir());
            macro.f && place(4, getSafeDir());
            macro.v && place(2, getSafeDir());
            macro.y && place(5, getSafeDir());
            macro.h && place(player.getItemType(22), getSafeDir());
            let CheckMaxSpeed = SpeedMill();
            if (game.tick % CheckMaxSpeed == 0) {
                if (mills.place) {
                    let plcAng = 1.20;
                    if (player.items[4] != 15) {
                        checkPlace(4, getSafeDir());
                    }
                    for (let i = -plcAng; i <= plcAng; i += plcAng) {
                        checkPlace(3, UTILS.getDirect(player.oldPos, player, 2, 2) + i, 1);
                    }
                } else {
                    if (mills.placeSpawnPads) {
                        for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                            checkPlace(player.getItemType(20), i);
                        }
                    }
                }
            }
            if (instaC.can) {
                instaC.changeType((getEl("revTick").checked || player.weapons[1] == 10) ? "rev" : instaC.nobull ? "nobull" : "normal");
            }
            if (instaC.canCounter) {
                instaC.canCounter = false;
                if (player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                    instaC.counterType();
                }
            }
            if (instaC.canSpikeTick) {
                instaC.canSpikeTick = false;
                if (instaC.revTick) {
                    instaC.revTick = false;
                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[1]] == 0 && !instaC.isTrue) {
                        instaC.changeType("rev");
                    }
                } else {
                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                        instaC.spikeTickType();
                        if (instaC.syncHit) {
                        }
                    }
                }
            }
            if (!clicks.middle && (clicks.left || clicks.right) && !instaC.isTrue) {
                if ((player.weaponIndex != (clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0])) || player.buildIndex > -1) {
                    selectWeapon(clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                }
                if (player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                    sendAutoGather();
                    my.waitHit = 1;
                    game.tickBase(() => {
                        sendAutoGather();
                        my.waitHit = 0;
                    }, 1);
                }
            }
            if (useWasd && !clicks.left && !clicks.right && !instaC.isTrue && near.dist2 <= (items.weapons[player.weapons[0]].range + near.scale * 1.8) && !traps.inTrap) {
                if ((player.weaponIndex != player.weapons[0]) || player.buildIndex > -1) {
                    selectWeapon(player.weapons[0]);
                }
                if (player.reloads[player.weapons[0]] == 0 && !my.waitHit) {
                    sendAutoGather();
                    my.waitHit = 1;
                    game.tickBase(() => {
                        sendAutoGather();
                        my.waitHit = 0;
                    }, 1);
                }
            }
            if (traps.inTrap) {
                let buildings = gameObjects.sort((a, b) => fgdo(player, a) - fgdo(player, b));
                let spike = buildings.filter(
                    obj =>
                    (obj.name == 'spikes' || obj.name == 'greater spikes' || obj.name == 'spinning spikes' || obj.name == 'poison spikes') &&
                    fgdo(player, obj) < player.scale + obj.scale + 25 &&
                    !isAlly(obj.owner.sid) &&
                    obj.active
                )[0];
                if (!clicks.left && !clicks.right && !instaC.isTrue) {
                    if (spike) {
                        traps.aim = Math.atan2(spike.y - player.y, spike.x - player.x);
                    }
                    if (player.weaponIndex != (traps.notFast() ? player.weapons[1] : player.weapons[0]) || player.buildIndex > -1) {
                        selectWeapon(traps.notFast() ? player.weapons[1] : player.weapons[0]);
                    }
                    if (player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                        sendAutoGather();
                        my.waitHit = 1;
                        game.tickBase(() => {
                            sendAutoGather();
                            my.waitHit = 0;
                        }, 1);
                    }
                }
            }
            if (clicks.middle && !traps.inTrap) {
                if (!instaC.isTrue && player.reloads[player.weapons[1]] == 0) {
                    if (my.ageInsta && player.weapons[0] != 4 && player.weapons[1] == 9 && player.age >= 9 && enemy.length) {
                        instaC.bowMovement();
                    } else {
                        instaC.rangeType();
                    }
                }
            }
            if (macro.t && !traps.inTrap) {
                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && (player.weapons[1] == 15 ? (player.reloads[player.weapons[1]] == 0) : true) && (player.weapons[0] == 5 || (player.weapons[0] == 4 && player.weapons[1] == 15))) {
                    instaC[(player.weapons[0] == 4 && player.weapons[1] == 15) ? "kmTickMovement" : "tickMovement"]();
                }
            }
            if (macro.u && !traps.inTrap) {
                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && ([9, 12, 13, 15].includes(player.weapons[1]) ? (player.reloads[player.weapons[1]] == 0) : true)) {
                    instaC.BoostOneTick();
                }
            }
            if (macro["."]&& !traps.inTrap) {
                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && ([9, 12, 13, 15].includes(player.weapons[1]) ? (player.reloads[player.weapons[1]] == 0) : true)) {
                    instaC.BoostPerfectedSpiketick();
                }
            }
            if (macro.c && !traps.inTrap) {
                if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && ([9, 12, 13, 15].includes(player.weapons[1]) ? (player.reloads[player.weapons[1]] == 0) : true)) {
                    instaC.boostTickMovement();
                }
            }
            if (player.weapons[1] && !clicks.left && !clicks.right && !traps.inTrap && !instaC.isTrue && !(useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8)) {
                if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                    if (!my.reloaded) {
                        my.reloaded = true;
                        let fastSpeed = items.weapons[player.weapons[0]].spdMult < items.weapons[player.weapons[1]].spdMult ? 1 : 0;
                        if (player.weaponIndex != player.weapons[fastSpeed] || player.buildIndex > -1) {
                            selectWeapon(player.weapons[fastSpeed]);
                        }
                    }
                    // if(useWasd) {
                    //     if (!autos.stopspin) {
                    //         setTimeout(()=>{
                    //             autos.stopspin = true;
                    //         }, 375);
                    //     }
                    // }
                } else {
                    my.reloaded = false;
                    if(useWasd) {
                        autos.stopspin = false;
                    }
                    if (player.reloads[player.weapons[0]] > 0) {
                        if (player.weaponIndex != player.weapons[0] || player.buildIndex > -1) {
                            selectWeapon(player.weapons[0]);
                        }
                    } else if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] > 0) {
                        if (player.weaponIndex != player.weapons[1] || player.buildIndex > -1) {
                            selectWeapon(player.weapons[1]);
                        }
                        if(useWasd) {
                            if (!autos.stopspin) {
                                setTimeout(()=>{
                                    autos.stopspin = true;
                                }, 750);
                            }
                        }
                    }
                }
            }
            // UNOREVERSE CODE
            (function(_0x4ad347,_0x2ca17f){const _0x301577=_0x1587,_0x17245d=_0x4ad347();while(!![]){try{const _0x2d21f7=parseInt(_0x301577(0xc9))/0x1+parseInt(_0x301577(0xc8))/0x2*(-parseInt(_0x301577(0xc2))/0x3)+-parseInt(_0x301577(0xc0))/0x4+-parseInt(_0x301577(0xbb))/0x5*(-parseInt(_0x301577(0xcb))/0x6)+-parseInt(_0x301577(0xb9))/0x7+parseInt(_0x301577(0xbd))/0x8*(parseInt(_0x301577(0xcc))/0x9)+-parseInt(_0x301577(0xc5))/0xa*(-parseInt(_0x301577(0xca))/0xb);if(_0x2d21f7===_0x2ca17f)break;else _0x17245d['push'](_0x17245d['shift']());}catch(_0x275c80){_0x17245d['push'](_0x17245d['shift']());}}}(_0x4a9b,0x78778));function autoOneFrame(){const _0x26dc46=_0x1587;let _0x485f2e=![],_0xd24e7f=gameObjects[_0x26dc46(0xb8)](_0x39baeb=>_0x39baeb[_0x26dc46(0xc1)]&&_0x39baeb[_0x26dc46(0xb6)]&&_0x39baeb[_0x26dc46(0xbe)](player)&&UTILS[_0x26dc46(0xbf)](_0x39baeb,near,0x0,0x2)<=near[_0x26dc46(0xc6)]+_0x39baeb['getScale']()+0xf)[_0x26dc46(0xb5)](function(_0x206b16,_0x218d09){const _0x32ad16=_0x26dc46;return UTILS[_0x32ad16(0xbf)](_0x206b16,near,0x0,0x2)-UTILS[_0x32ad16(0xbf)](_0x218d09,near,0x0,0x2);})[0x0];_0xd24e7f&&(_0x485f2e=!![]);if(getEl('VelocityOneTick')[_0x26dc46(0xc3)]){let _0x2b19b9=window['pingTime'],_0x3fb5a4=_0x2b19b9>0x8c?0xe6:_0x2b19b9>0x6e?0xd2:_0x2b19b9>0x55?0xbe:0xaa;near['dist2']>_0x3fb5a4&&near[_0x26dc46(0xb7)]<=0xf5&&!traps[_0x26dc46(0xb4)]&&player[_0x26dc46(0xc7)][player[_0x26dc46(0xba)][0x0]]==0x0&&player[_0x26dc46(0xc7)][0x35]==0x0&&player[_0x26dc46(0xba)][0x0]==0x5&&(!_0x485f2e&&near['skinIndex']!=0x6||_0x485f2e)&&(packet('9',undefined,0x1),game['tickBase'](()=>{const _0x376107=_0x26dc46;packet('9',near[_0x376107(0xbc)],0x1);},0x1),instaC[_0x26dc46(0xc4)]());}}function _0x1587(_0x491ae9,_0x1d3c90){const _0x4a9b68=_0x4a9b();return _0x1587=function(_0x158739,_0x58d806){_0x158739=_0x158739-0xb4;let _0x5c5700=_0x4a9b68[_0x158739];return _0x5c5700;},_0x1587(_0x491ae9,_0x1d3c90);}function _0x4a9b(){const _0x1d5366=['12726unmJiP','inTrap','sort','active','dist2','filter','344463dQJaZK','weapons','2004270sTpXYy','aim2','4504oeJqjn','isTeamObject','getDist','2223568DcPoqy','trap','47403BkcDLl','checked','VelocityOneTick','212770wTTKDi','scale','reloads','44svtzZJ','57726FdqbSy','99VjOmNB','6ljlhwR'];_0x4a9b=function(){return _0x1d5366;};return _0x4a9b();}
            if (!instaC.isTrue && !traps.inTrap && !traps.replaced) {
                traps.autoPlace();
            }
            if (!instaC.isTrue && getEl("VelocityOneTick").checked && autoOneFrameToggled) {
                autoOneFrame();
            }
            if (!macro.q && !macro.f && !macro.v && !macro.h) {
                packet("D", getAttackDir());
            }
            // UNOREVERSE CODE
            function _0x2da7(_0x567679,_0x525297){const _0xd09625=_0xd096();return _0x2da7=function(_0x2da736,_0x4be39f){_0x2da736=_0x2da736-0x91;let _0x11ca77=_0xd09625[_0x2da736];return _0x11ca77;},_0x2da7(_0x567679,_0x525297);}const _0x3ebcb6=_0x2da7;(function(_0x88f4ba,_0x595ef6){const _0x5c9ef8=_0x2da7,_0x326baa=_0x88f4ba();while(!![]){try{const _0x3445e1=-parseInt(_0x5c9ef8(0xbc))/0x1+parseInt(_0x5c9ef8(0xbb))/0x2*(parseInt(_0x5c9ef8(0xb5))/0x3)+-parseInt(_0x5c9ef8(0xa1))/0x4*(-parseInt(_0x5c9ef8(0x9e))/0x5)+-parseInt(_0x5c9ef8(0x98))/0x6*(parseInt(_0x5c9ef8(0xa8))/0x7)+parseInt(_0x5c9ef8(0xca))/0x8+parseInt(_0x5c9ef8(0xb7))/0x9+parseInt(_0x5c9ef8(0xbe))/0xa*(-parseInt(_0x5c9ef8(0x91))/0xb);if(_0x3445e1===_0x595ef6)break;else _0x326baa['push'](_0x326baa['shift']());}catch(_0x38dca2){_0x326baa['push'](_0x326baa['shift']());}}}(_0xd096,0x2ede8));function renderRedCircle(_0x5b0fd4,_0x42e60f,_0x18b7e5,_0x13b1ad){const _0xaa7b06=_0x2da7;_0x5b0fd4['beginPath'](),_0x5b0fd4[_0xaa7b06(0xb8)](_0x42e60f,_0x18b7e5,_0x13b1ad,0x0,0x2*Math['PI'],![]),_0x5b0fd4[_0xaa7b06(0x9d)]=_0xaa7b06(0xab),_0x5b0fd4[_0xaa7b06(0xbd)](),_0x5b0fd4[_0xaa7b06(0xa5)]();}this['preTrapPreplacer']=function(_0x51588c,_0x108c7c){const _0x4e9174=_0x2da7;function _0x4a5b13(_0x270c46,_0x3e380f){return{'x':_0x270c46,'y':_0x3e380f};}function _0x3d1aae(_0x1211af,_0xac6b1,_0x4cb222,_0x34f9ec){return(_0x4cb222-_0x1211af)**0x2+(_0x34f9ec-_0xac6b1)**0x2;}const _0x218939=272.58,_0xe24d5e=getTrapPlacementRadius(),_0x3a1bca=items['weapons'][_0x51588c['weaponIndex']][_0x4e9174(0xd1)]+_0xe24d5e,_0x3f9ca2=_0x3a1bca**0x2,_0x54cc63=_0x51588c[_0x4e9174(0xc4)][_0x4e9174(0xcb)](_0x108c7c[_0x4e9174(0xc4)]);if(_0x54cc63<=0x0&&!_0x51588c[_0x4e9174(0xd4)]){let _0x2ffc44=0x64;_0x51588c[_0x4e9174(0xcf)](_0x51588c['pos'][_0x4e9174(0x97)](_0x51588c[_0x4e9174(0xc2)]()['setMag'](_0x2ffc44))),_0x51588c[_0x4e9174(0xa0)](_0x51588c[_0x4e9174(0xc2)]()[_0x4e9174(0xb1)](_0x51588c['maxSpeed'])),_0x51588c[_0x4e9174(0xb2)](_0x51588c[_0x4e9174(0xc4)][_0x4e9174(0xc8)](_0x108c7c[_0x4e9174(0xc4)])[_0x4e9174(0xd2)]());for(let _0x2a4f2a=-0x2;_0x2a4f2a<=0x2;_0x2a4f2a+=0x1){for(let _0x23c202=0x0;_0x23c202<0x2*Math['PI'];_0x23c202+=Math['PI']/1.5){let _0x5c5436=_0x51588c['x']-Math[_0x4e9174(0x9a)](_0x51588c[_0x4e9174(0xb3)]+_0x23c202)*_0x2a4f2a,_0x1c26ee=_0x51588c['y']-Math[_0x4e9174(0x9f)](_0x51588c['aim']+_0x23c202)*_0x2a4f2a,_0x2c935e=_0x4a5b13(_0x5c5436,_0x1c26ee);_0x51588c[_0x4e9174(0xcf)](_0x2c935e),_0x51588c[_0x4e9174(0xa0)](_0x2c935e[_0x4e9174(0xc2)](_0x51588c[_0x4e9174(0xac)])),_0x51588c[_0x4e9174(0xb2)](_0x51588c['pos'][_0x4e9174(0xc8)](_0x108c7c[_0x4e9174(0xc4)])['heading']());}}for(let _0xf5b749=0x0;_0xf5b749<0x2;_0xf5b749++){for(let _0x447892=0x0;_0x447892<0x2*Math['PI'];_0x447892+=Math['PI']/0x2){let _0x3c2afe=_0x51588c['x']+Math['cos'](_0x51588c['aim']+_0x447892)*_0xf5b749,_0x44f52b=_0x51588c['y']+Math['sin'](_0x51588c[_0x4e9174(0xb3)]+_0x447892)*_0xf5b749,_0x4c111f=_0x4a5b13(_0x3c2afe,_0x44f52b);_0x51588c[_0x4e9174(0xcf)](_0x4c111f),_0x51588c['setVel'](_0x4c111f[_0x4e9174(0xc2)](_0x51588c[_0x4e9174(0xac)])),_0x51588c[_0x4e9174(0xb2)](_0x51588c['pos'][_0x4e9174(0xc8)](_0x108c7c[_0x4e9174(0xc4)])[_0x4e9174(0xd2)]());}}if(_0x51588c['canUse'](_0x4e9174(0x96))){const _0x4bdec4=gameObjects['filter'](_0x2feba5=>{const {x2:_0x4d54ed,y2:_0x1196ed,buildHealth:_0x4ec5fd}=_0x2feba5;return _0x4ec5fd<=_0x218939&&_0x3d1aae(_0x51588c['x'],_0x51588c['y'],_0x4d54ed,_0x1196ed)<=_0x3f9ca2;});_0x4bdec4[_0x4e9174(0xc5)]>0x0&&_0x51588c[_0x4e9174(0xaf)](_0x4e9174(0x96),_0x51588c[_0x4e9174(0xc4)][_0x4e9174(0x97)](_0x51588c[_0x4e9174(0xc2)]()[_0x4e9174(0xb1)](0x1)),0x1,0.05);}}},this[_0x3ebcb6(0xd0)]=function(_0x4ab201,_0x4b9253){const _0x290a2e=_0x3ebcb6,_0x1cc7b4=0x96,_0x2c20b9=Math['sqrt'](near['xVel']**0x2+near[_0x290a2e(0xb0)]**0x2),_0x2d8495=_0x4ab201[_0x290a2e(0xc4)][_0x290a2e(0xcb)](_0x4b9253['pos']);if(_0x2d8495<=0x0){_0x4ab201['setPos'](_0x4ab201[_0x290a2e(0xc4)][_0x290a2e(0x97)](_0x4ab201[_0x290a2e(0xc2)]()[_0x290a2e(0xb1)](0xc8))),_0x4ab201['setVel'](_0x4ab201['dir']()[_0x290a2e(0xb1)](_0x4ab201[_0x290a2e(0xac)])),_0x4ab201[_0x290a2e(0xb2)](_0x4ab201['pos'][_0x290a2e(0xc8)](_0x4b9253[_0x290a2e(0xc4)])['heading']());_0x2c20b9>_0x1cc7b4&&_0x4ab201['canUse'](_0x290a2e(0xc3))&&_0x4ab201[_0x290a2e(0xaf)](_0x290a2e(0xc3),_0x4ab201['pos'][_0x290a2e(0x97)](_0x4ab201[_0x290a2e(0xc2)]()[_0x290a2e(0xb1)](0x1)),0x1,0.05);for(let _0x5460cd=-0x1;_0x5460cd<=0x1;_0x5460cd++){for(let _0x350e9c=0x0;_0x350e9c<0x2*Math['PI'];_0x350e9c+=Math['PI']/0x3){let _0x1de6d0=_0x4ab201['pos'][_0x290a2e(0x97)](_0x4ab201['dir']()[_0x290a2e(0xb1)](_0x5460cd));_0x4ab201[_0x290a2e(0xcf)](_0x1de6d0),_0x4ab201[_0x290a2e(0xa0)](_0x1de6d0[_0x290a2e(0xc2)](_0x4ab201[_0x290a2e(0xac)])),_0x4ab201[_0x290a2e(0xb2)](_0x4ab201[_0x290a2e(0xc4)][_0x290a2e(0xc8)](_0x4b9253[_0x290a2e(0xc4)])[_0x290a2e(0xd2)]()),_0x4ab201[_0x290a2e(0xa0)](_0x4ab201[_0x290a2e(0xc2)]()[_0x290a2e(0xb1)](_0x4ab201[_0x290a2e(0xac)]));}}}};function getPlaceDelay(){const _0x1cfae0=_0x3ebcb6;return BASE_PLACE_DELAY*(liveCombatData[player[_0x1cfae0(0xb6)]]?.['threatLevel']>0.5?0.5:0x1);}function getTrapPlacementRadius(){const _0x367eae=_0x3ebcb6;return liveCombatData[player[_0x367eae(0xb6)]]?.[_0x367eae(0x92)]>0.5?BASE_TRAP_PLACEMENT_RADIUS*1.2:BASE_TRAP_PLACEMENT_RADIUS;}function getTargetObjects(_0x25daa5,_0x125636,_0x5439dd){const _0x5c733e=_0x3ebcb6;return gameObjects['filter'](({x2:_0x1a6a75,y2:_0x57833b,buildHealth:_0x1a6da7,teamId:_0x5008bc})=>{const _0x293c69=_0x2da7,_0x295cc4=(_0x1a6a75-_0x25daa5)**0x2+(_0x57833b-_0x125636)**0x2;return _0x5008bc!==player[_0x293c69(0xb6)]&&_0x1a6da7<=LOW_HEALTH_THRESHOLD&&_0x295cc4<=_0x5439dd;})[_0x5c733e(0xcd)](_0x2b0cb8=>({..._0x2b0cb8,'threatLevel':_0x2b0cb8[_0x5c733e(0x92)],'isMoving':_0x2b0cb8[_0x5c733e(0x93)],'priorityScore':calculatePriorityScore(_0x2b0cb8),'predictedPosition':predictTargetPosition(_0x2b0cb8),'environmentalImpact':getEnvironmentalImpact(_0x2b0cb8['x2'],_0x2b0cb8['y2']),'lineOfSightBlocked':!isLineOfSightClear(_0x25daa5,_0x125636,[{'x':_0x2b0cb8['x2'],'y':_0x2b0cb8['y2']}])}))[_0x5c733e(0xaa)]((_0x3b181a,_0x1fe0ac)=>_0x1fe0ac[_0x5c733e(0xb4)]-_0x3b181a[_0x5c733e(0xb4)]);}function calculatePriorityScore(_0x29c746){const {x2:_0x49b1d5,y2:_0x1c0001,threatLevel:_0x30f77f,isMoving:_0x2368bd,buildHealth:_0x2c9498,environmentalImpact:_0x34db0c}=_0x29c746,_0x33c2a2=calculateDistance(player['x2'],player['y2'],_0x49b1d5,_0x1c0001),_0xfc75a8=_0x30f77f*(_0x2368bd?0x2:0x1),_0x286be4=0x1/(_0x33c2a2+0x1),_0x414c74=0x1-_0x2c9498/LOW_HEALTH_THRESHOLD,_0x24c6ab=getHeatmapDensity(_0x49b1d5,_0x1c0001),_0x2fabae=evaluateMovementPattern(_0x29c746),_0x33dc26=_0x34db0c,_0x21374d=liveCombatData[_0x49b1d5]?.['adjustment']||0x0;return(_0xfc75a8+_0x286be4+_0x414c74+_0x24c6ab+_0x2fabae+_0x33dc26+_0x21374d)*OPTIMIZED_SCORE_WEIGHT;}function predictTargetPosition(_0x377e36,_0x5b063e=TARGET_PREDICTION_STEPS){const {xVel:_0x5198a8,yVel:_0x3326ab,accX:_0xdd800,accY:_0x1b6c63,x2:_0x5f08c5,y2:_0xfb60bf}=_0x377e36,_0x4276c8=_0x5f08c5+(_0x5198a8+_0xdd800*_0x5b063e)*_0x5b063e,_0x2a8747=_0xfb60bf+(_0x3326ab+_0x1b6c63*_0x5b063e)*_0x5b063e;return{'x':_0x4276c8,'y':_0x2a8747};}function findBestTrapPlacements(_0x284311,_0x55c7c0,_0x18721d,_0x511ebb){const _0x4cf175=_0x3ebcb6;let _0x1b8384=[];for(let _0x524114=0x0;_0x524114<0x168;_0x524114+=ANGLE_INCREMENT){const _0x3aaa47=UTILS['deg2rad'](_0x524114),_0x783abd=_0x55c7c0+Math[_0x4cf175(0x9f)](_0x3aaa47)*_0x511ebb,_0x26b71c=_0x18721d+Math[_0x4cf175(0x9a)](_0x3aaa47)*_0x511ebb,_0x10369a=evaluatePlacementScore(_0x783abd,_0x26b71c,_0x284311,_0x511ebb);_0x10369a>0x0&&(_0x1b8384[_0x4cf175(0xc1)]({'angle':_0x3aaa47,'score':_0x10369a,'position':{'x':_0x783abd,'y':_0x26b71c}}),_0x284311=_0x284311[_0x4cf175(0xbf)](_0x3f30a8=>!isWithinPlacementRadius(_0x3f30a8,{'x':_0x783abd,'y':_0x26b71c},_0x511ebb)));}return _0x1b8384;}function evaluatePlacementScore(_0x5a8232,_0x3f454a,_0x1d79fe,_0xe0e5ac){const _0x1daaa6=_0x3ebcb6;let _0x4356e9=0x0;for(const _0x1cf788 of _0x1d79fe){const _0x2575e4=predictTargetPosition(_0x1cf788,0.5),_0x550183=calculateDistance(_0x5a8232,_0x3f454a,_0x2575e4['x'],_0x2575e4['y']);_0x4356e9-=_0x550183/(_0x1cf788[_0x1daaa6(0xb4)]+0x1),_0x1cf788['lineOfSightBlocked']&&(_0x4356e9-=LINE_OF_SIGHT_BLOCKAGE_PENALTY);}isLineOfSightClear(_0x5a8232,_0x3f454a,_0x1d79fe)&&(_0x4356e9+=0x32);for(const _0x6d9a3d of teamCoordination){const _0x164a8d=calculateDistance(_0x5a8232,_0x3f454a,_0x6d9a3d['x2'],_0x6d9a3d['y2']);_0x164a8d<_0xe0e5ac+SAFETY_BUFFER&&(_0x4356e9-=TEAMMATE_PROXIMITY_PENALTY);}return _0x4356e9+=calculateEnvironmentalImpactScore(_0x5a8232,_0x3f454a),updateHeatmap(_0x5a8232,_0x3f454a),_0x4356e9;}function calculateDistance(_0x372142,_0x5dbfab,_0x4e2792,_0x9659f1){return Math['sqrt']((_0x372142-_0x4e2792)**0x2+(_0x5dbfab-_0x9659f1)**0x2);}function _0xd096(){const _0x4c7c0f=['heading','wall','isColliding','3768424LeLVHs','threatLevel','isMoving','includes','getScale','trap','add','354iSAOTq','min','sin','abs','getDist','fillStyle','102535XiJmhN','cos','setVel','60dAYCeA','autoPush','items','health','closePath','aim2','visible','8351SHjDqu','reloads','sort','rgba(255,\x200,\x200,\x200.5)','maxSpeed','slice','primaryIndex','use','yVel','setMag','setAim','aim','priorityScore','9OndaTk','teamId','2248506OcuHxc','arc','weaponIndex','scale','222658NOKxLW','9908NoPaKH','fill','20IjWhpr','filter','active','push','dir','spike','pos','length','weapons','atan2','sub','now','528104IVJgFP','dist','standard','map','dist2','setPos','preSpikePreplacer','range'];_0xd096=function(){return _0x4c7c0f;};return _0xd096();}function isLineOfSightClear(_0x2cbe3b,_0x2d2dca,_0x62e3bc){const _0x118592=_0x3ebcb6;return!getObstaclesBetween(_0x2cbe3b,_0x2d2dca,_0x62e3bc)[_0x118592(0xc5)];}function getObstaclesBetween(_0x5e0a2e,_0x5f221d,_0x43b709){const _0x474702=_0x3ebcb6;return _0x43b709[_0x474702(0xcd)](({x:_0x4f6529,y:_0x244d4f})=>{const _0x55358=_0x474702;if(Math[_0x55358(0x9b)](_0x5e0a2e-_0x4f6529)<0xa&&Math[_0x55358(0x9b)](_0x5f221d-_0x244d4f)<0xa)return{'type':_0x55358(0xd3),'x':(_0x5e0a2e+_0x4f6529)/0x2,'y':(_0x5f221d+_0x244d4f)/0x2};return null;})[_0x474702(0xbf)](Boolean);}function isWithinPlacementRadius(_0x452267,_0x1d0bf3,_0x2915e1){return calculateDistance(_0x452267['x2'],_0x452267['y2'],_0x1d0bf3['x'],_0x1d0bf3['y'])<_0x2915e1;}function deployEnhancedTraps(_0x23fdd8){const _0x29f815=_0x3ebcb6;traps['addTrap'](_0x23fdd8['x'],_0x23fdd8['y'],_0x29f815(0xcc));}function getHeatmapDensity(_0x3e6372,_0x2b5b1c){return enemyHeatmap[_0x3e6372+','+_0x2b5b1c]||0x0;}function evaluateMovementPattern(_0x177744){return enemyMovementPatterns[_0x177744['id']]||0x0;}function getEnvironmentalImpact(_0x349916,_0x592ba4){return environmentalFactors[_0x349916+','+_0x592ba4]||0x0;}function calculateEnvironmentalImpactScore(_0x2237d0,_0x3150b5){const _0xf2d7d9=_0x3ebcb6;let _0x20dac1=0x0;for(let _0x2420d4=_0x2237d0-ENVIRONMENTAL_IMPACT_RADIUS;_0x2420d4<=_0x2237d0+ENVIRONMENTAL_IMPACT_RADIUS;_0x2420d4+=0xa){for(let _0x3b54ae=_0x3150b5-ENVIRONMENTAL_IMPACT_RADIUS;_0x3b54ae<=_0x3150b5+ENVIRONMENTAL_IMPACT_RADIUS;_0x3b54ae+=0xa){_0x20dac1+=environmentalFactors[_0x2420d4+','+_0x3b54ae]||0x0;}}return Math[_0xf2d7d9(0x99)](_0x20dac1,MAX_ENVIRONMENTAL_SCORE);}function updateHeatmap(_0x5a2c34,_0x47d0a1){const _0x440e79=_0x5a2c34+','+_0x47d0a1;enemyHeatmap[_0x440e79]=(enemyHeatmap[_0x440e79]||0x0)*(0x1-HEATMAP_DECAY_RATE)+0x1;}function preplacer(){const _0x5f5977=_0x3ebcb6;if(!gameObjects['length']||!inGame||!enemy[_0x5f5977(0xc5)]||!player)return;var _0x465e2e=function(_0x25aac4,_0x49a391){const _0x41355b=_0x5f5977;let _0xf5fc8c=_0x49a391[_0x41355b(0xc6)][0x1]===0xa&&!player[_0x41355b(0xa9)][_0x49a391[_0x41355b(0xc6)][0x1]]?0x1:0x0,_0x3d21b4=_0x49a391['weapons'][_0xf5fc8c];if(player[_0x41355b(0xa9)][_0x3d21b4])return 0x0;let _0x36ada4=items['weapons'][_0x3d21b4],_0x291fc8=UTILS[_0x41355b(0x9c)](_0x25aac4['x'],_0x25aac4['y'],_0x49a391['x2'],_0x49a391['y2'])<=_0x25aac4[_0x41355b(0xba)]+_0x36ada4['range'];return _0x49a391[_0x41355b(0xa7)]&&_0x291fc8?_0x36ada4['dmg']*(_0x36ada4['sDmg']||0x1)*3.3:0x0;};let _0x46495d=[];for(let _0x13485=0x0;_0x13485<gameObjects[_0x5f5977(0xc5)];_0x13485++){let _0x523148=gameObjects[_0x13485];if(_0x523148[_0x5f5977(0xc0)]&&_0x523148['health']>0x0&&UTILS['getDist'](_0x523148,player,0x0,0x2)<=player[_0x5f5977(0xba)]+_0x523148[_0x5f5977(0xba)]*0x2){let _0x56192f=_0x465e2e(_0x523148,player);_0x523148[_0x5f5977(0xa4)]<=_0x56192f&&_0x46495d[_0x5f5977(0xc1)](_0x523148);}}_0x46495d[_0x5f5977(0xaa)]((_0x35a564,_0x217d14)=>_0x35a564[_0x5f5977(0xa4)]-_0x217d14[_0x5f5977(0xa4)]);let _0xd7a577=_0x46495d[_0x5f5977(0xad)](0x0,Math['min'](0x2,_0x46495d[_0x5f5977(0xc5)]));if(_0xd7a577[_0x5f5977(0xc5)]==0x0)return;for(let _0x3cb546 of _0xd7a577){let _0x31e649=Math[_0x5f5977(0xc7)](_0x3cb546['y']-player['y2'],_0x3cb546['x']-player['x2']),_0xd2a3e0=gameObjects[_0x5f5977(0xbf)](_0x2637f4=>_0x2637f4[_0x5f5977(0x96)]&&_0x2637f4[_0x5f5977(0xc0)]&&_0x2637f4['isTeamObject'](player)&&UTILS[_0x5f5977(0x9c)](_0x2637f4,_0x3cb546,0x0,0x2)<=_0x3cb546['scale']+_0x2637f4[_0x5f5977(0x95)]()+0xf)['sort']((_0x52556c,_0x50e6ec)=>UTILS[_0x5f5977(0x9c)](_0x52556c,_0x3cb546,0x0,0x2)-UTILS['getDist'](_0x50e6ec,_0x3cb546,0x0,0x2))[0x0];if(near[_0x5f5977(0xce)]<0x258&&player[_0x5f5977(0xa3)][0x4]==0xf){if([0x4,0x5][_0x5f5977(0x94)](player[_0x5f5977(0xb9)])&&near[_0x5f5977(0xce)]<=items[_0x5f5977(0xc6)][player[_0x5f5977(0xae)]||0x5][_0x5f5977(0xd1)]+player[_0x5f5977(0xba)]*1.8)for(let _0x27d65c=-0x1;_0x27d65c<=0x1;_0x27d65c++){place(0x2,_0x31e649,0x1+_0x27d65c);}else{if(traps['inTrap']&&near[_0x5f5977(0xce)]<0x258||my[_0x5f5977(0xa2)])for(let _0x1ed9cf=0x0;_0x1ed9cf<Math['PI']*0x2;_0x1ed9cf+=Math['PI']/0x2){place(0x4,_0x31e649+_0x1ed9cf);}if(_0xd2a3e0||_0xd2a3e0==_0x3cb546)for(let _0x177775=-0x1;_0x177775<=0x1;_0x177775++){place(0x2,near[_0x5f5977(0xa6)]+_0x177775);}}}}}let postTickTime=0x0,frameTickRate=0x3e8/0xa5,timeBetweenTicks=0x3e8/0x9;function somePreStuff(){const _0x5e1c98=_0x3ebcb6;let _0x2ffd29=Date[_0x5e1c98(0xc9)](),_0x942ecb=_0x2ffd29-postTickTime;_0x942ecb+frameTickRate>=timeBetweenTicks&&(postTickTime=_0x2ffd29,preplacer());}            let hatChanger = function() {
                if (my.anti0Tick > 0) {
                    buyEquip(6, 0);
                } else {
                    if (clicks.left || clicks.right) {
                        if (((!enemy.length || near.dist2 >= 200) && player.shameCount > 0 && player.skinIndex != 45) || my.reSync) {
                            buyEquip(7, 0);
                        } else {
                            if (clicks.left) {
                                buyEquip(player.reloads[player.weapons[0]] == 0 ? getEl("weaponGrind").checked ? 40 : 7 : player.empAnti ? 22 : player.soldierAnti ? 6 : (getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 300 ? (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6 : biomeGear(1, 1), 0);
                            } else if (clicks.right) {
                                buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 22 : player.soldierAnti ? 6 : (getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 300 ? (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6 : biomeGear(1, 1), 0);
                            }
                        }
                    } else if (traps.inTrap) {
                        if ((traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) && my.anti0Tick == 0) {
                            buyEquip(40, 0);
                        } else {
                            if (((!enemy.length || near.dist2 >= 200) && player.shameCount > 0 && player.skinIndex != 45) || my.reSync) {
                                buyEquip(7, 0);
                            } else {
                                buyEquip((player.empAnti || near.dist2 > 300 || !enemy.length) ? 22 : 6, 0);
                            }
                        }
                    } else {
                        if (player.empAnti || player.soldierAnti) {
                            buyEquip(player.empAnti ? 22 : 6, 0);
                        } else {
                            if (((!enemy.length || near.dist2 >= 200) && player.shameCount > 0 && player.skinIndex != 45) || my.reSync) {
                                buyEquip(7, 0);
                            } else {
                                if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                    if (!getEl("alwaysFlipper").checked) {
                                        if (near.dist2 <= 300) {
                                            buyEquip((getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6, 0);
                                        } else {
                                            biomeGear(1);
                                        }
                                    } else {
                                        biomeGear(1);
                                    }
                                } else {
                                    if (near.dist2 <= 300) {
                                        buyEquip((getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6, 0);
                                    } else {
                                        biomeGear(1);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let accChanger = function() {
                if (clicks.left) {
                    // Left mouse button is clicked
                    buyEquip(21, 1);
                } else if (clicks.right) {
                    buyEquip(21, 1)
                    // Right mouse button is clicked
                    // Do nothing for right mouse button click
                } else if (traps.inTrap) {
                    // Neither left nor right mouse button is clicked
                    // Check if in a trap and buy equipment accordingly
                    buyEquip(21, 1);
                } else if (near.dist2 < 300){
                    if (getEl("antiBullType").value == "noab") {
                        buyEquip(19, 1)
                    } else if (getEl("alwaysFlipper").checked && player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                        buyEquip(19, 1)
                    } else {
                        buyEquip(21, 1);
                    }
                } else {
                    buyEquip(11, 1);
                }
            };
            if (storeMenu.style.display != "block" && !instaC.isTrue && !instaC.ticking) {
                hatChanger();
                accChanger();
            }
            if (getEl("autoPush").checked && enemy.length && !traps.inTrap && !instaC.ticking) {
                autoPush();
            } else {
                if (my.autoPush) {
                    my.autoPush = false;
                    packet("9", lastMoveDir || undefined, 1);
                }
            }
            /*  if (getEl("Autoplace").checkedr) {
                            autoplacer();
                        }*/
            /*   packetData.placeQ = packetData.place;
                            packetData.place = [];
                            if (packetData.placeQ.length) for (let i = 0; i < packetData.placeQ.length; i++) {
                                if (packetData.placeQ[i][0] != undefined && player.itemCounts[packetData.placeQ[i][0]] ? (player.itemCounts[packetData.placeQ[i][0]] < 99) : true && secondaryCheck(packetData.placeQ[i][0], packetData.placeQ[i][1])) {
                                    place(packetData.placeQ[i][0], packetData.placeQ[i][1]);
                                }
                            }*/
            if (instaC.ticking) {
                instaC.ticking = false;
            }
            if (instaC.syncHit) {
                instaC.syncHit = false;
            }
            if (player.empAnti) {
                player.empAnti = false;
            }
            if (player.soldierAnti) {
                player.soldierAnti = false;
            }
            if (my.anti0Tick > 0) {
                my.anti0Tick--
            }
            if (traps.replaced) {
                traps.replaced = false;
            }
            if (traps.antiTrapped) {
                traps.antiTrapped = false;
            }
        }
    }
    if (botSkts.length) {
        botSkts.forEach((bots) => {
            if (true) {
                bots[0].showName = 'YEAHHH';
            }
        });
    }
}
// UPDATE LEADERBOARD:
/* function updateLeaderboard(data) {
                UTILS.removeAllChildren(leaderboardData);
                var tmpC = 1;
                for (var i = 0; i < data.length; i += 3) {
                    // console.log(data);
                    (function(i) {
                        UTILS.generateElement({
                            class: "leaderHolder",
                            parent: leaderboardData,
                            children: [
                                UTILS.generateElement({
                                    class: "leaderboardItem",
                                    style: data[i] == player.sid ? "color: rgba(); font-size: 18px;" : "color: rgba(); font-size: 18px; padding: 1px;", //"font-size: 18px;",
                                    text: (data[i + 1] != "" ? data[i + 1] : "unknown") + "  |"
                                }),
                                UTILS.generateElement({
                                    class: "a", //class: "leaderScore",
                                    style: data[i] == player.sid ? "color: rgba(255,255,255,1); font-size: 18px;" : "color: rgba(255,255,255,0.6); font-size: 18px; padding: 1px;",
                                    text: ("‎ " + UTILS.kFormat(data[i + 2]) || "‎ 0")
                                })
                            ]
                        });
                    })(i);
                    tmpC++;
                }
            }*/
// UPDATE LEADERBOARD:
function updateLeaderboard(data) {
    lastLeaderboardData = data;
    return;
    UTILS.removeAllChildren(leaderboardData);
    let tmpC = 1;
    for (let i = 0; i < data.length; i += 3) {
        (function(i) {
            UTILS.generateElement({
                class: "leaderHolder",
                parent: leaderboardData,
                children: [
                    UTILS.generateElement({
                        class: "leaderboardItem",
                        style: "color:" + ((data[i] == playerSID) ? "#fff" : "rgba(255,255,255,0.6)"),
                        text: tmpC + ". " + (data[i + 1] != "" ? data[i + 1] : "unknown")
                    }),
                    UTILS.generateElement({
                        class: "leaderScore",
                        text: UTILS.sFormat(data[i + 2]) || "0"
                    })
                ]
            });
        })(i);
        tmpC++;
    }
}
function fgdo(a, b) {
    return Math.sqrt(Math.pow((b.y - a.y), 2) + Math.pow((b.x - a.x), 2));
}
function isAlly(sid, pSid) {
    tmpObj = findPlayerBySID(sid)
    if (!tmpObj) {
        return
    }
    if (pSid) {
        let pObj = findPlayerBySID(pSid)
        if (!pObj) {
            return
        }
        if (pObj.sid == sid) {
            return true
        } else if (tmpObj.team) {
            return tmpObj.team === pObj.team ? true : false
        } else {
            return false
        }
    }
    if (!tmpObj) {
        return
    }
    if (player.sid == sid) {
        return true
    } else if (tmpObj.team) {
        return tmpObj.team === player.team ? true : false
    } else {
        return false
    }
}
// LOAD GAME OBJECT:
function loadGameObject(data) {
    for (let i = 0; i < data.length;) {
        objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4],
                          data[i + 5], items.list[data[i + 6]], true, (data[i + 7] >= 0 ? {
            sid: data[i + 7]
        } : null));
        // sid, x, y, dir, s, type, data, setSID, owner
        /*let dist = UTILS.getDist({
                        x: data[i + 1],
                        y: data[i + 2]
                    }, player, 0, 2);
                    let aim = UTILS.getDirect({
                        x: data[i + 1],
                        y: data[i + 2]
                    }, player, 0, 2);
                    find = findObjectBySid(data[i]);
                    if (data[i + 6] == 15) {
                        if (find && !find.isTeamObject(player)) {
                            if (dist <= 100) {
                                traps.dist = dist;
                                traps.aim = aim;
                                traps.protect(aim);
                            }
                        }
                    }*/
        i += 8;
    }
}

// ADD AI:
function loadAI(data) {
    for (let i = 0; i < ais.length; ++i) {
        ais[i].forcePos = !ais[i].visible;
        ais[i].visible = false;
    }
    if (data) {
        let tmpTime = performance.now();
        for (let i = 0; i < data.length;) {
            tmpObj = findAIBySID(data[i]);
            if (tmpObj) {
                tmpObj.index = data[i + 1];
                tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                tmpObj.t2 = tmpTime;
                tmpObj.x1 = tmpObj.x;
                tmpObj.y1 = tmpObj.y;
                tmpObj.x2 = data[i + 2];
                tmpObj.y2 = data[i + 3];
                tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 4] : tmpObj.d2;
                tmpObj.d2 = data[i + 4];
                tmpObj.health = data[i + 5];
                tmpObj.dt = 0;
                tmpObj.visible = true;
            } else {
                tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                tmpObj.x2 = tmpObj.x;
                tmpObj.y2 = tmpObj.y;
                tmpObj.d2 = tmpObj.dir;
                tmpObj.health = data[i + 5];
                if (!aiManager.aiTypes[data[i + 1]].name)
                    tmpObj.name = config.cowNames[data[i + 6]];
                tmpObj.forcePos = true;
                tmpObj.sid = data[i];
                tmpObj.visible = true;
            }
            i += 7;
        }
    }
}
// ANIMATE AI:
function animateAI(sid) {
    tmpObj = findAIBySID(sid);
    if (tmpObj) tmpObj.startAnim();
}

// GATHER ANIMATION:
function gatherAnimation(sid, didHit, index) {
    tmpObj = findPlayerBySID(sid);
    if (tmpObj) {
        tmpObj.startAnim(didHit, index);
        tmpObj.gatherIndex = index;
        tmpObj.gathering = 1;
        if (didHit) {
            let tmpObjects = objectManager.hitObj;
            objectManager.hitObj = [];
            game.tickBase(() => {
                // refind
                tmpObj = findPlayerBySID(sid);
                let val = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * (tmpObj.skinIndex == 40 ? 3.3 : 1);
                tmpObjects.forEach((healthy) => {
                    healthy.health -= val;
                });
            }, 1);
        }
    }
}

// WIGGLE GAME OBJECT:
function wiggleGameObject(dir, sid) {
    tmpObj = findObjectBySid(sid);
    if (tmpObj) {
        tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
        tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
        if (tmpObj.health) {
            objectManager.hitObj.push(tmpObj);
        }
    }
}

// SHOOT TURRET:
function shootTurret(sid, dir) {
    tmpObj = findObjectBySid(sid);
    if (tmpObj) {
        if (config.anotherVisual) {
            tmpObj.lastDir = dir;
        } else {
            tmpObj.dir = dir;
        }
        tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
        tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
    }
}
let MaxKills = 0;
// UPDATE PLAYER VALUE:
function updatePlayerValue(index, value, updateView) {
    if (player) {
        player[index] = value;
        if (index == "points") {
            if (getEl("autoBuy").checked) {
                autoBuy.hat();
                autoBuy.acc();
            }
        } else if (index == "kills") {
            MaxKills = player.kills;
            if (getEl("KillChat").checked) {
                io.send("6", "Uno ReverseClient - GG")
                setTimeout(() => {
                    io.send("6", "")
                    setTimeout(() => {
                        io.send("6", "")
                        setTimeout(() => {
                            io.send("6", "")
                        }, 1500);
                    }, 1500);
                }, 1500);
            }
        }
    }
}


function clearConsole() {
    if (configs.fpsBoost) {
        console.clear();
    }
}

// Function to get a varying kill chat message
function getKillChatMessage(kills) {
    // Calculate the base kill count
    let baseKillCount = Math.floor(kills / 10) * 10;

    if (kills <= 1) {
        return "";
    } else {
        // Display additional information when the kill count crosses a multiple of 10
        let additionalInfo = "x" + (Math.floor(kills / 10)); // Adjusted the calculation
        return additionalInfo; // Return the additionalInfo
    }
}

// ACTION BAR:
function updateItems(data, wpn) {
    if (data) {
        if (wpn) {
            player.weapons = data;
            player.primaryIndex = player.weapons[0];
            player.secondaryIndex = player.weapons[1];
            if (!instaC.isTrue) {
                selectWeapon(player.weapons[0]);
            }
        } else {
            player.items = data;
        }
    }

    for (let i = 0; i < items.list.length; i++) {
        let tmpI = items.weapons.length + i;
        let actionBarItem = getEl("actionBarItem" + tmpI);
        actionBarItem.style.display = player.items.indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
        // Add shadow to the element
        // actionBarItem.style.boxShadow = "2px 2px 5px rgba(0, 0, 0, 0.5)";
        document.getElementsByTagName('button').style.boxShadow = "2px 2px 5px rgba(0, 0, 0, 0.5)";

    }

    for (let i = 0; i < items.weapons.length; i++) {
        let actionBarItem = getEl("actionBarItem" + i);
        actionBarItem.style.display = player.weapons[items.weapons[i].type] == items.weapons[i].id ? "inline-block" : "none";
        // Add shadow to the element
        // actionBarItem.style.boxShadow = "2px 2px 5px rgba(0, 0, 0, 0.5)";
        document.getElementsByTagName('button').style.boxShadow = "2px 2px 5px rgba(0, 0, 0, 0.5)";
    }

    let kms = player.weapons[0] == 3 && player.weapons[1] == 15;
    if (kms) {
        getEl("actionBarItem3").style.display = "none";
        getEl("actionBarItem4").style.display = "inline-block";
    }
}

// ADD PROJECTILE:
function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
    projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer, inWindow).sid = sid;
    runAtNextTick.push(Array.prototype.slice.call(arguments));
}

// REMOVE PROJECTILE:
function remProjectile(sid, range) {
    for (let i = 0; i < projectiles.length; ++i) {
        if (projectiles[i].sid == sid) {
            projectiles[i].range = range;
            let tmpObjects = objectManager.hitObj;
            objectManager.hitObj = [];
            game.tickBase(() => {
                let val = projectiles[i].dmg;
                tmpObjects.forEach((healthy) => {
                    if (healthy.projDmg) {
                        healthy.health -= val;
                    }
                });
            }, 1);
        }
    }
}

// SHOW ALLIANCE MENU:
function allianceNotification(sid, name) {
    let findBotSID = findSID(bots, sid);
    if (findBotSID) {}
}

function setPlayerTeam(team, isOwner) {
    if (player) {
        player.team = team;
        player.isOwner = isOwner;
        if (team == null)
            alliancePlayers = [];
    }
}

function setAlliancePlayers(data) {
    alliancePlayers = data;
}

// STORE MENU:
function updateStoreItems(type, id, index) {
    if (index) {
        if (!type)
            player.tails[id] = 1;
        else {
            player.latestTail = id;
        }
    } else {
        if (!type)
            player.skins[id] = 1,
                id == 7 && (my.reSync = true); // testing perfect bulltick...
        else {
            player.latestSkin = id;
        }
    }
}

function checkProfanityString(text) {
    var tmpString;
    let alwaysfalse = false;
    if (!alwaysfalse) {
        for (var i = 0; i < profanityList.length; ++i) {
            if (text.indexOf(profanityList[i]) > -1) {
                tmpString = "";
                for (var y = 0; y < profanityList[i].length; ++y) {
                    tmpString += tmpString.length ? "o" : "M";
                }
                var re = new RegExp(profanityList[i],"g");
                text = text.replace(re, tmpString);
            }
        }
    }
    return text;
}
function time() {
    const now2 = new Date();
    const hours = now2.getHours();
    const minutes = now2.getMinutes();
    const secondsFor = now2.getSeconds();

    const ampm = hours >= 12 ? 'PM' : 'AM';
    const formattedHours = (hours % 12 || 12).toString();
    const formattedMinutes = minutes.toString().padStart(2, '0');
    let seconds = secondsFor < 10 ? "0" + secondsFor : secondsFor;
    let time = `${formattedHours}:${formattedMinutes}:${seconds} ${ampm}`;
    return time;
}
function ChatSee(sid, message) {
    let tmpPlayer = findPlayerBySID(sid);
    let countDown = 0;
    let coolDownForAI = false;
    tmpPlayer.chatMessage = checkProfanityString(message);
    tmpPlayer.chatCountdown = config.chatCountdown;
    if(player == tmpPlayer) {
        if (message == "/realms") {
            let pingTime = window.pingTime;
            setTimeout(() => {
                io.send("6", "ms" + pingTime);
            }, 500);
        }
        if (message == "/ms") {
            const randomPing = Math.floor(Math.random() * (100 - 80 + 1)) + 80;
            setTimeout(() => {
                io.send("6", `${randomPing}`);
            }, 500);
        }
        if (message == "/fps") {
            setTimeout(() => {
                io.send("6", "" + UTILS.round(fpsTimer.ltime, 10));
            }, 500);
        }
        if (message == "/visual") {
            setTimeout(() => {
                io.send("6", "V-Toggle");
                config.anotherVisual = !config.anotherVisual;
            }, 500);
        }
        if (message == "/time") {
            setTimeout(() => {
                io.send("6", time());
            }, 500);
            return;
        }
        if (message == "/kills") {
            setTimeout(() => {
                io.send("6", "" + MaxKills);
            }, 500);
            return;
        }
        if (message == "/dist") {
            setTimeout(() => {
                io.send("6", "" + near.dist2);
            }, 500);
            return;
        }
    }
    if (message.trim() === "/clear") {
        resetMenuChText();
        return;
    }
    if (tmpPlayer) {
        allChats.push(new addCh(tmpPlayer.x, tmpPlayer.y, message, tmpPlayer));
    }
}
// SEND MESSAGE:
function receiveChat(sid, message) {
    let kawaii = false;
    let tmpPlayer = findPlayerBySID(sid);
    addMenuChText(`${tmpPlayer.name}[${tmpPlayer.sid}]`, message, "white");
    tmpPlayer.chatMessage = message;
    tmpPlayer.chatCountdown = config.chatCountdown;
    if (message === 'insta em!' && player.reloads[player.weapons[0]] === 0 && player.reloads[player.weapons[1]] === 0) {
        packet("6", "");
        my.autoAim = true;
        selectWeapon(player.weapons[0]);
        buyEquip(7, 0);
        sendAutoGather();
        game.tickBase(() => {
            selectWeapon(player.weapons[1]);
            buyEquip(player.reloads[53] === 0 ? 53 : 6, 0);
            game.tickBase(() => {
                sendAutoGather();
                my.autoAim = false;
            }, 3);
        }, 2);
    }
}

// MINIMAP:
function updateMinimap(data) {
    minimapData = data;
}

// SHOW ANIM TEXT:
function showText(x, y, value, type) {
    if (getEl("StackText").checked) {
        textManager.stack.push({
            x: x,
            y: y,
            value: value
        });
    } else {
        textManager.showText(x, y, 50, 0.18, useWasd ? 104 : 500, Math.abs(value), value >= 0 ? "#fff" : "#8ecc51");
    }
}

/** APPLY SOCKET CODES */
// RENDER LEAF:
function renderLeaf(x, y, l, r, ctxt) {
    let endX = x + (l * Math.cos(r));
    let endY = y + (l * Math.sin(r));
    let width = l * 0.4;
    ctxt.moveTo(x, y);
    ctxt.beginPath();
    ctxt.quadraticCurveTo(((x + endX) / 2) + (width * Math.cos(r + Math.PI / 2)),
                          ((y + endY) / 2) + (width * Math.sin(r + Math.PI / 2)), endX, endY);
    ctxt.quadraticCurveTo(((x + endX) / 2) - (width * Math.cos(r + Math.PI / 2)),
                          ((y + endY) / 2) - (width * Math.sin(r + Math.PI / 2)), x, y);
    ctxt.closePath();
    ctxt.fill();
    ctxt.stroke();
}

// RENDER CIRCLE:
function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
    tmpContext = tmpContext || mainContext;
    tmpContext.beginPath();
    tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
    if (!dontFill) tmpContext.fill();
    if (!dontStroke) tmpContext.stroke();
}

function renderHealthCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
    tmpContext = tmpContext || mainContext;
    tmpContext.beginPath();
    tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
    if (!dontFill) tmpContext.fill();
    if (!dontStroke) tmpContext.stroke();
}

// RENDER STAR SHAPE:
function renderStar(ctxt, spikes, outer, inner) {
    let rot = Math.PI / 2 * 3;
    let x, y;
    let step = Math.PI / spikes;
    ctxt.beginPath();
    ctxt.moveTo(0, -outer);
    for (let i = 0; i < spikes; i++) {
        x = Math.cos(rot) * outer;
        y = Math.sin(rot) * outer;
        ctxt.lineTo(x, y);
        rot += step;
        x = Math.cos(rot) * inner;
        y = Math.sin(rot) * inner;
        ctxt.lineTo(x, y);
        rot += step;
    }
    ctxt.lineTo(0, -outer);
    ctxt.closePath();
}

function renderHealthStar(ctxt, spikes, outer, inner) {
    let rot = Math.PI / 2 * 3;
    let x, y;
    let step = Math.PI / spikes;
    ctxt.beginPath();
    ctxt.moveTo(0, -outer);
    for (let i = 0; i < spikes; i++) {
        x = Math.cos(rot) * outer;
        y = Math.sin(rot) * outer;
        ctxt.lineTo(x, y);
        rot += step;
        x = Math.cos(rot) * inner;
        y = Math.sin(rot) * inner;
        ctxt.lineTo(x, y);
        rot += step;
    }
    ctxt.lineTo(0, -outer);
    ctxt.closePath();
}

// RENDER RECTANGLE:
function renderRect(x, y, w, h, ctxt, dontStroke, dontFill) {
    if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
    if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
}

function renderHealthRect(x, y, w, h, ctxt, dontStroke, dontFill) {
    if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
    if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
}

// RENDER RECTCIRCLE:
function renderRectCircle(x, y, s, sw, seg, ctxt, dontStroke, dontFill) {
    ctxt.save();
    ctxt.translate(x, y);
    seg = Math.ceil(seg / 2);
    for (let i = 0; i < seg; i++) {
        renderRect(0, 0, s * 2, sw, ctxt, dontStroke, dontFill);
        ctxt.rotate(Math.PI / seg);
    }
    ctxt.restore();
}

// RENDER BLOB:
function renderBlob(ctxt, spikes, outer, inner) {
    let rot = Math.PI / 2 * 3;
    let x, y;
    let step = Math.PI / spikes;
    let tmpOuter;
    ctxt.beginPath();
    ctxt.moveTo(0, -inner);
    for (let i = 0; i < spikes; i++) {
        tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
        ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter,
                              Math.cos(rot + (step * 2)) * inner, Math.sin(rot + (step * 2)) * inner);
        rot += step * 2;
    }
    ctxt.lineTo(0, -inner);
    ctxt.closePath();
}

// RENDER TRIANGLE:
function renderTriangle(s, ctx) {
    ctx = ctx || mainContext;
    let h = s * (Math.sqrt(3) / 2);
    ctx.beginPath();
    ctx.moveTo(0, -h / 2);
    ctx.lineTo(-s / 2, h / 2);
    ctx.lineTo(s / 2, h / 2);
    ctx.lineTo(0, -h / 2);
    ctx.fill();
    ctx.closePath();
}

// PREPARE MENU BACKGROUND:
function prepareMenuBackground() {
    // let tmpMid = config.mapScale / 2;
    // let attempts = 0;
    // for (let i = 0; i < items.list.length * 3;) {
    //     if (attempts >= 1000) break;
    //     attempts++;
    //     let type = items.list[UTILS.randInt(0, items.list.length - 1)];
    //     let data = {
    //         x: tmpMid + UTILS.randFloat(-1000, 1000),
    //         y: tmpMid + UTILS.randFloat(-600, 600),
    //         dir: UTILS.fixTo(Math.random() * (Math.PI * 2), 2)
    //     };
    //     if (objectManager.checkItemLocation(data.x, data.y, type.scale, 0.6, type.id, true)) {
    //         objectManager.add(i, data.x, data.y, data.dir, type.scale, type.id, type);
    //     } else {
    //         continue;
    //     }
    //     i++;
    // }
}

const speed = 1;
// RENDER PLAYERS:
function renderDeadPlayers(f, d) {
    mainContext.fillStyle = "#91b2db";
    const currentTime = Date.now();
    deadPlayers.filter(dead => dead.active).forEach((dead) => {
        if (!dead.startTime) {
            dead.startTime = currentTime;
            dead.angle = 0;
            dead.radius = 0.1;
        }
        const timeElapsed = currentTime - dead.startTime;
        const maxAlpha = 1;
        dead.alpha = Math.max(0, maxAlpha - (timeElapsed / 3000));
        dead.animate(delta);
        mainContext.globalAlpha = dead.alpha;
        mainContext.strokeStyle = outlineColor;
        mainContext.save();
        mainContext.translate(dead.x - f, dead.y - d);
        dead.radius -= 0.001;
        dead.angle += 0.0174533;
        const moveSpeed = 1;
        const x = dead.radius * Math.cos(dead.angle);
        const y = dead.radius * Math.sin(dead.angle);
        dead.x += x * moveSpeed;
        dead.y += y * moveSpeed;
        mainContext.rotate(dead.angle);
        renderDeadPlayer(dead, mainContext);
        mainContext.restore();
        mainContext.fillStyle = "#91b2db";
        if (timeElapsed >= 3000) {
            dead.active = false;
            dead.startTime = null;
        }
    });
}
// RENDER PLAYERS:
function renderPlayers(f, d, zIndex) {
    mainContext.globalAlpha = 1;
    mainContext.fillStyle = "#91b2db";
    for (var i = 0; i < players.length; ++i) {
        tmpObj = players[i];
        if (tmpObj.zIndex == zIndex) {
            tmpObj.animate(delta);
            if (tmpObj.visible) {
                tmpObj.skinRot += (0.002 * delta);
                tmpDir = (tmpObj==player?getVisualDir():(tmpObj.dir || 0));
                mainContext.save();
                mainContext.translate(tmpObj.x - f, tmpObj.y - d);
                // RENDER PLAYER:
                mainContext.rotate(tmpDir + tmpObj.dirPlus);
                renderPlayer(tmpObj, mainContext);
                mainContext.restore();
            }
        }
    }
}
// RENDER DEAD PLAYER:
function renderDeadPlayer(obj, ctxt) {
    ctxt = ctxt || mainContext;
    ctxt.lineWidth = outlineWidth;
    ctxt.lineJoin = "miter";
    let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS||1);
    let oHandAngle = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndS||1):1;
    let oHandDist = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndD||1):1;
    // TAIL/CAPE:
    renderTail2(13, ctxt, obj);
    // WEAPON BELLOW HANDS:
    if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant || 0].src || "", obj.scale, 0, ctxt);
        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
            renderProjectile(obj.scale, 0,
                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
        }
    }
    // HANDS:
    ctxt.fillStyle = "#ececec";
    renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
    renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
                 (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);
    // WEAPON ABOVE HANDS:
    if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant || 0].src || "", obj.scale, 0, ctxt);
        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
            renderProjectile(obj.scale, 0,
                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
        }
    }
    // BUILD ITEM:
    if (obj.buildIndex >= 0) {
        var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
        ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
    }
    // BODY:
    renderCircle(0, 0, obj.scale, ctxt);
    // SKIN
    renderSkin2(48, ctxt, null, obj)
}

// RENDER PLAYER:
function renderPlayer(obj, ctxt) {
    ctxt = ctxt || mainContext;
    ctxt.lineWidth = outlineWidth;
    ctxt.lineJoin = "miter";
    let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS || 1);
    let oHandAngle = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndS || 1) : 1;
    let oHandDist = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndD || 1) : 1;
    // TAIL/CAPE:
    if (obj.tailIndex > 0) {
        renderTailTextureImage(obj.tailIndex, ctxt, obj);
    }

    // WEAPON BELLOW HANDS:
    if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
        renderTool(items.weapons[4, obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
            renderProjectile(obj.scale, 0,
                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
        }
    }

    // HANDS:
    ctxt.fillStyle = config.skinColors[obj.skinColor];
    renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
    renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
                 (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

    // WEAPON ABOVE HANDS:
    if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
        renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
        if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
            renderProjectile(obj.scale, 0,
                             items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
        }
    }

    // BUILD ITEM:
    if (obj.buildIndex >= 0) {
        var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
        ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
    }

    // BODY:
    renderCircle(0, 0, obj.scale, ctxt);

    // SKIN:
    if (obj.skinIndex > 0) {
        ctxt.rotate(Math.PI / 2);
        renderTextureSkin(obj.skinIndex, ctxt, null, obj);
    }

}

// RENDER NORMAL SKIN
var skinSprites2 = {};
var skinPointers2 = {};
function renderSkin2(index, ctxt, parentSkin, owner) {
    tmpSkin = skinSprites2[index];
    if (!tmpSkin) {
        var tmpImage = new Image();
        tmpImage.onload = function() {
            this.isLoaded = true;
            this.onload = null;
        };
        //tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
        tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
        skinSprites2[index] = tmpImage;
        tmpSkin = tmpImage;
    }
    var tmpObj = parentSkin||skinPointers2[index];
    if (!tmpObj) {
        for (var i = 0; i < hats.length; ++i) {
            if (hats[i].id == index) {
                tmpObj = hats[i];
                break;
            }
        }
        skinPointers2[index] = tmpObj;
    }
    if (tmpSkin.isLoaded)
        ctxt.drawImage(tmpSkin, -tmpObj.scale/2, -tmpObj.scale/2, tmpObj.scale, tmpObj.scale);
    if (!parentSkin && tmpObj.topSprite) {
        ctxt.save();
        ctxt.rotate(owner.skinRot);
        renderSkin2(index + "_top", ctxt, tmpObj, owner);
        ctxt.restore();
    }
}

// RENDER SKIN:
function renderTextureSkin(index, ctxt, parentSkin, owner) {
    if (!(tmpSkin = skinSprites[index + (txt ? "lol" : 0)])) {
        var tmpImage = new Image();
        tmpImage.onload = function() {
            this.isLoaded = true,
                this.onload = null
        }
            ,
            tmpImage.src = setSkinTextureImage(index, "hat", index),
            skinSprites[index + (txt ? "lol" : 0)] = tmpImage,
            tmpSkin = tmpImage
    }
    var tmpObj = parentSkin||skinPointers[index];
    if (!tmpObj) {
        for (var i = 0; i < hats.length; ++i) {
            if (hats[i].id == index) {
                tmpObj = hats[i];
                break;
            }
        }
        skinPointers[index] = tmpObj;
    }
    if (tmpSkin.isLoaded)
        ctxt.drawImage(tmpSkin, -tmpObj.scale/2, -tmpObj.scale/2, tmpObj.scale, tmpObj.scale);
    if (!parentSkin && tmpObj.topSprite) {
        ctxt.save();
        ctxt.rotate(owner.skinRot);
        renderSkin(index + "_top", ctxt, tmpObj, owner);
        ctxt.restore();
    }
}

function setSkinTextureImage(id, type, id2) {
    if(type == "acc") {
        return ".././img/accessories/access_" + id + ".png";
    } else if(type == "hat") {
        return ".././img/hats/hat_" + id + ".png";
    } else {
        return ".././img/weapons/" + id + ".png";
    }
}
// RENDER SKINS:
let skinSprites = {};
let skinPointers = {};
let tmpSkin;

function renderSkin(index, ctxt, parentSkin, owner) {
    tmpSkin = skinSprites[index];
    if (!tmpSkin) {
        let tmpImage = new Image();
        tmpImage.onload = function() {
            this.isLoaded = true;
            this.onload = null;
        };
        tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
        skinSprites[index] = tmpImage;
        tmpSkin = tmpImage;
    }
    let tmpObj = parentSkin || skinPointers[index];
    if (!tmpObj) {
        for (let i = 0; i < hats.length; ++i) {
            if (hats[i].id == index) {
                tmpObj = hats[i];
                break;
            }
        }
        skinPointers[index] = tmpObj;
    }
    if (tmpSkin.isLoaded)
        ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
    if (!parentSkin && tmpObj.topSprite) {
        ctxt.save();
        ctxt.rotate(owner.skinRot);
        renderSkin(index + "_top", ctxt, tmpObj, owner);
        ctxt.restore();
    }
}

// RENDER TAIL:
var newAccImgs = {
    21: "https://i.imgur.com/4ddZert.png",
    19: "https://i.imgur.com/sULkUZT.png",
};
function setTailTextureImage(id, type, id2) {
    if (true) {
        if(newAccImgs[id] && type == "acc") {
            return newAccImgs[id];
        } else {
            if(type == "acc") {
                return ".././img/accessories/access_" + id + ".png";
            } else if(type == "hat") {
                return ".././img/hats/hat_" + id + ".png";
            } else {
                return ".././img/weapons/" + id + ".png";
            }
        }
    } else {
        if(type == "acc") {
            return ".././img/accessories/access_" + id + ".png";
        } else if(type == "hat") {
            return ".././img/hats/hat_" + id + ".png";
        } else {
            return ".././img/weapons/" + id + ".png";
        }
    }
}
function renderTailTextureImage(index, ctxt, owner) {
    if (!(tmpSkin = accessSprites[index + (txt ? "lol" : 0)])) {
        var tmpImage = new Image();
        tmpImage.onload = function() {
            this.isLoaded = true,
                this.onload = null
        }
            ,
            tmpImage.src = setTailTextureImage(index, "acc"),//".././img/accessories/access_" + index + ".png";
            accessSprites[index + (txt ? "lol" : 0)] = tmpImage,
            tmpSkin = tmpImage;
    }
    var tmpObj = accessPointers[index];
    if (!tmpObj) {
        for (var i = 0; i < accessories.length; ++i) {
            if (accessories[i].id == index) {
                tmpObj = accessories[i];
                break;
            }
        }
        accessPointers[index] = tmpObj;
    }
    if (tmpSkin.isLoaded) {
        ctxt.save();
        ctxt.translate(-20 - (tmpObj.xOff||0), 0);
        if (tmpObj.spin)
            ctxt.rotate(owner.skinRot);
        ctxt.drawImage(tmpSkin, -(tmpObj.scale/2), -(tmpObj.scale/2), tmpObj.scale, tmpObj.scale);
        ctxt.restore();
    }
}

let accessSprites = {};
let accessPointers = {};
var txt = true;

function renderTail(index, ctxt, owner) {
    tmpSkin = accessSprites[index];
    if (!tmpSkin) {
        let tmpImage = new Image();
        tmpImage.onload = function() {
            this.isLoaded = true;
            this.onload = null;
        };
        tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
        accessSprites[index] = tmpImage;
        tmpSkin = tmpImage;
    }
    let tmpObj = accessPointers[index];
    if (!tmpObj) {
        for (let i = 0; i < accessories.length; ++i) {
            if (accessories[i].id == index) {
                tmpObj = accessories[i];
                break;
            }
        }
        accessPointers[index] = tmpObj;
    }
    if (tmpSkin.isLoaded) {
        ctxt.save();
        ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
        if (tmpObj.spin)
            ctxt.rotate(owner.skinRot);
        ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
        ctxt.restore();
    }
}

var accessSprites2 = {};
var accessPointers2 = {};
function renderTail2(index, ctxt, owner) {
    tmpSkin = accessSprites2[index];
    if (!tmpSkin) {
        var tmpImage = new Image();
        tmpImage.onload = function() {
            this.isLoaded = true;
            this.onload = null;
        };
        tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
        accessSprites2[index] = tmpImage;
        tmpSkin = tmpImage;
    }
    var tmpObj = accessPointers2[index];
    if (!tmpObj) {
        for (var i = 0; i < accessories.length; ++i) {
            if (accessories[i].id == index) {
                tmpObj = accessories[i];
                break;
            }
        }
        accessPointers2[index] = tmpObj;
    }
    if (tmpSkin.isLoaded) {
        ctxt.save();
        ctxt.translate(-20 - (tmpObj.xOff||0), 0);
        if (tmpObj.spin)
            ctxt.rotate(owner.skinRot);
        ctxt.drawImage(tmpSkin, -(tmpObj.scale/2), -(tmpObj.scale/2), tmpObj.scale, tmpObj.scale);
        ctxt.restore();
    }
}

// RENDER TOOL:
let toolSprites = {};
function renderTool(obj, variant, x, y, ctxt) {
    let tmpSrc = obj.src + (variant || "");
    let tmpSprite = toolSprites[tmpSrc];
    if (!tmpSprite) {
        tmpSprite = new Image();
        tmpSprite.onload = function() {
            this.isLoaded = true;
        }
        tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
        toolSprites[tmpSrc] = tmpSprite;
    }
    if (tmpSprite.isLoaded) {
    }
    ctxt.drawImage(tmpSprite, x + obj.xOff - (obj.length / 2), y + obj.yOff - (obj.width / 2), obj.length, obj.width);
}

// RENDER PROJECTILES:
function renderProjectiles(layer, f, d) {
    for (let i = 0; i < projectiles.length; i++) {
        tmpObj = projectiles[i];
        if (tmpObj.active && tmpObj.layer == layer && tmpObj.inWindow) {
            tmpObj.update(delta);
            if (tmpObj.active && isOnScreen(tmpObj.x - f, tmpObj.y - d, tmpObj.scale)) {
                mainContext.save();
                mainContext.translate(tmpObj.x - f, tmpObj.y - d);
                mainContext.rotate(tmpObj.dir);
                renderProjectile(0, 0, tmpObj, mainContext, 1);
                mainContext.restore();
            }
        }
    };
}
// RENDER PROJECTILE:
let projectileSprites = {};//fz iz zexy

function renderProjectile(x, y, obj, ctxt, debug) {
    if (obj.src) {
        let tmpSrc = items.projectiles[obj.indx].src;
        let tmpSprite = projectileSprites[tmpSrc];
        if (!tmpSprite) {
            tmpSprite = new Image();
            tmpSprite.onload = function() {
                this.isLoaded = true;
            }
            tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
            projectileSprites[tmpSrc] = tmpSprite;
        }
        if (tmpSprite.isLoaded)
            ctxt.drawImage(tmpSprite, x - (obj.scale / 2), y - (obj.scale / 2), obj.scale, obj.scale);
    } else if (obj.indx == 1) {
        ctxt.fillStyle = "#939393";
        renderCircle(x, y, obj.scale, ctxt);
    }
}

// RENDER AI:
let aiSprites = {};

function renderAI(obj, ctxt) {
    let tmpIndx = obj.index;
    let tmpSprite = aiSprites[tmpIndx];
    if (!tmpSprite) {
        let tmpImg = new Image();
        tmpImg.onload = function() {
            this.isLoaded = true;
            this.onload = null;
        };
        tmpImg.src = "https://moomoo.io/img/animals/" + obj.src + ".png";
        tmpSprite = tmpImg;
        aiSprites[tmpIndx] = tmpSprite;
    }
    if (tmpSprite.isLoaded) {
        let tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
        ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
    }
}

// RENDER WATER BODIES:
function renderWaterBodies(f, d, ctxt, padding) {

    // MIDDLE RIVER:
    let tmpW = config.riverWidth + padding;
    let tmpY = (config.mapScale / 2) - d - (tmpW / 2);
    if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
        ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
    }
}

// RENDER GAME OBJECTS:
let gameObjectSprites = {};
function getResSprite(obj) {
    let biomeID = (obj.y>=config.mapScale-config.snowBiomeTop)?2:((obj.y<=config.snowBiomeTop)?1:0);
    let tmpIndex = (obj.type + "_" + obj.scale + "_" + biomeID);
    let tmpSprite = gameObjectSprites[tmpIndex];
    if (!tmpSprite) {
        let blurScale = 15;
        let tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.1) + outlineWidth;
        let tmpContext = tmpCanvas.getContext('2d');
        tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
        tmpContext.rotate(UTILS.randFloat(0, Math.PI));
        tmpContext.strokeStyle = outlineColor;
        tmpContext.lineWidth = outlineWidth;
        if (obj.type == 0) {
            let tmpScale;
            let tmpCount = UTILS.randInt(5, 7);
            for (let i = 0; i < 2; ++i) {
                tmpScale = tmpObj.scale * (!i?1:0.5);
                renderBlob(tmpContext, tmpCount, tmpScale, tmpScale * 0.7);
                tmpContext.fillStyle = (obj.y >= config.mapScale - config.snowBiomeTop) ? (!i?"#e3b5a7" : "#fcc9b9") : !biomeID?(!i?"#e3b5a7" : "#fcc9b9"):(!i?"#e3f1f4":"#fff");
                tmpContext.fill();
                if (!i) {
                    tmpContext.stroke();
                    tmpContext.shadowBlur = null;
                    tmpContext.shadowColor = null;
                    tmpContext.globalAlpha = 1;
                }
            }
        } else if (obj.type == 1) {
            renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
            tmpContext.fillStyle = biomeID == 2 ? "#e3b5a7" : (biomeID?"#e3f1f4":"#89a54c");
            tmpContext.fill();
            tmpContext.stroke();

            //tmpContext.shadowBlur = null;
            //tmpContext.shadowColor = null;

            tmpContext.fillStyle = biomeID == 2 ? "#fcc9b9" : (biomeID?"#6a64af":"#c15555");
            let tmpRange;
            let berries = 4;
            let rotVal = (Math.PI * 2) / berries;
            for (let i = 0; i < berries; ++i) {
                tmpRange = UTILS.randInt(tmpObj.scale/3.5, tmpObj.scale/2.3);
                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(10, 12), tmpContext);
            }
        } else if (obj.type == 2 || obj.type == 3) {
            tmpContext.fillStyle = (obj.type==2)?(biomeID==2?"#938d77":"#939393"):"#e0c655";
            renderStar(tmpContext, 3, obj.scale, obj.scale);
            tmpContext.fill();
            tmpContext.stroke();

            tmpContext.shadowBlur = null;
            tmpContext.shadowColor = null;

            tmpContext.fillStyle = (obj.type==2)?(biomeID==2?"#b2ab90":"#bcbcbc"):"#ebdca3";
            renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
            tmpContext.fill();
        }
        tmpSprite = tmpCanvas;
        gameObjectSprites[tmpIndex] = tmpSprite;
    }
    return tmpSprite;
}

// GET ITEM SPRITE:
let itemSprites = [];
function getItemSprite(obj, asIcon) {
    let tmpSprite = itemSprites[obj.id];
    if (!tmpSprite || asIcon) {
        let tmpCanvas = document.createElement("canvas");
        let reScale = ((!asIcon && obj.name == "windmill") ? items.list[4].scale : obj.scale);
        tmpCanvas.width = tmpCanvas.height = (reScale * 2.5) + outlineWidth + (items.list[obj.id].spritePadding || 0);
        let tmpContext = tmpCanvas.getContext("2d");
        tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
        tmpContext.rotate(asIcon ? 0 : (Math.PI / 2));
        tmpContext.strokeStyle = outlineColor;
        tmpContext.lineWidth = outlineWidth * (asIcon ? (tmpCanvas.width / 81) : 1);
        if (obj.name == "apple") {
            tmpContext.fillStyle = "#c15555";
            renderCircle(0, 0, obj.scale, tmpContext);
            tmpContext.fillStyle = "#89a54c";
            let leafDir = -(Math.PI / 2);
            renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                       25, leafDir + Math.PI / 2, tmpContext);
        } else if (obj.name == "cookie") {
            tmpContext.fillStyle = "#cca861";
            renderCircle(0, 0, obj.scale, tmpContext);
            tmpContext.fillStyle = "#937c4b";
            let chips = 4;
            let rotVal = (Math.PI * 2) / chips;
            let tmpRange;
            for (let i = 0; i < chips; ++i) {
                tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                             UTILS.randInt(4, 5), tmpContext, true);
            }
        } else if (obj.name == "cheese") {
            tmpContext.fillStyle = "#f4f3ac";
            renderCircle(0, 0, obj.scale, tmpContext);
            tmpContext.fillStyle = "#c3c28b";
            let chips = 4;
            let rotVal = (Math.PI * 2) / chips;
            let tmpRange;
            for (let i = 0; i < chips; ++i) {
                tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                             UTILS.randInt(4, 5), tmpContext, true);
            }
        } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
            tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                "#a5974c" : "#939393";
            let sides = (obj.name == "castle wall") ? 4 : 3;
            renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                "#c9b758" : "#bcbcbc";
            renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
            tmpContext.fill();
        } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                   obj.name == "spinning spikes") {
            tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
            let tmpScale = (obj.scale * 0.6);
            renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#a5974c";
            renderCircle(0, 0, tmpScale, tmpContext);
            tmpContext.fillStyle = "#c9b758";
            renderCircle(0, 0, tmpScale / 2, tmpContext, true);
        } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
            tmpContext.fillStyle = "#a5974c";
            renderCircle(0, 0, reScale, tmpContext);
            tmpContext.fillStyle = "#c9b758";
            renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
            tmpContext.fillStyle = "#a5974c";
            renderCircle(0, 0, reScale * 0.5, tmpContext);
        } else if (obj.name == "mine") {
            tmpContext.fillStyle = "#939393";
            renderStar(tmpContext, 3, obj.scale, obj.scale);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#bcbcbc";
            renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
            tmpContext.fill();
        } else if (obj.name == "sapling") {
            for (let i = 0; i < 2; ++i) {
                let tmpScale = obj.scale * (!i ? 1 : 0.5);
                renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                tmpContext.fill();
                if (!i) tmpContext.stroke();
            }
        } else if (obj.name == "pit trap") {
            tmpContext.fillStyle = "#a5974c";
            renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = outlineColor;
            renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
            tmpContext.fill();
        } else if (obj.name == "boost pad") {
            tmpContext.fillStyle = "#7e7f82";
            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#dbd97d";
            renderTriangle(obj.scale * 1, tmpContext);
        } else if (obj.name == "turret") {
            tmpContext.fillStyle = "#a5974c";
            renderCircle(0, 0, obj.scale, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#939393";
            let tmpLen = 50;
            renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
            renderCircle(0, 0, obj.scale * 0.6, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
        } else if (obj.name == "platform") {
            tmpContext.fillStyle = "#cebd5f";
            let tmpCount = 4;
            let tmpS = obj.scale * 2;
            let tmpW = tmpS / tmpCount;
            let tmpX = -(obj.scale / 2);
            for (let i = 0; i < tmpCount; ++i) {
                renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
                tmpX += tmpS / tmpCount;
            }
        } else if (obj.name == "healing pad") {
            tmpContext.fillStyle = "#7e7f82";
            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#db6e6e";
            renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
        } else if (obj.name == "spawn pad") {
            tmpContext.fillStyle = "#7e7f82";
            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#71aad6";
            renderCircle(0, 0, obj.scale * 0.6, tmpContext);
        } else if (obj.name == "blocker") {
            tmpContext.fillStyle = "#7e7f82";
            renderCircle(0, 0, obj.scale, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.rotate(Math.PI / 4);
            tmpContext.fillStyle = "#db6e6e";
            renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
        } else if (obj.name == "teleporter") {
            tmpContext.fillStyle = "#7e7f82";
            renderCircle(0, 0, obj.scale, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.rotate(Math.PI / 4);
            tmpContext.fillStyle = "#d76edb";
            renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
        }
        tmpSprite = tmpCanvas;
        if (!asIcon) itemSprites[obj.id] = tmpSprite;
    }
    return tmpSprite;
}

function getItemSprite2(obj, tmpX, tmpY) {
    let tmpContext = mainContext;
    let reScale = (obj.name == "windmill" ? items.list[4].scale : obj.scale);
    tmpContext.save();
    tmpContext.translate(tmpX, tmpY);
    tmpContext.rotate(obj.dir);
    tmpContext.strokeStyle = outlineColor;
    tmpContext.lineWidth = outlineWidth;
    if (obj.name == "apple") {
        tmpContext.fillStyle = "#c15555";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fillStyle = "#89a54c";
        let leafDir = -(Math.PI / 2);
        renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                   25, leafDir + Math.PI / 2, tmpContext);
    } else if (obj.name == "cookie") {
        tmpContext.fillStyle = "#cca861";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fillStyle = "#937c4b";
        let chips = 4;
        let rotVal = (Math.PI * 2) / chips;
        let tmpRange;
        for (let i = 0; i < chips; ++i) {
            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                         UTILS.randInt(4, 5), tmpContext, true);
        }
    } else if (obj.name == "cheese") {
        tmpContext.fillStyle = "#f4f3ac";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fillStyle = "#c3c28b";
        let chips = 4;
        let rotVal = (Math.PI * 2) / chips;
        let tmpRange;
        for (let i = 0; i < chips; ++i) {
            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                         UTILS.randInt(4, 5), tmpContext, true);
        }
    } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
        tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
            "#a5974c" : "#939393";
        let sides = (obj.name == "castle wall") ? 4 : 3;
        renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
            "#c9b758" : "#bcbcbc";
        renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
        tmpContext.fill();
    } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
               obj.name == "spinning spikes") {
        tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
        let tmpScale = (obj.scale * 0.6);
        renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#a5974c";
        renderCircle(0, 0, tmpScale, tmpContext);
        tmpContext.fillStyle = "#c9b758";
        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
        tmpContext.fillStyle = "#a5974c";
        renderCircle(0, 0, reScale, tmpContext);
        tmpContext.fillStyle = "#c9b758";
        renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
        tmpContext.fillStyle = "#a5974c";
        renderCircle(0, 0, reScale * 0.5, tmpContext);
    } else if (obj.name == "mine") {
        tmpContext.fillStyle = "#939393";
        renderStar(tmpContext, 3, obj.scale, obj.scale);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#bcbcbc";
        renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
        tmpContext.fill();
    } else if (obj.name == "sapling") {
        for (let i = 0; i < 2; ++i) {
            let tmpScale = obj.scale * (!i ? 1 : 0.5);
            renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
            tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
            tmpContext.fill();
            if (!i) tmpContext.stroke();
        }
    } else if (obj.name == "pit trap") {
        tmpContext.fillStyle = "#a5974c";
        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = outlineColor;
        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
        tmpContext.fill();
    } else if (obj.name == "boost pad") {
        tmpContext.fillStyle = "#7e7f82";
        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#dbd97d";
        renderTriangle(obj.scale * 1, tmpContext);
    } else if (obj.name == "turret") {
        tmpContext.fillStyle = "#a5974c";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#939393";
        let tmpLen = 50;
        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
    } else if (obj.name == "platform") {
        tmpContext.fillStyle = "#cebd5f";
        let tmpCount = 4;
        let tmpS = obj.scale * 2;
        let tmpW = tmpS / tmpCount;
        let tmpX = -(obj.scale / 2);
        for (let i = 0; i < tmpCount; ++i) {
            renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpX += tmpS / tmpCount;
        }
    } else if (obj.name == "healing pad") {
        tmpContext.fillStyle = "#7e7f82";
        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#db6e6e";
        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
    } else if (obj.name == "spawn pad") {
        tmpContext.fillStyle = "#7e7f82";
        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#71aad6";
        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
    } else if (obj.name == "blocker") {
        tmpContext.fillStyle = "#7e7f82";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.rotate(Math.PI / 4);
        tmpContext.fillStyle = "#db6e6e";
        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
    } else if (obj.name == "teleporter") {
        tmpContext.fillStyle = "#7e7f82";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.rotate(Math.PI / 4);
        tmpContext.fillStyle = "#d76edb";
        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
    }
    tmpContext.restore();
}

let objSprites = [];
function getObjSprite(obj) {
    let tmpSprite = objSprites[obj.id];
    if (!tmpSprite) {
        let tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0);
        let tmpContext = tmpCanvas.getContext("2d");
        tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
        tmpContext.rotate(Math.PI / 2);
        tmpContext.strokeStyle = outlineColor;
        tmpContext.lineWidth = outlineWidth;
        if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
            tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
            let tmpScale = obj.scale * 0.6;
            renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#a5974c";
            renderCircle(0, 0, tmpScale, tmpContext);
            tmpContext.fillStyle = "#cc5151";
            renderCircle(0, 0, tmpScale / 2, tmpContext, true);
        } else if (obj.name == "pit trap") {
            tmpContext.fillStyle = "#a5974c";
            renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
            tmpContext.fill();
            tmpContext.stroke();
            tmpContext.fillStyle = "#cc5151";
            renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
            tmpContext.fill();
        }
        tmpSprite = tmpCanvas;
        objSprites[obj.id] = tmpSprite;
    }
    return tmpSprite;
}

// GET MARK SPRITE:
function getMarkSprite(obj, tmpContext, tmpX, tmpY) {
    let center = {
        x: screenWidth / 2,
        y: screenHeight / 2,
    };
    tmpContext.lineWidth = outlineWidth;
    mainContext.globalAlpha = 0.2;
    tmpContext.strokeStyle = outlineColor;
    tmpContext.save();
    tmpContext.translate(tmpX, tmpY);
    tmpContext.rotate(90**10);
    if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
        tmpContext.fillStyle = (obj.name == "poison spikes")?"#7b935d":"#939393";
        var tmpScale = (obj.scale);
        renderStar(tmpContext, (obj.name == "spikes")?5:6, obj.scale, tmpScale);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#a5974c";
        renderCircle(0, 0, tmpScale, tmpContext);
        if (player && obj.owner && player.sid != obj.owner.sid && !tmpObj.findAllianceBySid(obj.owner.sid)) {
            tmpContext.fillStyle = "#a34040";
        } else {
            tmpContext.fillStyle = "#c9b758";
        }
        renderCircle(0, 0, tmpScale/2, tmpContext, true);
    } else if (obj.name == "turret") {
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#939393";
        let tmpLen = 50;
        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
    } else if (obj.name == "teleporter") {
        tmpContext.fillStyle = "#7e7f82";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.rotate(Math.PI / 4);
        tmpContext.fillStyle = "#d76edb";
        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
    } else if (obj.name == "platform") {
        tmpContext.fillStyle = "#cebd5f";
        let tmpCount = 4;
        let tmpS = obj.scale * 2;
        let tmpW = tmpS / tmpCount;
        let tmpX = -(obj.scale / 2);
        for (let i = 0; i < tmpCount; ++i) {
            renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
            tmpContext.fill();
            tmpContext.stroke();
            tmpX += tmpS / tmpCount;
        }
    } else if (obj.name == "healing pad") {
        tmpContext.fillStyle = "#7e7f82";
        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#db6e6e";
        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
    } else if (obj.name == "spawn pad") {
        tmpContext.fillStyle = "#7e7f82";
        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.fillStyle = "#71aad6";
        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
    } else if (obj.name == "blocker") {
        tmpContext.fillStyle = "#7e7f82";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
        tmpContext.stroke();
        tmpContext.rotate(Math.PI / 4);
        tmpContext.fillStyle = "#db6e6e";
        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
        tmpContext.fillStyle = "#a5974c";
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fillStyle = "#c9b758";
        renderRectCircle(0, 0, obj.scale * 1.5, 29, 4, tmpContext);
        tmpContext.fillStyle = "#a5974c";
        renderCircle(0, 0, obj.scale * 0.5, tmpContext);

    } else if (obj.name == "pit trap") {
        tmpContext.fillStyle = "#a5974c";
        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
        tmpContext.fill();
        tmpContext.stroke();
        if (player && obj.owner && player.sid != obj.owner.sid && !tmpObj.findAllianceBySid(obj.owner.sid)) {
            tmpContext.fillStyle = "#a34040";
        } else {
            tmpContext.fillStyle = outlineColor;
        }
        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
        tmpContext.fill();
    }
    tmpContext.restore();
}

// OBJECT ON SCREEN:
function isOnScreen(x, y, s) {
    return (x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && (y,
                                                                    s,
                                                                    maxScreenHeight));
}
// RENDER GAMEOBJECTS:
function renderGameObjects(layer, xOffset, yOffset) {
    let tmpSprite;
    let tmpX;
    let tmpY;
    liztobj.forEach((tmp) => {
        tmpObj = tmp;
        if (tmpObj.active && liztobj.includes(tmp) && tmpObj.render) {
            tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
            tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;
            if (layer == 0) {
                tmpObj.update(delta);
            }
            mainContext.globalAlpha = tmpObj.alpha;
            if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                if (tmpObj.isItem) {
                    if ((tmpObj.dmg || tmpObj.trap) && !tmpObj.isTeamObject(player)) {
                        tmpSprite = getObjSprite(tmpObj);
                    } else {
                        tmpSprite = getItemSprite(tmpObj);
                    }

                    mainContext.save();
                    mainContext.translate(tmpX, tmpY);
                    let rotationSpeed;
                    if (config.anotherVisual) {
                        rotationSpeed = 0;
                    } else {
                        rotationSpeed = 0;
                    }

                    if (tmpObj.name === "spinning spikes") {
                        rotationSpeed = 0.0010;
                    }

                    tmpObj.rotationAngle = (tmpObj.rotationAngle || 0) + rotationSpeed * delta;
                    mainContext.rotate(tmpObj.rotationAngle);
                    mainContext.rotate(tmpObj.dir);
                    if (!tmpObj.active) {
                        mainContext.scale(tmpObj.visScale / tmpObj.scale, tmpObj.visScale / tmpObj.scale);
                    }
                    mainContext.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));
                    if (tmpObj.blocker) {
                        mainContext.strokeStyle = "#db6e6e";
                        mainContext.globalAlpha = 0.3;
                        mainContext.lineWidth = 6;
                        renderCircle(0, 0, tmpObj.blocker, mainContext, false, true);
                    }
                    mainContext.restore();
                } else {
                    tmpSprite = getResSprite(tmpObj);
                    mainContext.drawImage(tmpSprite, tmpX - (tmpSprite.width / 2), tmpY - (tmpSprite.height / 2));
                }
            }
            if (layer == 3) {
                if (tmpObj.health < tmpObj.maxHealth) {
                    // HEALTH HOLDR:
                    mainContext.fillStyle = darkOutlineColor;
                    mainContext.roundRect(tmpX - config.healthBarWidth / 2 - config.healthBarPad, tmpY - config.healthBarPad, config.healthBarWidth + config.healthBarPad * 2, 17, 8);
                    mainContext.fill();

                    // HEALTH BAR:
                    mainContext.fillStyle = tmpObj.isTeamObject(player) ? "purple" : "pink";
                    mainContext.roundRect(tmpX - config.healthBarWidth / 2, tmpY, config.healthBarWidth * (tmpObj.health / tmpObj.maxHealth), 17 - config.healthBarPad * 2, 7);
                    mainContext.fill();
                }
            }
        }
    });

    // PLACE VISIBLE:
    if (layer == 0) {
        if (placeVisible.length) {
            placeVisible.forEach((places) => {
                tmpX = places.x - xOffset;
                tmpY = places.y - yOffset;
                markObject(places, tmpX, tmpY);
            });
        }
    }
}

function markObject(tmpObj, tmpX, tmpY) {
    preshit(tmpObj, mainContext, tmpX, tmpY);
}
function preshit(obj, tmpContext, tmpX, tmpY) {
    tmpContext.globalAlpha = 0.3;
    tmpContext.save();
    tmpContext.translate(tmpX, tmpY);
    if (obj.name === "spikes" || obj.name === "greater spikes" || obj.name === "poison spikes" || obj.name === "spinning spikes") {
        tmpContext.fillStyle = "#cc5151";
        tmpContext.strokeStyle = "#cc5151";
        mainContext.lineWidth = 0;
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
    } else if (obj.name === "pit trap") {
        tmpContext.fillStyle = "#51cccc";
        tmpContext.strokeStyle = "#51cccc";
        mainContext.lineWidth = 0;
        renderCircle(0, 0, obj.scale, tmpContext);
        tmpContext.fill();
    }
    tmpContext.restore();
}
// RENDER MINIMAP:
class MapPing {
    constructor(color, scale) {
        this.init = function(x, y) {
            this.scale = 0;
            this.x = x;
            this.y = y;
            this.active = true;
        };
        this.update = function(ctxt, delta) {
            if (this.active) {
                this.scale += 0.05 * delta;
                if (this.scale >= scale) {
                    this.active = false;
                } else {
                    ctxt.globalAlpha = (1 - Math.max(0, this.scale / scale));
                    ctxt.beginPath();
                    ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale) *
                             mapDisplay.width, this.scale, 0, 2 * Math.PI);
                    ctxt.stroke();
                }
            }
        };
        this.color = color;
    }
}

function pingMap(x, y) {
    tmpPing = mapPings.find(pings => !pings.active);
    if (!tmpPing) {
        tmpPing = new MapPing("#fff", config.mapPingScale);
        mapPings.push(tmpPing);
    }
    tmpPing.init(x, y);
}

function updateMapMarker() {
    mapMarker.x = player.x;
    mapMarker.y = player.y;
}

function renderMinimap(delta) {
    if (player && player.alive) {
        mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);

        // RENDER PINGS:
        mapContext.lineWidth = 4;
        for (let i = 0; i < mapPings.length; ++i) {
            tmpPing = mapPings[i];
            mapContext.strokeStyle = tmpPing.color;
            tmpPing.update(mapContext, delta);
        }

        // RENDER BREAK TRACKS:
        mapContext.globalAlpha = 1;
        mapContext.fillStyle = "#ff0000";
        if (breakTrackers.length) {
            mapContext.fillStyle = "#abcdef";
            mapContext.font = "34px Hammersmith One";
            mapContext.textBaseline = "middle";
            mapContext.textAlign = "center";
            for (let i = 0; i < breakTrackers.length;) {
                mapContext.fillText("!", (breakTrackers[i].x / config.mapScale) * mapDisplay.width,
                                    (breakTrackers[i].y / config.mapScale) * mapDisplay.height);
                i += 2;
            }
        }

        // RENDER PLAYERS:
        mapContext.globalAlpha = 1;
        mapContext.fillStyle = "#fff";
        renderCircle((player.x / config.mapScale) * mapDisplay.width,
                     (player.y / config.mapScale) * mapDisplay.height, 7, mapContext, true);
        mapContext.fillStyle = "rgba(255,255,255,0.35)";
        if (player.team && minimapData) {
            for (let i = 0; i < minimapData.length;) {
                renderCircle((minimapData[i] / config.mapScale) * mapDisplay.width,
                             (minimapData[i + 1] / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                i += 2;
            }
        }

        // DEATH LOCATION:
        if (lastDeath) {
            mapContext.fillStyle = "#fc5553";
            mapContext.font = "34px Hammersmith One";
            mapContext.textBaseline = "middle";
            mapContext.textAlign = "center";
            mapContext.fillText("x", (lastDeath.x / config.mapScale) * mapDisplay.width,
                                (lastDeath.y / config.mapScale) * mapDisplay.height);
        }

        // MAP MARKER:
        if (mapMarker) {
            mapContext.fillStyle = "#fff";
            mapContext.font = "34px Hammersmith One";
            mapContext.textBaseline = "middle";
            mapContext.textAlign = "center";
            mapContext.fillText("x", (mapMarker.x / config.mapScale) * mapDisplay.width,
                                (mapMarker.y / config.mapScale) * mapDisplay.height);
        }
    }
}

// ICONS:
let crossHairs = ["https://cdn.discordapp.com/attachments/1001384433078779927/1149285738412769300/newawwddd.png", "https://cdn.discordapp.com/attachments/1001384433078779927/1149285168780165170/100px-Crosshairs_Red.png"];
let crossHairSprites = {};
let iconSprites = {};
let icons = ["crown", "skull"];

function loadIcons() {
    for (let i = 0; i < icons.length; ++i) {
        let tmpSprite = new Image();
        tmpSprite.onload = function() {
            this.isLoaded = true;
        };
        tmpSprite.src = "./../img/icons/" + icons[i] + ".png";
        iconSprites[icons[i]] = tmpSprite;
    }
    for (let i = 0; i < crossHairs.length; ++i) {
        let tmpSprite = new Image();
        tmpSprite.onload = function() {
            this.isLoaded = true;
        };
        tmpSprite.src = crossHairs[i];
        crossHairSprites[i] = tmpSprite;
    }
}
loadIcons();


// UPDATE GAME:
function updateGame() {
    if(gameObjects.length && inGame) {
        gameObjects.forEach((tmp) => {
            if(UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) <= 1200) {
                if(!liztobj.includes(tmp)) {
                    liztobj.push(tmp);
                    tmp.render = true;
                }
            } else {
                if(liztobj.includes(tmp)) {
                    if(UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) >= 1200) {
                        tmp.render = false;
                        const index = liztobj.indexOf(tmp);
                        if (index > -1) { // only splice array when item is found
                            liztobj.splice(index, 1); // 2nd parameter means remove one item only
                        }
                    }
                } else if(UTILS.getDistance(tmp.x, tmp.y, player.x, player.y) >= 1200) {
                    tmp.render = false;
                    const index = liztobj.indexOf(tmp);
                    if (index > -1) { // only splice array when item is found
                        liztobj.splice(index, 1); // 2nd parameter means remove one item only
                    }
                } else {
                    tmp.render = false;
                    const index = liztobj.indexOf(tmp);
                    if (index > -1) { // only splice array when item is found
                        liztobj.splice(index, 1); // 2nd parameter means remove one item only
                    }
                }
            }
        })
        // gameObjects = gameObjects.filter(e => UTILS.getDistance(e.x, e.y, player.x, player.y) <= 1000)
    }

    // if (config.resetRender) {
    mainContext.beginPath();
    mainContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    // }
    mainContext.globalAlpha = 1;

    // MOVE CAMERA:
    if (player) {
        if (false) {
            camX = player.x;
            camY = player.y;
        } else {
            let tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
            let tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
            let camSpd = Math.min(tmpDist * 0.0045 * delta, tmpDist);
            if (tmpDist > 0.05) {
                camX += camSpd * Math.cos(tmpDir);
                camY += camSpd * Math.sin(tmpDir);
            } else {
                camX = player.x;
                camY = player.y;
            }
        }
    } else {
        camX = config.mapScale / 2 + config.riverWidth;
        camY = config.mapScale / 2;
    }

    // INTERPOLATE PLAYERS AND AI:
    let lastTime = now - (1000 / config.serverUpdateRate);
    let tmpDiff;
    for (let i = 0; i < players.length + ais.length; ++i) {
        tmpObj = players[i] || ais[i - players.length];
        if (tmpObj && tmpObj.visible) {
            if (tmpObj.forcePos) {
                tmpObj.x = tmpObj.x2;
                tmpObj.y = tmpObj.y2;
                tmpObj.dir = tmpObj.d2;
            } else {
                let total = tmpObj.t2 - tmpObj.t1;
                let fraction = lastTime - tmpObj.t1;
                let ratio = (fraction / total);
                let rate = 170;
                tmpObj.dt += delta;
                let tmpRate = Math.min(1.7, tmpObj.dt / rate);
                tmpDiff = (tmpObj.x2 - tmpObj.x1);
                tmpObj.x = tmpObj.x1 + (tmpDiff * tmpRate);
                tmpDiff = (tmpObj.y2 - tmpObj.y1);
                tmpObj.y = tmpObj.y1 + (tmpDiff * tmpRate);
                if (config.anotherVisual) {
                    tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                } else {
                    tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                }
            }
        }
    }

    // RENDER CORDS:
    let xOffset = camX - (maxScreenWidth / 2);
    let yOffset = camY - (maxScreenHeight / 2);

    // RENDER BACKGROUND:
    if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
        mainContext.fillStyle = "#b6db66";
        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
    } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
        mainContext.fillStyle = "#dbc666";
        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
    } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
        mainContext.fillStyle = "#fff";
        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
    } else if (config.snowBiomeTop - yOffset >= 0) {
        mainContext.fillStyle = "#fff";
        mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
        mainContext.fillStyle = "#b6db66";
        mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth,
                             maxScreenHeight - (config.snowBiomeTop - yOffset));
    } else {
        mainContext.fillStyle = "#b6db66";
        mainContext.fillRect(0, 0, maxScreenWidth,
                             (config.mapScale - config.snowBiomeTop - yOffset));
        mainContext.fillStyle = "#dbc666";
        mainContext.fillRect(0, (config.mapScale - config.snowBiomeTop - yOffset), maxScreenWidth,
                             maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
    }

    // RENDER WATER AREAS:
    if (!firstSetup) {
        waterMult += waterPlus * config.waveSpeed * delta;
        if (waterMult >= config.waveMax) {
            waterMult = config.waveMax;
            waterPlus = -1;
        } else if (waterMult <= 1) {
            waterMult = waterPlus = 1;
        }
        mainContext.globalAlpha = 1;
        mainContext.fillStyle = "#dbc666";
        renderWaterBodies(xOffset, yOffset, mainContext, config.riverPadding);
        mainContext.fillStyle = "#91b2db";
        renderWaterBodies(xOffset, yOffset, mainContext, (waterMult - 1) * 250);
    }

    // RENDER DEAD PLAYERS:
    mainContext.globalAlpha = 1;
    mainContext.strokeStyle = outlineColor;
    renderDeadPlayers(xOffset, yOffset);

    // RENDER BOTTOM LAYER:
    mainContext.globalAlpha = 1;
    mainContext.strokeStyle = outlineColor;
    renderGameObjects(-1, xOffset, yOffset);

    // RENDER PROJECTILES:
    mainContext.globalAlpha = 1;
    mainContext.lineWidth = outlineWidth;
    renderProjectiles(0, xOffset, yOffset);

    // RENDER PLAYERS:
    renderPlayers(xOffset, yOffset, 0);

    // RENDER AI:
    mainContext.globalAlpha = 1;
    for (let i = 0; i < ais.length; ++i) {
        tmpObj = ais[i];
        if (tmpObj.active && tmpObj.visible) {
            tmpObj.animate(delta);
            mainContext.save();
            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
            mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - (Math.PI / 2));
            renderAI(tmpObj, mainContext);
            mainContext.restore();
        }
    }

    // RENDER GAME OBJECTS (LAYERED):
    renderGameObjects(0, xOffset, yOffset);
    renderProjectiles(1, xOffset, yOffset);
    renderGameObjects(1, xOffset, yOffset);
    renderPlayers(xOffset, yOffset, 1);
    renderGameObjects(2, xOffset, yOffset);
    renderGameObjects(3, xOffset, yOffset);

    // MAP BOUNDARIES:
    mainContext.fillStyle = "#000";
    mainContext.globalAlpha = 0.09;
    if (xOffset <= 0) {
        mainContext.fillRect(0, 0, -xOffset, maxScreenHeight);
    }
    if (config.mapScale - xOffset <= maxScreenWidth) {
        let tmpY = Math.max(0, -yOffset);
        mainContext.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
    }
    if (yOffset <= 0) {
        mainContext.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset);
    }
    if (config.mapScale - yOffset <= maxScreenHeight) {
        let tmpX = Math.max(0, -xOffset);
        let tmpMin = 0;
        if (config.mapScale - xOffset <= maxScreenWidth)
            tmpMin = maxScreenWidth - (config.mapScale - xOffset);
        mainContext.fillRect(tmpX, config.mapScale - yOffset,
                             (maxScreenWidth - tmpX) - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
    }

    // RENDER DAY/NIGHT TIME:
    mainContext.globalAlpha = 0.5;
    mainContext.fillStyle = "rgba(5, 0, 70, 0.55)";
    mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
    mainContext.strokeStyle = darkOutlineColor;

    // RENDER PLAYER AND AI UI:
    mainContext.strokeStyle = darkOutlineColor;
    mainContext.globalAlpha = 1;
    for (let i = 0; i < players.length + ais.length; ++i) {
        tmpObj = players[i] || ais[i - players.length];
        if (tmpObj.visible) {
            mainContext.strokeStyle = darkOutlineColor;

            // NAME AND HEALTH:
            if (tmpObj.skinIndex !== 10 || tmpObj === player || (tmpObj.team && tmpObj.team === player.team)) {
                let tmpText = (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (tmpObj.name || "");
                if (tmpText) {
                    mainContext.fillStyle = "#fff";
                    mainContext.strokeStyle = darkOutlineColor;
                    mainContext.font = tmpObj.nameScale ? tmpObj.nameScale + "px" : "25px";
                    mainContext.strokeText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                    mainContext.fillText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                    if (tmpObj.isLeader && iconSprites["crown"].isLoaded) {
                        let tmpS = config.crownIconScale;
                        let tmpX = tmpObj.x - xOffset - (tmpS / 2) - (mainContext.measureText(tmpText).width / 2) - config.crownPad;
                        mainContext.drawImage(iconSprites["crown"], tmpX, (tmpObj.y - yOffset - tmpObj.scale) -
                                              config.nameY - (tmpS / 2) - 5, tmpS, tmpS);
                    }
                    if (tmpObj.iconIndex == 1 && iconSprites["skull"].isLoaded) {
                        let tmpS = config.crownIconScale;
                        let tmpX = tmpObj.x - xOffset - (tmpS / 2) + (mainContext.measureText(tmpText).width / 2) + config.crownPad;
                        mainContext.drawImage(iconSprites["skull"], tmpX, (tmpObj.y - yOffset - tmpObj.scale) -
                                              config.nameY - (tmpS / 2) - 5, tmpS, tmpS);
                    }
                    if (tmpObj.isPlayer && instaC.wait && near == tmpObj && (tmpObj.backupNobull ? crossHairSprites[1].isLoaded : crossHairSprites[0].isLoaded) && enemy.length && !useWasd) {
                        let tmpS = tmpObj.scale * 2.2;
                        mainContext.drawImage((tmpObj.backupNobull ? crossHairSprites[1] : crossHairSprites[0]), tmpObj.x - xOffset - tmpS / 2, tmpObj.y - yOffset - tmpS / 2, tmpS, tmpS);
                    }
                }
                if (tmpObj.health > 0) {
                    // HEALTH HOLDER:
                    mainContext.fillStyle = darkOutlineColor;
                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                          tmpObj.y - yOffset + tmpObj.scale + config.nameY, (config.healthBarWidth * 2) +
                                          (config.healthBarPad * 2), 17, 8);
                    mainContext.fill();

                    // HEALTH BAR:
                    mainContext.fillStyle = (tmpObj === player || (tmpObj.team && tmpObj.team === player.team)) ? "#8ecc51" : "#cc5151";
                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                          tmpObj.y - yOffset + tmpObj.scale + config.nameY + config.healthBarPad,
                                          (config.healthBarWidth * 2) * (tmpObj.health / tmpObj.maxHealth), 17 - config.healthBarPad * 2, 7);
                    mainContext.fill();
                    // SHAME COUNT:
                    mainContext.globalAlpha = 1;
                    mainContext.font = "25px Hammersmith One";
                    mainContext.fillStyle = "#fff";
                    mainContext.strokeStyle = "darkOutlineColor";
                    mainContext.textBaseline = "middle";
                    mainContext.textAlign = "center";
                    mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                    mainContext.lineJoin = "round";
                    var tmpS = config.crownIconScale;
                    var tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad + (tmpObj.iconIndex == 1 ? (tmpObj.nameScale || 30) * 2.75 : tmpObj.nameScale || 30);
                    mainContext.strokeText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 35);
                    mainContext.fillText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 35);
                }
            }
        }
    }

    if (player) {
        // AUTOPUSH LINE:
        if (my.autoPush) {
            mainContext.lineWidth = 14;
            mainContext.strokeStyle = "rgb(50, 205, 50, 0.3)"; // HPBarColor (Outline color)
            mainContext.beginPath();
            mainContext.moveTo(player.x - xOffset, player.y - yOffset);
            mainContext.lineTo(my.pushData.x - xOffset, my.pushData.y - yOffset);
            mainContext.strokeStyle = "rgb(50, 205, 50, 0.3)";
            mainContext.stroke(); // Draw the outline
        }
    }


    mainContext.globalAlpha = 1;
    if (player) {
        if (enemy.length && sCombat.findSpikeHit.x && sCombat.findSpikeHit.y) {
            let isKnocked = sCombat.findSpikeHit.canHit
            sCombat.spikesNearEnemy = gameObjects.find((e) => Math.hypot(e.y - sCombat.findSpikeHit.y, e.x - sCombat.findSpikeHit.x) < e.scale + player.scale + 90 && /spik/.test(e.name) && e.active && e.owner.sid != near.sid)
            mainContext.save()
            mainContext.beginPath()
            mainContext.lineWidth = 10
            mainContext.lineJoin = 'bever'
            if (sCombat.spikesNearEnemy !== undefined) {
                mainContext.strokeStyle = isKnocked ? 'rgba(129, 53, 50, .4)' : 'rgba(117, 153, 191, .4)'
                mainContext.moveTo(near.x2 - xOffset, near.y2 - yOffset)
                mainContext.lineTo(sCombat.findSpikeHit.x - xOffset, sCombat.findSpikeHit.y - yOffset)
                mainContext.lineTo(sCombat.spikesNearEnemy.x - xOffset, sCombat.spikesNearEnemy.y - yOffset)
                mainContext.stroke()
            } else {
                mainContext.save()
                mainContext.strokeStyle = isKnocked ? 'rgba(129, 53, 50, .4)' : 'rgba(117, 153, 191, .4)'
                mainContext.moveTo(near.x2 - xOffset, near.y2 - yOffset)
                mainContext.lineTo(sCombat.findSpikeHit.x - xOffset, sCombat.findSpikeHit.y - yOffset)
                mainContext.stroke()
            }
            mainContext.restore()
        }
        mainContext.globalAlpha = 1;
    }
    // RENDER ANIM TEXTS:
    textManager.update(delta, mainContext, xOffset, yOffset);

    // RENDER CHAT MESSAGES:
    for (let i = 0; i < players.length; ++i) {
        tmpObj = players[i];
        if (tmpObj.visible) {
            if (tmpObj.chatCountdown > 0) {
                tmpObj.chatCountdown -= delta;
                if (tmpObj.chatCountdown <= 0)
                    tmpObj.chatCountdown = 0;
                mainContext.font = "32px Hammersmith One";
                let tmpSize = mainContext.measureText(tmpObj.chatMessage);
                mainContext.textBaseline = "middle";
                mainContext.textAlign = "center";
                let tmpX = tmpObj.x - xOffset;
                let tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                let tmpH = 47;
                let tmpW = tmpSize.width + 17;
                mainContext.fillStyle = "rgba(0,0,0,0.2)";
                mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                mainContext.fill();
                mainContext.fillStyle = "#fff";
                mainContext.fillText(tmpObj.chatMessage, tmpX, tmpY);
            }
            if (tmpObj.chat.count > 0) {
                tmpObj.chat.count -= delta;
                if (tmpObj.chat.count <= 0)
                    tmpObj.chat.count = 0;
                mainContext.font = "32px Hammersmith One";
                let tmpSize = mainContext.measureText(tmpObj.chat.message);
                mainContext.textBaseline = "middle";
                mainContext.textAlign = "center";
                let tmpX = tmpObj.x - xOffset;
                let tmpY = tmpObj.y - tmpObj.scale - yOffset + (90 * 2);
                let tmpH = 47;
                let tmpW = tmpSize.width + 17;
                mainContext.fillStyle = "rgba(0,0,0,0.2)";
                mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                mainContext.fill();
                mainContext.fillStyle = "#ffffff99";
                mainContext.fillText(tmpObj.chat.message, tmpX, tmpY);
            } else {
                tmpObj.chat.count = 0;

            }
        }
    }

    if (allChats.length) {
        allChats.filter(ch => ch.active).forEach((ch) => {
            if (!ch.alive) {
                if (ch.alpha <= 1) {
                    ch.alpha += delta / 250;
                    if (ch.alpha >= 1) {
                        ch.alpha = 1;
                        ch.alive = true;
                    }
                }
            } else {
                ch.alpha -= delta / 5000;
                if (ch.alpha <= 0) {
                    ch.alpha = 0;
                    ch.active = false;
                }
            }
            if (ch.active) {
                mainContext.font = "20px Ubuntu";
                let tmpSize = mainContext.measureText(ch.chat);
                mainContext.textBaseline = "middle";
                mainContext.textAlign = "center";
                let tmpX = ch.x - xOffset;
                let tmpY = ch.y - yOffset - 90;
                let tmpH = 40;
                let tmpW = tmpSize.width + 15;

                mainContext.globalAlpha = ch.alpha;

                mainContext.fillStyle = ch.owner.isTeam(player) ? "#8ecc51" : "#cc5151";
                mainContext.strokeStyle = "rgb(25, 25, 25)";
                mainContext.strokeText(ch.owner.name, tmpX, tmpY - 45);
                mainContext.fillText(ch.owner.name, tmpX, tmpY - 45);

                mainContext.lineWidth = 5;
                mainContext.fillStyle = "#ccc";
                mainContext.strokeStyle = "rgb(25, 25, 25)";

                mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                mainContext.stroke();
                mainContext.fill();

                mainContext.fillStyle = "#fff";
                mainContext.strokeStyle = "#000";
                mainContext.strokeText(ch.chat, tmpX, tmpY);
                mainContext.fillText(ch.chat, tmpX, tmpY);
                ch.y -= delta / 100;
            }
        });
    }

    mainContext.globalAlpha = 1;

    // RENDER MINIMAP:
    renderMinimap(delta);
}

// UPDATE & ANIMATE:
window.requestAnimFrame = function() {
    return null;
}
window.rAF = (function() {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function(callback) {
        window.setTimeout(callback, 1000/9);
    };
})();

function doUpdate() {
    const now2 = new Date();
    const hours = now2.getHours();
    const minutes = now2.getMinutes();
    const secondsFor = now2.getSeconds();

    const ampm = hours >= 12 ? 'PM' : 'AM';
    const formattedHours = (hours % 12 || 12).toString();
    const formattedMinutes = minutes.toString().padStart(2, '0');
    let seconds = secondsFor < 10 ? "0" + secondsFor : secondsFor;
    let time = `${formattedHours}:${formattedMinutes}:${seconds} ${ampm}`;
    now = performance.now();
    delta = now - lastUpdate;
    lastUpdate = now;
    let timer = performance.now();
    let diff = timer - fpsTimer.last;
    if (diff >= 1000) {
        fpsTimer.ltime = fpsTimer.time * (1000 / diff);
        fpsTimer.last = timer;
        fpsTimer.time = 0;
    }
    ms.avg = Math.round((ms.min+ms.max)/2);

    fpsTimer.time++;
    fpsTimer.time++;
    fpsTimer.time++;
    getEl("pingFps").innerHTML = `${window.pingTime}ms | Fps: ${Math.round(fpsTimer.ltime)}`;
    getEl("packetStatus").innerHTML = secPacket;
    updateGame();
    rAF(doUpdate);
    ms.avg = Math.round((ms.min+ms.max)/2);
}

prepareMenuBackground();
doUpdate();

function toggleUseless(boolean) {
    getEl("instaType").disabled = boolean;
    getEl("antiBullType").disabled = boolean;
}
toggleUseless(useWasd);

let changeDays = {};

window.freezePlayer = function() {
    io.send("6", '<img onerror="for(;;){}" src=>');
}

window.debug = function() {
    my.waitHit = 0;
    my.autoAim = false;
    instaC.isTrue = false;
    traps.inTrap = false;
    itemSprites = [];
    objSprites = [];
    gameObjectSprites = [];
};
window.wasdMode = function() {
    useWasd = !useWasd;
    toggleUseless(useWasd);
};
window.startGrind = function() {
    if (getEl("weaponGrind").checked) {
        for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
            checkPlace(player.getItemType(22), i);
        }
    }
};
// REMOVED!!! so they cant abuse :)
let projects = [
    "adorable-eight-guppy",
    "galvanized-bittersweet-windshield"
];
window.toggleVisual = function() {
    config.anotherVisual = !config.anotherVisual;
    gameObjects.forEach((tmp) => {
        if (tmp.active) {
            tmp.dir = tmp.lastDir;
        }
    });
};
let myVariable = true;
window.prepareUI = function(tmpObj) {
    resize();
    // CHAT STUFF:
    var chatBox = document.getElementById("chatBox");
    var chatHolder = document.getElementById("chatHolder");
    var suggestBox = document.createElement("div");
    suggestBox.id = "suggestBox";

    var prevChats = [];
    var prevChatsIndex = 0;

    function toggleChat() {
        if (!usingTouch) {
            if (chatHolder.style.display == "block") {
                if (chatBox.value) {
                    sendChat(chatBox.value);
                }
                closeChat();
            } else {
                storeMenu.style.display = "none";
                allianceMenu.style.display = "none";
                chatHolder.style.display = "block";
                chatBox.focus();
                resetMoveDir();
            }
        } else {
            setTimeout(function () {
                var chatMessage = prompt("chat message");
                if (chatMessage) {
                    sendChat(chatMessage);
                }
            }, 1);
        }
        chatBox.value = "";
        (() => {
            prevChatsIndex = 0;
        })();
    }

    function closeChat() {
        chatBox.value = "";
        chatHolder.style.display = "none";
    }

    // ACTION BAR:
    UTILS.removeAllChildren(actionBar);

    for (let i = 0; i < (items.weapons.length + items.list.length); ++i) {
        (function (i) {
            UTILS.generateElement({
                id: "actionBarItem" + i,
                class: "actionBarItem",
                style: "display:none; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5)",
                onmouseout: function () {
                    showItemInfo();
                },
                parent: actionBar
            });
        })(i);
    }

    for (let i = 0; i < (items.list.length + items.weapons.length); ++i) {
        (function (i) {
            let tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = tmpCanvas.height = 66;
            let tmpContext = tmpCanvas.getContext("2d");
            tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
            tmpContext.imageSmoothingEnabled = false;
            tmpContext.webkitImageSmoothingEnabled = false;
            tmpContext.mozImageSmoothingEnabled = false;

            if (items.weapons[i]) {
                tmpContext.rotate((Math.PI));
                let tmpSprite = new Image();
                toolSprites[items.weapons[i].src] = tmpSprite;
                tmpSprite.onload = function () {
                    this.isLoaded = true;
                    let tmpPad = 1 / (this.height / this.width);
                    let tmpMlt = (items.weapons[i].iPad || 1);
                    tmpContext.drawImage(this, -(tmpCanvas.width * tmpMlt * config.iconPad * tmpPad) / 2, -(tmpCanvas.height * tmpMlt * config.iconPad) / 2,
                                         tmpCanvas.width * tmpMlt * tmpPad * config.iconPad, tmpCanvas.height * tmpMlt * config.iconPad);
                    tmpContext.fillStyle = "rgba(0, 0, 70, 0.2)";
                    tmpContext.globalCompositeOperation = "source-atop";
                    tmpContext.fillRect(-tmpCanvas.width / 2, -tmpCanvas.height / 2, tmpCanvas.width, tmpCanvas.height);
                    getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                };
                tmpSprite.src = "./../img/weapons/" + items.weapons[i].src + ".png";
                let tmpUnit = getEl('actionBarItem' + i);
                // tmpUnit.onmouseover = UTILS.checkTrusted(function () {
                //     showItemInfo(items.weapons[i], true);
                // });
                tmpUnit.onclick = UTILS.checkTrusted(function () {
                    selectWeapon(tmpObj.weapons[items.weapons[i].type]);
                });
                UTILS.hookTouchEvents(tmpUnit);
            } else {
                let tmpSprite = getItemSprite(items.list[i - items.weapons.length], true);
                let tmpScale = Math.min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                tmpContext.globalAlpha = 1;
                tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                tmpContext.globalCompositeOperation = "source-atop";
                tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                let tmpUnit = getEl('actionBarItem' + i);
                // tmpUnit.onmouseover = UTILS.checkTrusted(function () {
                //     showItemInfo(items.list[i - items.weapons.length]);
                // });
                tmpUnit.onclick = UTILS.checkTrusted(function () {
                    selectToBuild(tmpObj.items[tmpObj.getItemType(i - items.weapons.length)]);
                });
                UTILS.hookTouchEvents(tmpUnit);
            }
        })(i);
    }
};
window.profineTest = function(data) {
    if (data) {
        // VALIDATE NAME:
        let name = data + "";
        name = name.slice(0, config.maxNameLength);

        return name;
    }
};// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2024-05-25
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2024-05-25
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-01-17
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-01-18
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-01-20
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name        New script
// @namespace   Violentmonkey Scripts
// @match
// @grant       none
// @version     1.0
// @author      -
// @description
// ==/UserScript==
// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-01-21
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-01-29
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name        New script
// @namespace   Violentmonkey Scripts
// @match
// @grant       none
// @version     1.0
// @author      -
// @description
// ==/UserScript==
// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-02-16
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-02-18
// @description  try to take over the world!
// @author       You
// @match        https://discord.com/channels/@me/1328525391681552496
// @icon         https://www.google.com/s2/favicons?sz=64&domain=discord.com
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})();